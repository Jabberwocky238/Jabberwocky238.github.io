"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[2886],{5263:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var s=t(4848),r=t(8453);const a={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/statements-and-state",title:"statements-and-state",description:"All my life, my heart has yearned for a thing I cannot name.",source:"@site/docs/Craftinginterpreters/not-translated-yet/statements-and-state.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/statements-and-state",permalink:"/docs/Craftinginterpreters/not-translated-yet/statements-and-state",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/statements-and-state.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"scanning",permalink:"/docs/Craftinginterpreters/not-translated-yet/scanning"},next:{title:"strings",permalink:"/docs/Craftinginterpreters/not-translated-yet/strings"}},l={},h=[{value:"Statements",id:"statements",level:2},{value:"Statement syntax trees",id:"statement-syntax-trees",level:3},{value:"Parsing statements",id:"parsing-statements",level:3},{value:"Executing statements",id:"executing-statements",level:3},{value:"Global Variables",id:"global-variables",level:2},{value:"Variable syntax",id:"variable-syntax",level:3},{value:"Parsing variables",id:"parsing-variables",level:3},{value:"Environments",id:"environments",level:2},{value:"Interpreting global variables",id:"interpreting-global-variables",level:3},{value:"Assignment",id:"assignment",level:2},{value:"Assignment syntax",id:"assignment-syntax",level:3},{value:"Assignment semantics",id:"assignment-semantics",level:3},{value:"Scope",id:"scope",level:2},{value:"Nesting and shadowing",id:"nesting-and-shadowing",level:3},{value:"Block syntax and semantics",id:"block-syntax-and-semantics",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Implicit Variable Declaration",id:"design-note-implicit-variable-declaration",level:2}];function d(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["All my life, my heart has yearned for a thing I cannot name.\r\n",(0,s.jsxs)(n.cite,{children:["Andr\xe9 Breton, ",(0,s.jsx)(n.em,{children:"Mad Love"})]})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The interpreter we have so far feels less like programming a real language and\r\nmore like punching buttons on a calculator. \"Programming\" to me means building\r\nup a system out of smaller pieces. We can't do that yet because we have no way\r\nto bind a name to some data or function. We can't compose software without a way\r\nto refer to the pieces."}),"\n",(0,s.jsxs)(n.p,{children:["To support bindings, our interpreter needs internal state. When you define a\r\nvariable at the beginning of the program and use it at the end, the interpreter\r\nhas to hold on to the value of that variable in the meantime. So in this\r\nchapter, we will give our interpreter a brain that can not just process, but\r\n",(0,s.jsx)(n.em,{children:"remember"}),"."]}),"\n",(0,s.jsx)(n.img,{src:"image/statements-and-state/brain.png",alt:"A brain, presumably remembering stuff."}),"\n",(0,s.jsxs)(n.p,{children:["State and ",(0,s.jsx)(n.span,{name:"expr",children:"statements"})," go hand in hand. Since statements,\r\nby definition, don't evaluate to a value, they need to do something else to be\r\nuseful. That something is called a ",(0,s.jsx)(n.strong,{children:"side effect"}),". It could mean producing\r\nuser-visible output or modifying some state in the interpreter that can be\r\ndetected later. The latter makes them a great fit for defining variables or\r\nother named entities."]}),"\n",(0,s.jsxs)(n.aside,{name:"expr",children:["\n",(0,s.jsxs)(n.p,{children:["You could make a language that treats variable declarations as expressions that\r\nboth create a binding and produce a value. The only language I know that does\r\nthat is Tcl. Scheme seems like a contender, but note that after a ",(0,s.jsx)(n.code,{children:"let"}),"\r\nexpression is evaluated, the variable it bound is forgotten. The ",(0,s.jsx)(n.code,{children:"define"})," syntax\r\nis not an expression."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In this chapter, we'll do all of that. We'll define statements that produce\r\noutput (",(0,s.jsx)(n.code,{children:"print"}),") and create state (",(0,s.jsx)(n.code,{children:"var"}),"). We'll add expressions to access and\r\nassign to variables. Finally, we'll add blocks and local scope. That's a lot to\r\nstuff into one chapter, but we'll chew through it all one bite at a time."]}),"\n",(0,s.jsx)(n.h2,{id:"statements",children:"Statements"}),"\n",(0,s.jsx)(n.p,{children:"We start by extending Lox's grammar with statements. They aren't very different\r\nfrom expressions. We start with the two simplest kinds:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.strong,{children:"expression statement"})," lets you place an expression where a statement\r\nis expected. They exist to evaluate expressions that have side effects. You\r\nmay not notice them, but you use them all the time in ",(0,s.jsx)(n.span,{name:"expr-stmt",children:"C"}),", Java, and other languages. Any time you see a\r\nfunction or method call followed by a ",(0,s.jsx)(n.code,{children:";"}),", you're looking at an expression\r\nstatement."]}),"\n",(0,s.jsxs)(n.aside,{name:"expr-stmt",children:["\n",(0,s.jsxs)(n.p,{children:["Pascal is an outlier. It distinguishes between ",(0,s.jsx)(n.em,{children:"procedures"})," and ",(0,s.jsx)(n.em,{children:"functions"}),".\r\nFunctions return values, but procedures cannot. There is a statement form\r\nfor calling a procedure, but functions can only be called where an\r\nexpression is expected. There are no expression statements in Pascal."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"print"})," statement"]})," evaluates an expression and displays the result to\r\nthe user. I admit it's weird to bake printing right into the language\r\ninstead of making it a library function. Doing so is a concession to the\r\nfact that we're building this interpreter one chapter at a time and want to\r\nbe able to play with it before it's all done. To make print a library\r\nfunction, we'd have to wait until we had all of the machinery for defining\r\nand calling functions ",(0,s.jsx)(n.span,{name:"print",children:"before"})," we could witness any\r\nside effects."]}),"\n",(0,s.jsxs)(n.aside,{name:"print",children:["\n",(0,s.jsxs)(n.p,{children:["I will note with only a modicum of defensiveness that BASIC and Python\r\nhave dedicated ",(0,s.jsx)(n.code,{children:"print"})," statements and they are real languages. Granted,\r\nPython did remove their ",(0,s.jsx)(n.code,{children:"print"})," statement in 3.0..."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'New syntax means new grammar rules. In this chapter, we finally gain the ability\r\nto parse an entire Lox script. Since Lox is an imperative, dynamically typed\r\nlanguage, the "top level" of a script is simply a list of statements. The new\r\nrules are:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'program        \u2192 statement* EOF ;\r\n\r\nstatement      \u2192 exprStmt\r\n               | printStmt ;\r\n\r\nexprStmt       \u2192 expression ";" ;\r\nprintStmt      \u2192 "print" expression ";" ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The first rule is now ",(0,s.jsx)(n.code,{children:"program"}),', which is the starting point for the grammar and\r\nrepresents a complete Lox script or REPL entry. A program is a list of\r\nstatements followed by the special "end of file" token. The mandatory end token\r\nensures the parser consumes the entire input and doesn\'t silently ignore\r\nerroneous unconsumed tokens at the end of a script.']}),"\n",(0,s.jsxs)(n.p,{children:["Right now, ",(0,s.jsx)(n.code,{children:"statement"})," only has two cases for the two kinds of statements we've\r\ndescribed. We'll fill in more later in this chapter and in the following ones.\r\nThe next step is turning this grammar into something we can store in memory --\r\nsyntax trees."]}),"\n",(0,s.jsx)(n.h3,{id:"statement-syntax-trees",children:"Statement syntax trees"}),"\n",(0,s.jsxs)(n.p,{children:["There is no place in the grammar where both an expression and a statement are\r\nallowed. The operands of, say, ",(0,s.jsx)(n.code,{children:"+"})," are always expressions, never statements. The\r\nbody of a ",(0,s.jsx)(n.code,{children:"while"})," loop is always a statement."]}),"\n",(0,s.jsx)(n.p,{children:"Since the two syntaxes are disjoint, we don't need a single base class that they\r\nall inherit from. Splitting expressions and statements into separate class\r\nhierarchies enables the Java compiler to help us find dumb mistakes like passing\r\na statement to a Java method that expects an expression."}),"\n",(0,s.jsxs)(n.p,{children:['That means a new base class for statements. As our elders did before us, we will\r\nuse the cryptic name "Stmt". With great ',(0,s.jsx)(n.span,{name:"foresight",children:"foresight"}),',\r\nI have designed our little AST metaprogramming script in anticipation of this.\r\nThat\'s why we passed in "Expr" as a parameter to ',(0,s.jsx)(n.code,{children:"defineAst()"}),". Now we add\r\nanother call to define Stmt and its ",(0,s.jsx)(n.span,{name:"stmt-ast",children:"subclasses"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"foresight",children:["\n",(0,s.jsx)(n.p,{children:"Not really foresight: I wrote all the code for the book before I sliced it into\r\nchapters."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code stmt-ast (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"stmt-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new nodes is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html",children:"Appendix II"}),": ",(0,s.jsx)(n.a,{href:"appendix-ii.html#expression-statement",children:"Expression statement"}),", ",(0,s.jsx)(n.a,{href:"appendix-ii.html#print-statement",children:"Print statement"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['Run the AST generator script and behold the resulting "Stmt.java" file with the\r\nsyntax tree classes we need for expression and ',(0,s.jsx)(n.code,{children:"print"})," statements. Don't forget\r\nto add the file to your IDE project or makefile or whatever."]}),"\n",(0,s.jsx)(n.h3,{id:"parsing-statements",children:"Parsing statements"}),"\n",(0,s.jsxs)(n.p,{children:["The parser's ",(0,s.jsx)(n.code,{children:"parse()"})," method that parses and returns a single expression was a\r\ntemporary hack to get the last chapter up and running. Now that our grammar has\r\nthe correct starting rule, ",(0,s.jsx)(n.code,{children:"program"}),", we can turn ",(0,s.jsx)(n.code,{children:"parse()"})," into the real deal."]}),"\n",(0,s.jsx)(n.p,{children:"^code parse"}),"\n",(0,s.jsxs)(n.aside,{name:"parse-error-handling",children:["\n",(0,s.jsxs)(n.p,{children:["What about the code we had in here for catching ",(0,s.jsx)(n.code,{children:"ParseError"})," exceptions? We'll\r\nput better parse error handling in place soon when we add support for additional\r\nstatement types."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This parses a series of statements, as many as it can find until it hits the end\r\nof the input. This is a pretty direct translation of the ",(0,s.jsx)(n.code,{children:"program"})," rule into\r\nrecursive descent style. We must also chant a minor prayer to the Java verbosity\r\ngods since we are using ArrayList now."]}),"\n",(0,s.jsx)(n.p,{children:"^code parser-imports (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"A program is a list of statements, and we parse one of those statements using\r\nthis method:"}),"\n",(0,s.jsx)(n.p,{children:"^code parse-statement"}),"\n",(0,s.jsxs)(n.p,{children:["A little bare bones, but we'll fill it in with more statement types later. We\r\ndetermine which specific statement rule is matched by looking at the current\r\ntoken. A ",(0,s.jsx)(n.code,{children:"print"})," token means it's obviously a ",(0,s.jsx)(n.code,{children:"print"})," statement."]}),"\n",(0,s.jsx)(n.p,{children:"If the next token doesn't look like any known kind of statement, we assume it\r\nmust be an expression statement. That's the typical final fallthrough case when\r\nparsing a statement, since it's hard to proactively recognize an expression from\r\nits first token."}),"\n",(0,s.jsxs)(n.p,{children:["Each statement kind gets its own method. First ",(0,s.jsx)(n.code,{children:"print"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"^code parse-print-statement"}),"\n",(0,s.jsxs)(n.p,{children:["Since we already matched and consumed the ",(0,s.jsx)(n.code,{children:"print"})," token itself, we don't need to\r\ndo that here. We parse the subsequent expression, consume the terminating\r\nsemicolon, and emit the syntax tree."]}),"\n",(0,s.jsxs)(n.p,{children:["If we didn't match a ",(0,s.jsx)(n.code,{children:"print"})," statement, we must have one of these:"]}),"\n",(0,s.jsx)(n.p,{children:"^code parse-expression-statement"}),"\n",(0,s.jsx)(n.p,{children:"Similar to the previous method, we parse an expression followed by a semicolon.\r\nWe wrap that Expr in a Stmt of the right type and return it."}),"\n",(0,s.jsx)(n.h3,{id:"executing-statements",children:"Executing statements"}),"\n",(0,s.jsx)(n.p,{children:"We're running through the previous couple of chapters in microcosm, working our\r\nway through the front end. Our parser can now produce statement syntax trees, so\r\nthe next and final step is to interpret them. As in expressions, we use the\r\nVisitor pattern, but we have a new visitor interface, Stmt.Visitor, to\r\nimplement since statements have their own base class."}),"\n",(0,s.jsx)(n.p,{children:"We add that to the list of interfaces Interpreter implements."}),"\n",(0,s.jsx)(n.p,{children:"^code interpreter (1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"void",children:["\n",(0,s.jsx)(n.p,{children:'Java doesn\'t let you use lowercase "void" as a generic type argument for obscure\r\nreasons having to do with type erasure and the stack. Instead, there is a\r\nseparate "Void" type specifically for this use. Sort of a "boxed void", like\r\n"Integer" is for "int".'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Unlike expressions, statements produce no values, so the return type of the\r\nvisit methods is Void, not Object. We have two statement types, and we need a\r\nvisit method for each. The easiest is expression statements."}),"\n",(0,s.jsx)(n.p,{children:"^code visit-expression-stmt"}),"\n",(0,s.jsxs)(n.p,{children:["We evaluate the inner expression using our existing ",(0,s.jsx)(n.code,{children:"evaluate()"})," method and\r\n",(0,s.jsx)(n.span,{name:"discard",children:"discard"})," the value. Then we return ",(0,s.jsx)(n.code,{children:"null"}),". Java\r\nrequires that to satisfy the special capitalized Void return type. Weird, but\r\nwhat can you do?"]}),"\n",(0,s.jsxs)(n.aside,{name:"discard",children:["\n",(0,s.jsxs)(n.p,{children:["Appropriately enough, we discard the value returned by ",(0,s.jsx)(n.code,{children:"evaluate()"})," by placing\r\nthat call inside a ",(0,s.jsx)(n.em,{children:"Java"})," expression statement."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"print"})," statement's visit method isn't much different."]}),"\n",(0,s.jsx)(n.p,{children:"^code visit-print"}),"\n",(0,s.jsxs)(n.p,{children:["Before discarding the expression's value, we convert it to a string using the\r\n",(0,s.jsx)(n.code,{children:"stringify()"})," method we introduced in the last chapter and then dump it to\r\nstdout."]}),"\n",(0,s.jsxs)(n.p,{children:["Our interpreter is able to visit statements now, but we have some work to do to\r\nfeed them to it. First, modify the old ",(0,s.jsx)(n.code,{children:"interpret()"})," method in the Interpreter\r\nclass to accept a list of statements -- in other words, a program."]}),"\n",(0,s.jsx)(n.p,{children:"^code interpret"}),"\n",(0,s.jsx)(n.p,{children:"This replaces the old code which took a single expression. The new code relies\r\non this tiny helper method:"}),"\n",(0,s.jsx)(n.p,{children:"^code execute"}),"\n",(0,s.jsxs)(n.p,{children:["That's the statement analogue to the ",(0,s.jsx)(n.code,{children:"evaluate()"})," method we have for\r\nexpressions. Since we're working with lists now, we need to let Java know."]}),"\n",(0,s.jsx)(n.p,{children:"^code import-list (2 before, 2 after)"}),"\n",(0,s.jsx)(n.p,{children:"The main Lox class is still trying to parse a single expression and pass it to\r\nthe interpreter. We fix the parsing line like so:"}),"\n",(0,s.jsx)(n.p,{children:"^code parse-statements (1 before, 2 after)"}),"\n",(0,s.jsx)(n.p,{children:"And then replace the call to the interpreter with this:"}),"\n",(0,s.jsx)(n.p,{children:"^code interpret-statements (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"Basically just plumbing the new syntax through. OK, fire up the interpreter and\r\ngive it a try. At this point, it's worth sketching out a little Lox program in a\r\ntext file to run as a script. Something like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'print "one";\r\nprint true;\r\nprint 2 + 1;\n'})}),"\n",(0,s.jsx)(n.p,{children:"It almost looks like a real program! Note that the REPL, too, now requires you\r\nto enter a full statement instead of a simple expression. Don't forget your\r\nsemicolons."}),"\n",(0,s.jsx)(n.h2,{id:"global-variables",children:"Global Variables"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have statements, we can start working on state. Before we get into\r\nall of the complexity of lexical scoping, we'll start off with the easiest kind\r\nof variables -- ",(0,s.jsx)(n.span,{name:"globals",children:"globals"}),". We need two new constructs."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"variable declaration"})," statement brings a new variable into the world."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var beverage = "espresso";\n'})}),"\n",(0,s.jsxs)(n.p,{children:['This creates a new binding that associates a name (here "beverage") with a\r\nvalue (here, the string ',(0,s.jsx)(n.code,{children:'"espresso"'}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Once that's done, a ",(0,s.jsx)(n.strong,{children:"variable expression"}),' accesses that binding. When the\r\nidentifier "beverage" is used as an expression, it looks up the value bound\r\nto that name and returns it.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'print beverage; // "espresso".\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Later, we'll add assignment and block scope, but that's enough to get moving."}),"\n",(0,s.jsxs)(n.aside,{name:"globals",children:["\n",(0,s.jsxs)(n.p,{children:["Global state gets a bad rap. Sure, lots of global state -- especially ",(0,s.jsx)(n.em,{children:"mutable"}),"\r\nstate -- makes it hard to maintain large programs. It's good software\r\nengineering to minimize how much you use."]}),"\n",(0,s.jsx)(n.p,{children:"But when you're slapping together a simple programming language or, heck, even\r\nlearning your first language, the flat simplicity of global variables helps. My\r\nfirst language was BASIC and, though I outgrew it eventually, it was nice that I\r\ndidn't have to wrap my head around scoping rules before I could make a computer\r\ndo fun stuff."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"variable-syntax",children:"Variable syntax"}),"\n",(0,s.jsx)(n.p,{children:"As before, we'll work through the implementation from front to back, starting\r\nwith the syntax. Variable declarations are statements, but they are different\r\nfrom other statements, and we're going to split the statement grammar in two to\r\nhandle them. That's because the grammar restricts where some kinds of statements\r\nare allowed."}),"\n",(0,s.jsxs)(n.p,{children:["The clauses in control flow statements -- think the then and else branches of\r\nan ",(0,s.jsx)(n.code,{children:"if"})," statement or the body of a ",(0,s.jsx)(n.code,{children:"while"})," -- are each a single statement. But\r\nthat statement is not allowed to be one that declares a name. This is OK:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'if (monday) print "Ugh, already?";\n'})}),"\n",(0,s.jsx)(n.p,{children:"But this is not:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'if (monday) var beverage = "espresso";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We ",(0,s.jsx)(n.em,{children:"could"})," allow the latter, but it's confusing. What is the scope of that\r\n",(0,s.jsx)(n.code,{children:"beverage"})," variable? Does it persist after the ",(0,s.jsx)(n.code,{children:"if"})," statement? If so, what is\r\nits value on days other than Monday? Does the variable exist at all on those\r\ndays?"]}),"\n",(0,s.jsxs)(n.p,{children:["Code like this is weird, so C, Java, and friends all disallow it. It's as if\r\nthere are two levels of ",(0,s.jsx)(n.span,{name:"brace",children:'"precedence"'}),' for statements.\r\nSome places where a statement is allowed -- like inside a block or at the top\r\nlevel -- allow any kind of statement, including declarations. Others allow only\r\nthe "higher" precedence statements that don\'t declare names.']}),"\n",(0,s.jsxs)(n.aside,{name:"brace",children:["\n",(0,s.jsxs)(n.p,{children:['In this analogy, block statements work sort of like parentheses do for\r\nexpressions. A block is itself in the "higher" precedence level and can be used\r\nanywhere, like in the clauses of an ',(0,s.jsx)(n.code,{children:"if"})," statement. But the statements it\r\n",(0,s.jsx)(n.em,{children:"contains"})," can be lower precedence. You're allowed to declare variables and\r\nother names inside the block. The curlies let you escape back into the full\r\nstatement grammar from a place where only some statements are allowed."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To accommodate the distinction, we add another rule for kinds of statements that\r\ndeclare names."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:"program        \u2192 declaration* EOF ;\r\n\r\ndeclaration    \u2192 varDecl\r\n               | statement ;\r\n\r\nstatement      \u2192 exprStmt\r\n               | printStmt ;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Declaration statements go under the new ",(0,s.jsx)(n.code,{children:"declaration"})," rule. Right now, it's only\r\nvariables, but later it will include functions and classes. Any place where a\r\ndeclaration is allowed also allows non-declaring statements, so the\r\n",(0,s.jsx)(n.code,{children:"declaration"})," rule falls through to ",(0,s.jsx)(n.code,{children:"statement"}),". Obviously, you can declare\r\nstuff at the top level of a script, so ",(0,s.jsx)(n.code,{children:"program"})," routes to the new rule."]}),"\n",(0,s.jsx)(n.p,{children:"The rule for declaring a variable looks like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'varDecl        \u2192 "var" IDENTIFIER ( "=" expression )? ";" ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Like most statements, it starts with a leading keyword. In this case, ",(0,s.jsx)(n.code,{children:"var"}),".\r\nThen an identifier token for the name of the variable being declared, followed\r\nby an optional initializer expression. Finally, we put a bow on it with the\r\nsemicolon."]}),"\n",(0,s.jsx)(n.p,{children:"To access a variable, we define a new kind of primary expression."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'primary        \u2192 "true" | "false" | "nil"\r\n               | NUMBER | STRING\r\n               | "(" expression ")"\r\n               | IDENTIFIER ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["That ",(0,s.jsx)(n.code,{children:"IDENTIFIER"})," clause matches a single identifier token, which is understood\r\nto be the name of the variable being accessed."]}),"\n",(0,s.jsxs)(n.p,{children:["These new grammar rules get their corresponding syntax trees. Over in the AST\r\ngenerator, we add a ",(0,s.jsx)(n.span,{name:"var-stmt-ast",children:"new statement"})," node for a\r\nvariable declaration."]}),"\n",(0,s.jsx)(n.p,{children:"^code var-stmt-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"var-stmt-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#variable-statement",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It stores the name token so we know what it's declaring, along with the\r\ninitializer expression. (If there isn't an initializer, that field is ",(0,s.jsx)(n.code,{children:"null"}),".)"]}),"\n",(0,s.jsx)(n.p,{children:"Then we add an expression node for accessing a variable."}),"\n",(0,s.jsx)(n.p,{children:"^code var-expr (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.span,{name:"var-expr-ast",children:"It's"}),' simply a wrapper around the token for the\r\nvariable name. That\'s it. As always, don\'t forget to run the AST generator\r\nscript so that you get updated "Expr.java" and "Stmt.java" files.']}),"\n",(0,s.jsxs)(n.aside,{name:"var-expr-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#variable-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"parsing-variables",children:"Parsing variables"}),"\n",(0,s.jsxs)(n.p,{children:["Before we parse variable statements, we need to shift around some code to make\r\nroom for the new ",(0,s.jsx)(n.code,{children:"declaration"})," rule in the grammar. The top level of a program\r\nis now a list of declarations, so the entrypoint method to the parser changes."]}),"\n",(0,s.jsx)(n.p,{children:"^code parse-declaration (3 before, 4 after)"}),"\n",(0,s.jsx)(n.p,{children:"That calls this new method:"}),"\n",(0,s.jsx)(n.p,{children:"^code declaration"}),"\n",(0,s.jsxs)(n.p,{children:["Hey, do you remember way back in that ",(0,s.jsx)(n.a,{href:"parsing-expressions.html",children:"earlier chapter"})," when we put the\r\ninfrastructure in place to do error recovery? We are finally ready to hook that\r\nup."]}),"\n",(0,s.jsxs)(n.p,{children:["This ",(0,s.jsx)(n.code,{children:"declaration()"})," method is the method we call repeatedly when parsing a\r\nseries of statements in a block or a script, so it's the right place to\r\nsynchronize when the parser goes into panic mode. The whole body of this method\r\nis wrapped in a try block to catch the exception thrown when the parser begins\r\nerror recovery. This gets it back to trying to parse the beginning of the next\r\nstatement or declaration."]}),"\n",(0,s.jsxs)(n.p,{children:["The real parsing happens inside the try block. First, it looks to see if we're\r\nat a variable declaration by looking for the leading ",(0,s.jsx)(n.code,{children:"var"})," keyword. If not, it\r\nfalls through to the existing ",(0,s.jsx)(n.code,{children:"statement()"})," method that parses ",(0,s.jsx)(n.code,{children:"print"})," and\r\nexpression statements."]}),"\n",(0,s.jsxs)(n.p,{children:["Remember how ",(0,s.jsx)(n.code,{children:"statement()"})," tries to parse an expression statement if no other\r\nstatement matches? And ",(0,s.jsx)(n.code,{children:"expression()"})," reports a syntax error if it can't parse\r\nan expression at the current token? That chain of calls ensures we report an\r\nerror if a valid declaration or statement isn't parsed."]}),"\n",(0,s.jsxs)(n.p,{children:["When the parser matches a ",(0,s.jsx)(n.code,{children:"var"})," token, it branches to:"]}),"\n",(0,s.jsx)(n.p,{children:"^code parse-var-declaration"}),"\n",(0,s.jsxs)(n.p,{children:["As always, the recursive descent code follows the grammar rule. The parser has\r\nalready matched the ",(0,s.jsx)(n.code,{children:"var"})," token, so next it requires and consumes an identifier\r\ntoken for the variable name."]}),"\n",(0,s.jsxs)(n.p,{children:["Then, if it sees an ",(0,s.jsx)(n.code,{children:"="})," token, it knows there is an initializer expression and\r\nparses it. Otherwise, it leaves the initializer ",(0,s.jsx)(n.code,{children:"null"}),". Finally, it consumes the\r\nrequired semicolon at the end of the statement. All this gets wrapped in a\r\nStmt.Var syntax tree node and we're groovy."]}),"\n",(0,s.jsxs)(n.p,{children:["Parsing a variable expression is even easier. In ",(0,s.jsx)(n.code,{children:"primary()"}),", we look for an\r\nidentifier token."]}),"\n",(0,s.jsx)(n.p,{children:"^code parse-identifier (2 before, 2 after)"}),"\n",(0,s.jsx)(n.p,{children:"That gives us a working front end for declaring and using variables. All that's\r\nleft is to feed it into the interpreter. Before we get to that, we need to talk\r\nabout where variables live in memory."}),"\n",(0,s.jsx)(n.h2,{id:"environments",children:"Environments"}),"\n",(0,s.jsxs)(n.p,{children:["The bindings that associate variables to values need to be stored somewhere.\r\nEver since the Lisp folks invented parentheses, this data structure has been\r\ncalled an ",(0,s.jsx)(n.span,{name:"env",children:(0,s.jsx)(n.strong,{children:"environment"})}),"."]}),"\n",(0,s.jsx)(n.img,{src:"image/statements-and-state/environment.png",alt:"An environment containing two bindings."}),"\n",(0,s.jsxs)(n.aside,{name:"env",children:["\n",(0,s.jsx)(n.p,{children:"I like to imagine the environment literally, as a sylvan wonderland where\r\nvariables and values frolic."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can think of it like a ",(0,s.jsx)(n.span,{name:"map",children:"map"})," where the keys are\r\nvariable names and the values are the variable's, uh, values. In fact, that's\r\nhow we'll implement it in Java. We could stuff that map and the code to manage\r\nit right into Interpreter, but since it forms a nicely delineated concept, we'll\r\npull it out into its own class."]}),"\n",(0,s.jsx)(n.p,{children:"Start a new file and add:"}),"\n",(0,s.jsxs)(n.aside,{name:"map",children:["\n",(0,s.jsxs)(n.p,{children:["Java calls them ",(0,s.jsx)(n.strong,{children:"maps"})," or ",(0,s.jsx)(n.strong,{children:"hashmaps"}),". Other languages call them ",(0,s.jsx)(n.strong,{children:"hash\r\ntables"}),", ",(0,s.jsx)(n.strong,{children:"dictionaries"})," (Python and C#), ",(0,s.jsx)(n.strong,{children:"hashes"})," (Ruby and Perl),\r\n",(0,s.jsx)(n.strong,{children:"tables"})," (Lua), or ",(0,s.jsx)(n.strong,{children:"associative arrays"})," (PHP). Way back when, they were\r\nknown as ",(0,s.jsx)(n.strong,{children:"scatter tables"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code environment-class"}),"\n",(0,s.jsx)(n.p,{children:"There's a Java Map in there to store the bindings. It uses bare strings for the\r\nkeys, not tokens. A token represents a unit of code at a specific place in the\r\nsource text, but when it comes to looking up variables, all identifier tokens\r\nwith the same name should refer to the same variable (ignoring scope for now).\r\nUsing the raw string ensures all of those tokens refer to the same map key."}),"\n",(0,s.jsx)(n.p,{children:"There are two operations we need to support. First, a variable definition binds\r\na new name to a value."}),"\n",(0,s.jsx)(n.p,{children:"^code environment-define"}),"\n",(0,s.jsx)(n.p,{children:"Not exactly brain surgery, but we have made one interesting semantic choice.\r\nWhen we add the key to the map, we don't check to see if it's already present.\r\nThat means that this program works:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var a = "before";\r\nprint a; // "before".\r\nvar a = "after";\r\nprint a; // "after".\n'})}),"\n",(0,s.jsxs)(n.p,{children:["A variable statement doesn't just define a ",(0,s.jsx)(n.em,{children:"new"})," variable, it can also be used\r\nto ",(0,s.jsx)(n.em,{children:"re"}),"define an existing variable. We could ",(0,s.jsx)(n.span,{name:"scheme",children:"choose"}),"\r\nto make this an error instead. The user may not intend to redefine an existing\r\nvariable. (If they did mean to, they probably would have used assignment, not\r\n",(0,s.jsx)(n.code,{children:"var"}),".) Making redefinition an error would help them find that bug."]}),"\n",(0,s.jsx)(n.p,{children:"However, doing so interacts poorly with the REPL. In the middle of a REPL\r\nsession, it's nice to not have to mentally track which variables you've already\r\ndefined. We could allow redefinition in the REPL but not in scripts, but then\r\nusers would have to learn two sets of rules, and code copied and pasted from one\r\nform to the other might not work."}),"\n",(0,s.jsxs)(n.aside,{name:"scheme",children:["\n",(0,s.jsx)(n.p,{children:'My rule about variables and scoping is, "When in doubt, do what Scheme does".\r\nThe Scheme folks have probably spent more time thinking about variable scope\r\nthan we ever will -- one of the main goals of Scheme was to introduce lexical\r\nscoping to the world -- so it\'s hard to go wrong if you follow in their\r\nfootsteps.'}),"\n",(0,s.jsx)(n.p,{children:"Scheme allows redefining variables at the top level."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"So, to keep the two modes consistent, we'll allow it -- at least for global\r\nvariables. Once a variable exists, we need a way to look it up."}),"\n",(0,s.jsx)(n.p,{children:"^code environment-get (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"This is a little more semantically interesting. If the variable is found, it\r\nsimply returns the value bound to it. But what if it's not? Again, we have a\r\nchoice:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Make it a syntax error."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Make it a runtime error."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Allow it and return some default value like ",(0,s.jsx)(n.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Lox is pretty lax, but the last option is a little ",(0,s.jsx)(n.em,{children:"too"})," permissive to me.\r\nMaking it a syntax error -- a compile-time error -- seems like a smart choice.\r\nUsing an undefined variable is a bug, and the sooner you detect the mistake, the\r\nbetter."]}),"\n",(0,s.jsxs)(n.p,{children:["The problem is that ",(0,s.jsx)(n.em,{children:"using"})," a variable isn't the same as ",(0,s.jsx)(n.em,{children:"referring"})," to it. You\r\ncan refer to a variable in a chunk of code without immediately evaluating it if\r\nthat chunk of code is wrapped inside a function. If we make it a static error to\r\n",(0,s.jsx)(n.em,{children:"mention"})," a variable before it's been declared, it becomes much harder to define\r\nrecursive functions."]}),"\n",(0,s.jsx)(n.p,{children:"We could accommodate single recursion -- a function that calls itself -- by\r\ndeclaring the function's own name before we examine its body. But that doesn't\r\nhelp with mutually recursive procedures that call each other. Consider:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.span,{name:"contrived"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"fun isOdd(n) {\r\n  if (n == 0) return false;\r\n  return isEven(n - 1);\r\n}\r\n\r\nfun isEven(n) {\r\n  if (n == 0) return true;\r\n  return isOdd(n - 1);\r\n}\n"})}),"\n",(0,s.jsxs)(n.aside,{name:"contrived",children:["\n",(0,s.jsx)(n.p,{children:"Granted, this is probably not the most efficient way to tell if a number is even\r\nor odd (not to mention the bad things that happen if you pass a non-integer or\r\nnegative number to them). Bear with me."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"isEven()"})," function isn't defined by the ",(0,s.jsx)(n.span,{name:"declare",children:"time"})," we\r\nare looking at the body of ",(0,s.jsx)(n.code,{children:"isOdd()"})," where it's called. If we swap the order of\r\nthe two functions, then ",(0,s.jsx)(n.code,{children:"isOdd()"})," isn't defined when we're looking at\r\n",(0,s.jsx)(n.code,{children:"isEven()"}),"'s body."]}),"\n",(0,s.jsxs)(n.aside,{name:"declare",children:["\n",(0,s.jsxs)(n.p,{children:["Some statically typed languages like Java and C# solve this by specifying that\r\nthe top level of a program isn't a sequence of imperative statements. Instead, a\r\nprogram is a set of declarations which all come into being simultaneously. The\r\nimplementation declares ",(0,s.jsx)(n.em,{children:"all"})," of the names before looking at the bodies of ",(0,s.jsx)(n.em,{children:"any"}),"\r\nof the functions."]}),"\n",(0,s.jsxs)(n.p,{children:["Older languages like C and Pascal don't work like this. Instead, they force you\r\nto add explicit ",(0,s.jsx)(n.em,{children:"forward declarations"})," to declare a name before it's fully\r\ndefined. That was a concession to the limited computing power at the time. They\r\nwanted to be able to compile a source file in one single pass through the text,\r\nso those compilers couldn't gather up all of the declarations first before\r\nprocessing function bodies."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Since making it a ",(0,s.jsx)(n.em,{children:"static"})," error makes recursive declarations too difficult,\r\nwe'll defer the error to runtime. It's OK to refer to a variable before it's\r\ndefined as long as you don't ",(0,s.jsx)(n.em,{children:"evaluate"})," the reference. That lets the program\r\nfor even and odd numbers work, but you'd get a runtime error in:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'print a;\r\nvar a = "too late!";\n'})}),"\n",(0,s.jsx)(n.p,{children:"As with type errors in the expression evaluation code, we report a runtime error\r\nby throwing an exception. The exception contains the variable's token so we can\r\ntell the user where in their code they messed up."}),"\n",(0,s.jsx)(n.h3,{id:"interpreting-global-variables",children:"Interpreting global variables"}),"\n",(0,s.jsx)(n.p,{children:"The Interpreter class gets an instance of the new Environment class."}),"\n",(0,s.jsx)(n.p,{children:"^code environment-field (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"We store it as a field directly in Interpreter so that the variables stay in\r\nmemory as long as the interpreter is still running."}),"\n",(0,s.jsx)(n.p,{children:"We have two new syntax trees, so that's two new visit methods. The first is for\r\ndeclaration statements."}),"\n",(0,s.jsx)(n.p,{children:"^code visit-var"}),"\n",(0,s.jsxs)(n.p,{children:["If the variable has an initializer, we evaluate it. If not, we have another\r\nchoice to make. We could have made this a syntax error in the parser by\r\n",(0,s.jsx)(n.em,{children:"requiring"})," an initializer. Most languages don't, though, so it feels a little\r\nharsh to do so in Lox."]}),"\n",(0,s.jsxs)(n.p,{children:["We could make it a runtime error. We'd let you define an uninitialized variable,\r\nbut if you accessed it before assigning to it, a runtime error would occur. It's\r\nnot a bad idea, but most dynamically typed languages don't do that. Instead,\r\nwe'll keep it simple and say that Lox sets a variable to ",(0,s.jsx)(n.code,{children:"nil"})," if it isn't\r\nexplicitly initialized."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var a;\r\nprint a; // "nil".\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Thus, if there isn't an initializer, we set the value to ",(0,s.jsx)(n.code,{children:"null"}),", which is the\r\nJava representation of Lox's ",(0,s.jsx)(n.code,{children:"nil"})," value. Then we tell the environment to bind\r\nthe variable to that value."]}),"\n",(0,s.jsx)(n.p,{children:"Next, we evaluate a variable expression."}),"\n",(0,s.jsx)(n.p,{children:"^code visit-variable"}),"\n",(0,s.jsx)(n.p,{children:"This simply forwards to the environment which does the heavy lifting to make\r\nsure the variable is defined. With that, we've got rudimentary variables\r\nworking. Try this out:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var a = 1;\r\nvar b = 2;\r\nprint a + b;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can't reuse ",(0,s.jsx)(n.em,{children:"code"})," yet, but we can start to build up programs that reuse\r\n",(0,s.jsx)(n.em,{children:"data"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"assignment",children:"Assignment"}),"\n",(0,s.jsxs)(n.p,{children:["It's possible to create a language that has variables but does not let you\r\nreassign -- or ",(0,s.jsx)(n.strong,{children:"mutate"})," -- them. Haskell is one example. SML supports only\r\nmutable references and arrays -- variables cannot be reassigned. Rust steers you\r\naway from mutation by requiring a ",(0,s.jsx)(n.code,{children:"mut"})," modifier to enable assignment."]}),"\n",(0,s.jsxs)(n.p,{children:["Mutating a variable is a side effect and, as the name suggests, some language\r\nfolks think side effects are ",(0,s.jsx)(n.span,{name:"pure",children:"dirty"})," or inelegant. Code\r\nshould be pure math that produces values -- crystalline, unchanging ones -- like\r\nan act of divine creation. Not some grubby automaton that beats blobs of data\r\ninto shape, one imperative grunt at a time."]}),"\n",(0,s.jsxs)(n.aside,{name:"pure",children:["\n",(0,s.jsx)(n.p,{children:'I find it delightful that the same group of people who pride themselves on\r\ndispassionate logic are also the ones who can\'t resist emotionally loaded terms\r\nfor their work: "pure", "side effect", "lazy", "persistent", "first-class",\r\n"higher-order".'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Lox is not so austere. Lox is an imperative language, and mutation comes with\r\nthe territory. Adding support for assignment doesn't require much work. Global\r\nvariables already support redefinition, so most of the machinery is there now.\r\nMainly, we're missing an explicit assignment notation."}),"\n",(0,s.jsx)(n.h3,{id:"assignment-syntax",children:"Assignment syntax"}),"\n",(0,s.jsxs)(n.p,{children:["That little ",(0,s.jsx)(n.code,{children:"="})," syntax is more complex than it might seem. Like most C-derived\r\nlanguages, assignment is an ",(0,s.jsx)(n.span,{name:"assign",children:"expression"})," and not a\r\nstatement. As in C, it is the lowest precedence expression form. That means the\r\nrule slots between ",(0,s.jsx)(n.code,{children:"expression"})," and ",(0,s.jsx)(n.code,{children:"equality"})," (the next lowest precedence\r\nexpression)."]}),"\n",(0,s.jsxs)(n.aside,{name:"assign",children:["\n",(0,s.jsx)(n.p,{children:"In some other languages, like Pascal, Python, and Go, assignment is a statement."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'expression     \u2192 assignment ;\r\nassignment     \u2192 IDENTIFIER "=" assignment\r\n               | equality ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This says an ",(0,s.jsx)(n.code,{children:"assignment"})," is either an identifier followed by an ",(0,s.jsx)(n.code,{children:"="})," and an\r\nexpression for the value, or an ",(0,s.jsx)(n.code,{children:"equality"})," (and thus any other) expression.\r\nLater, ",(0,s.jsx)(n.code,{children:"assignment"})," will get more complex when we add property setters on\r\nobjects, like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'instance.field = "value";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The easy part is adding the ",(0,s.jsx)(n.span,{name:"assign-ast",children:"new syntax tree node"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"^code assign-expr (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"assign-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#assign-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It has a token for the variable being assigned to, and an expression for the new\r\nvalue. After you run the AstGenerator to get the new Expr.Assign class, swap out\r\nthe body of the parser's existing ",(0,s.jsx)(n.code,{children:"expression()"})," method to match the updated\r\nrule."]}),"\n",(0,s.jsx)(n.p,{children:"^code expression (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["Here is where it gets tricky. A single token lookahead recursive descent parser\r\ncan't see far enough to tell that it's parsing an assignment until ",(0,s.jsx)(n.em,{children:"after"})," it\r\nhas gone through the left-hand side and stumbled onto the ",(0,s.jsx)(n.code,{children:"="}),". You might wonder\r\nwhy it even needs to. After all, we don't know we're parsing a ",(0,s.jsx)(n.code,{children:"+"})," expression\r\nuntil after we've finished parsing the left operand."]}),"\n",(0,s.jsx)(n.p,{children:"The difference is that the left-hand side of an assignment isn't an expression\r\nthat evaluates to a value. It's a sort of pseudo-expression that evaluates to a\r\n\"thing\" you can assign to. Consider:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var a = "before";\r\na = "value";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["On the second line, we don't ",(0,s.jsx)(n.em,{children:"evaluate"})," ",(0,s.jsx)(n.code,{children:"a"}),' (which would return the string\r\n"before"). We figure out what variable ',(0,s.jsx)(n.code,{children:"a"})," refers to so we know where to store\r\nthe right-hand side expression's value. The ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue",children:"classic terms"})," for these\r\ntwo ",(0,s.jsx)(n.span,{name:"l-value",children:"constructs"})," are ",(0,s.jsx)(n.strong,{children:"l-value"})," and ",(0,s.jsx)(n.strong,{children:"r-value"}),'. All\r\nof the expressions that we\'ve seen so far that produce values are r-values. An\r\nl-value "evaluates" to a storage location that you can assign into.']}),"\n",(0,s.jsxs)(n.aside,{name:"l-value",children:["\n",(0,s.jsxs)(n.p,{children:["In fact, the names come from assignment expressions: ",(0,s.jsx)(n.em,{children:"l"}),"-values appear on the\r\n",(0,s.jsx)(n.em,{children:"left"})," side of the ",(0,s.jsx)(n.code,{children:"="})," in an assignment, and ",(0,s.jsx)(n.em,{children:"r"}),"-values on the ",(0,s.jsx)(n.em,{children:"right"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We want the syntax tree to reflect that an l-value isn't evaluated like a normal\r\nexpression. That's why the Expr.Assign node has a ",(0,s.jsx)(n.em,{children:"Token"})," for the left-hand\r\nside, not an Expr. The problem is that the parser doesn't know it's parsing an\r\nl-value until it hits the ",(0,s.jsx)(n.code,{children:"="}),". In a complex l-value, that may occur ",(0,s.jsx)(n.span,{name:"many",children:"many"})," tokens later."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"makeList().head.next = node;\n"})}),"\n",(0,s.jsxs)(n.aside,{name:"many",children:["\n",(0,s.jsxs)(n.p,{children:["Since the receiver of a field assignment can be any expression, and expressions\r\ncan be as long as you want to make them, it may take an ",(0,s.jsx)(n.em,{children:"unbounded"})," number of\r\ntokens of lookahead to find the ",(0,s.jsx)(n.code,{children:"="}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We have only a single token of lookahead, so what do we do? We use a little\r\ntrick, and it looks like this:"}),"\n",(0,s.jsx)(n.p,{children:"^code parse-assignment"}),"\n",(0,s.jsxs)(n.p,{children:["Most of the code for parsing an assignment expression looks similar to that of\r\nthe other binary operators like ",(0,s.jsx)(n.code,{children:"+"}),". We parse the left-hand side, which can be\r\nany expression of higher precedence. If we find an ",(0,s.jsx)(n.code,{children:"="}),", we parse the right-hand\r\nside and then wrap it all up in an assignment expression tree node."]}),"\n",(0,s.jsxs)(n.aside,{name:"no-throw",children:["\n",(0,s.jsxs)(n.p,{children:["We ",(0,s.jsx)(n.em,{children:"report"})," an error if the left-hand side isn't a valid assignment target, but\r\nwe don't ",(0,s.jsx)(n.em,{children:"throw"})," it because the parser isn't in a confused state where we need\r\nto go into panic mode and synchronize."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["One slight difference from binary operators is that we don't loop to build up a\r\nsequence of the same operator. Since assignment is right-associative, we instead\r\nrecursively call ",(0,s.jsx)(n.code,{children:"assignment()"})," to parse the right-hand side."]}),"\n",(0,s.jsx)(n.p,{children:"The trick is that right before we create the assignment expression node, we look\r\nat the left-hand side expression and figure out what kind of assignment target\r\nit is. We convert the r-value expression node into an l-value representation."}),"\n",(0,s.jsxs)(n.p,{children:["This conversion works because it turns out that every valid assignment target\r\nhappens to also be ",(0,s.jsx)(n.span,{name:"converse",children:"valid syntax"})," as a normal\r\nexpression. Consider a complex field assignment like:"]}),"\n",(0,s.jsxs)(n.aside,{name:"converse",children:["\n",(0,s.jsxs)(n.p,{children:["You can still use this trick even if there are assignment targets that are not\r\nvalid expressions. Define a ",(0,s.jsx)(n.strong,{children:"cover grammar"}),", a looser grammar that accepts\r\nall of the valid expression ",(0,s.jsx)(n.em,{children:"and"})," assignment target syntaxes. When you hit\r\nan ",(0,s.jsx)(n.code,{children:"="}),", report an error if the left-hand side isn't within the valid assignment\r\ntarget grammar. Conversely, if you ",(0,s.jsx)(n.em,{children:"don't"})," hit an ",(0,s.jsx)(n.code,{children:"="}),", report an error if the\r\nleft-hand side isn't a valid ",(0,s.jsx)(n.em,{children:"expression"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"newPoint(x + 2, 0).y = 3;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The left-hand side of that assignment could also work as a valid expression."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"newPoint(x + 2, 0).y;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The first example sets the field, the second gets it."}),"\n",(0,s.jsxs)(n.p,{children:["This means we can parse the left-hand side ",(0,s.jsx)(n.em,{children:"as if it were"})," an expression and\r\nthen after the fact produce a syntax tree that turns it into an assignment\r\ntarget. If the left-hand side expression isn't a ",(0,s.jsx)(n.span,{name:"paren",children:"valid"}),"\r\nassignment target, we fail with a syntax error. That ensures we report an error\r\non code like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"a + b = c;\n"})}),"\n",(0,s.jsxs)(n.aside,{name:"paren",children:["\n",(0,s.jsx)(n.p,{children:"Way back in the parsing chapter, I said we represent parenthesized expressions\r\nin the syntax tree because we'll need them later. This is why. We need to be\r\nable to distinguish these cases:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"a = 3;   // OK.\r\n(a) = 3; // Error.\n"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Right now, the only valid target is a simple variable expression, but we'll add\r\nfields later. The end result of this trick is an assignment expression tree node\r\nthat knows what it is assigning to and has an expression subtree for the value\r\nbeing assigned. All with only a single token of lookahead and no backtracking."}),"\n",(0,s.jsx)(n.h3,{id:"assignment-semantics",children:"Assignment semantics"}),"\n",(0,s.jsx)(n.p,{children:"We have a new syntax tree node, so our interpreter gets a new visit method."}),"\n",(0,s.jsx)(n.p,{children:"^code visit-assign"}),"\n",(0,s.jsxs)(n.p,{children:["For obvious reasons, it's similar to variable declaration. It evaluates the\r\nright-hand side to get the value, then stores it in the named variable. Instead\r\nof using ",(0,s.jsx)(n.code,{children:"define()"})," on Environment, it calls this new method:"]}),"\n",(0,s.jsx)(n.p,{children:"^code environment-assign"}),"\n",(0,s.jsxs)(n.p,{children:["The key difference between assignment and definition is that assignment is not\r\n",(0,s.jsx)(n.span,{name:"new",children:"allowed"})," to create a ",(0,s.jsx)(n.em,{children:"new"})," variable. In terms of our\r\nimplementation, that means it's a runtime error if the key doesn't already exist\r\nin the environment's variable map."]}),"\n",(0,s.jsxs)(n.aside,{name:"new",children:["\n",(0,s.jsxs)(n.p,{children:["Unlike Python and Ruby, Lox doesn't do ",(0,s.jsx)(n.a,{href:"#design-note",children:"implicit variable declaration"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The last thing the ",(0,s.jsx)(n.code,{children:"visit()"})," method does is return the assigned value. That's\r\nbecause assignment is an expression that can be nested inside other expressions,\r\nlike so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var a = 1;\r\nprint a = 2; // "2".\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Our interpreter can now create, read, and modify variables. It's about as\r\nsophisticated as early ",(0,s.jsx)(n.span,{name:"basic",children:"BASICs"}),". Global variables are\r\nsimple, but writing a large program when any two chunks of code can accidentally\r\nstep on each other's state is no fun. We want ",(0,s.jsx)(n.em,{children:"local"})," variables, which means\r\nit's time for ",(0,s.jsx)(n.em,{children:"scope"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"basic",children:["\n",(0,s.jsx)(n.p,{children:"Maybe a little better than that. Unlike some old BASICs, Lox can handle variable\r\nnames longer than two characters."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"scope",children:"Scope"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"scope"}),' defines a region where a name maps to a certain entity. Multiple\r\nscopes enable the same name to refer to different things in different contexts.\r\nIn my house, "Bob" usually refers to me. But maybe in your town you know a\r\ndifferent Bob. Same name, but different dudes based on where you say it.']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.span,{name:"lexical",children:(0,s.jsx)(n.strong,{children:"Lexical scope"})})," (or the less commonly heard\r\n",(0,s.jsx)(n.strong,{children:"static scope"}),") is a specific style of scoping where the text of the program\r\nitself shows where a scope begins and ends. In Lox, as in most modern languages,\r\nvariables are lexically scoped. When you see an expression that uses some\r\nvariable, you can figure out which variable declaration it refers to just by\r\nstatically reading the code."]}),"\n",(0,s.jsxs)(n.aside,{name:"lexical",children:["\n",(0,s.jsx)(n.p,{children:'"Lexical" comes from the Greek "lexikos" which means "related to words". When we\r\nuse it in programming languages, it usually means a thing you can figure out\r\nfrom source code itself without having to execute anything.'}),"\n",(0,s.jsx)(n.p,{children:"Lexical scope came onto the scene with ALGOL. Earlier languages were often\r\ndynamically scoped. Computer scientists back then believed dynamic scope was\r\nfaster to execute. Today, thanks to early Scheme hackers, we know that isn't\r\ntrue. If anything, it's the opposite."}),"\n",(0,s.jsxs)(n.p,{children:["Dynamic scope for variables lives on in some corners. Emacs Lisp defaults to\r\ndynamic scope for variables. The ",(0,s.jsx)(n.a,{href:"http://clojuredocs.org/clojure.core/binding",children:(0,s.jsx)(n.code,{children:"binding"})})," macro in Clojure provides\r\nit. The widely disliked ",(0,s.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with",children:[(0,s.jsx)(n.code,{children:"with"})," statement"]})," in JavaScript turns properties\r\non an object into dynamically scoped variables."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'{\r\n  var a = "first";\r\n  print a; // "first".\r\n}\r\n\r\n{\r\n  var a = "second";\r\n  print a; // "second".\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, we have two blocks with a variable ",(0,s.jsx)(n.code,{children:"a"})," declared in each of them. You and\r\nI can tell just from looking at the code that the use of ",(0,s.jsx)(n.code,{children:"a"})," in the first\r\n",(0,s.jsx)(n.code,{children:"print"})," statement refers to the first ",(0,s.jsx)(n.code,{children:"a"}),", and the second one refers to the\r\nsecond."]}),"\n",(0,s.jsx)(n.img,{src:"image/statements-and-state/blocks.png",alt:"An environment for each 'a'."}),"\n",(0,s.jsxs)(n.p,{children:["This is in contrast to ",(0,s.jsx)(n.strong,{children:"dynamic scope"})," where you don't know what a name refers\r\nto until you execute the code. Lox doesn't have dynamically scoped ",(0,s.jsx)(n.em,{children:"variables"}),",\r\nbut methods and fields on objects are dynamically scoped."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Saxophone {\r\n  play() {\r\n    print "Careless Whisper";\r\n  }\r\n}\r\n\r\nclass GolfClub {\r\n  play() {\r\n    print "Fore!";\r\n  }\r\n}\r\n\r\nfun playIt(thing) {\r\n  thing.play();\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"playIt()"})," calls ",(0,s.jsx)(n.code,{children:"thing.play()"}),', we don\'t know if we\'re about to hear\r\n"Careless Whisper" or "Fore!" It depends on whether you pass a Saxophone or a\r\nGolfClub to the function, and we don\'t know that until runtime.']}),"\n",(0,s.jsxs)(n.p,{children:["Scope and environments are close cousins. The former is the theoretical concept,\r\nand the latter is the machinery that implements it. As our interpreter works its\r\nway through code, syntax tree nodes that affect scope will change the\r\nenvironment. In a C-ish syntax like Lox's, scope is controlled by curly-braced\r\nblocks. (That's why we call it ",(0,s.jsx)(n.strong,{children:"block scope"}),".)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'{\r\n  var a = "in block";\r\n}\r\nprint a; // Error! No more "a".\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The beginning of a block introduces a new local scope, and that scope ends when\r\nexecution passes the closing ",(0,s.jsx)(n.code,{children:"}"}),". Any variables declared inside the block\r\ndisappear."]}),"\n",(0,s.jsx)(n.h3,{id:"nesting-and-shadowing",children:"Nesting and shadowing"}),"\n",(0,s.jsx)(n.p,{children:"A first cut at implementing block scope might work like this:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"As we visit each statement inside the block, keep track of any variables\r\ndeclared."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"After the last statement is executed, tell the environment to delete all of\r\nthose variables."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"That would work for the previous example. But remember, one motivation for\r\nlocal scope is encapsulation -- a block of code in one corner of the program\r\nshouldn't interfere with some other block. Check this out:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"// How loud?\r\nvar volume = 11;\r\n\r\n// Silence.\r\nvolume = 0;\r\n\r\n// Calculate size of 3x4x5 cuboid.\r\n{\r\n  var volume = 3 * 4 * 5;\r\n  print volume;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Look at the block where we calculate the volume of the cuboid using a local\r\ndeclaration of ",(0,s.jsx)(n.code,{children:"volume"}),". After the block exits, the interpreter will delete the\r\n",(0,s.jsx)(n.em,{children:"global"})," ",(0,s.jsx)(n.code,{children:"volume"})," variable. That ain't right. When we exit the block, we should\r\nremove any variables declared inside the block, but if there is a variable with\r\nthe same name declared outside of the block, ",(0,s.jsx)(n.em,{children:"that's a different variable"}),". It\r\nshouldn't get touched."]}),"\n",(0,s.jsxs)(n.p,{children:["When a local variable has the same name as a variable in an enclosing scope, it\r\n",(0,s.jsx)(n.strong,{children:"shadows"})," the outer one. Code inside the block can't see it any more -- it is\r\nhidden in the \"shadow\" cast by the inner one -- but it's still there."]}),"\n",(0,s.jsx)(n.p,{children:"When we enter a new block scope, we need to preserve variables defined in outer\r\nscopes so they are still around when we exit the inner block. We do that by\r\ndefining a fresh environment for each block containing only the variables\r\ndefined in that scope. When we exit the block, we discard its environment and\r\nrestore the previous one."}),"\n",(0,s.jsxs)(n.p,{children:["We also need to handle enclosing variables that are ",(0,s.jsx)(n.em,{children:"not"})," shadowed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var global = "outside";\r\n{\r\n  var local = "inside";\r\n  print global + local;\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"global"})," lives in the outer global environment and ",(0,s.jsx)(n.code,{children:"local"})," is defined\r\ninside the block's environment. In that ",(0,s.jsx)(n.code,{children:"print"})," statement, both of those\r\nvariables are in scope. In order to find them, the interpreter must search not\r\nonly the current innermost environment, but also any enclosing ones."]}),"\n",(0,s.jsxs)(n.p,{children:["We implement this by ",(0,s.jsx)(n.span,{name:"cactus",children:"chaining"})," the environments\r\ntogether. Each environment has a reference to the environment of the immediately\r\nenclosing scope. When we look up a variable, we walk that chain from innermost\r\nout until we find the variable. Starting at the inner scope is how we make local\r\nvariables shadow outer ones."]}),"\n",(0,s.jsx)(n.img,{src:"image/statements-and-state/chaining.png",alt:"Environments for each scope, linked together."}),"\n",(0,s.jsxs)(n.aside,{name:"cactus",children:["\n",(0,s.jsx)(n.p,{children:"While the interpreter is running, the environments form a linear list of\r\nobjects, but consider the full set of environments created during the entire\r\nexecution. An outer scope may have multiple blocks nested within it, and each\r\nwill point to the outer one, giving a tree-like structure, though only one path\r\nthrough the tree exists at a time."}),"\n",(0,s.jsxs)(n.p,{children:["The boring name for this is a ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Parent_pointer_tree",children:(0,s.jsx)(n.strong,{children:"parent-pointer tree"})}),", but I\r\nmuch prefer the evocative ",(0,s.jsx)(n.strong,{children:"cactus stack"}),"."]}),"\n",(0,s.jsx)(n.img,{className:"above",src:"image/statements-and-state/cactus.png",alt:"Each branch points to its parent. The root is global scope."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Before we add block syntax to the grammar, we'll beef up our Environment class\r\nwith support for this nesting. First, we give each environment a reference to\r\nits enclosing one."}),"\n",(0,s.jsx)(n.p,{children:"^code enclosing-field (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"This field needs to be initialized, so we add a couple of constructors."}),"\n",(0,s.jsx)(n.p,{children:"^code environment-constructors"}),"\n",(0,s.jsx)(n.p,{children:"The no-argument constructor is for the global scope's environment, which ends\r\nthe chain. The other constructor creates a new local scope nested inside the\r\ngiven outer one."}),"\n",(0,s.jsxs)(n.p,{children:["We don't have to touch the ",(0,s.jsx)(n.code,{children:"define()"})," method -- a new variable is always\r\ndeclared in the current innermost scope. But variable lookup and assignment work\r\nwith existing variables and they need to walk the chain to find them. First,\r\nlookup:"]}),"\n",(0,s.jsx)(n.p,{children:"^code environment-get-enclosing (2 before, 3 after)"}),"\n",(0,s.jsxs)(n.p,{children:["If the variable isn't found in this environment, we simply try the enclosing\r\none. That in turn does the same thing ",(0,s.jsx)(n.span,{name:"recurse",children:"recursively"}),",\r\nso this will ultimately walk the entire chain. If we reach an environment with\r\nno enclosing one and still don't find the variable, then we give up and report\r\nan error as before."]}),"\n",(0,s.jsx)(n.p,{children:"Assignment works the same way."}),"\n",(0,s.jsxs)(n.aside,{name:"recurse",children:["\n",(0,s.jsxs)(n.p,{children:["It's likely faster to iteratively walk the chain, but I think the recursive\r\nsolution is prettier. We'll do something ",(0,s.jsx)(n.em,{children:"much"})," faster in clox."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code environment-assign-enclosing (4 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"Again, if the variable isn't in this environment, it checks the outer one,\r\nrecursively."}),"\n",(0,s.jsx)(n.h3,{id:"block-syntax-and-semantics",children:"Block syntax and semantics"}),"\n",(0,s.jsx)(n.p,{children:"Now that Environments nest, we're ready to add blocks to the language. Behold\r\nthe grammar:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'statement      \u2192 exprStmt\r\n               | printStmt\r\n               | block ;\r\n\r\nblock          \u2192 "{" declaration* "}" ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["A block is a (possibly empty) series of statements or declarations surrounded by\r\ncurly braces. A block is itself a statement and can appear anywhere a statement\r\nis allowed. The ",(0,s.jsx)(n.span,{name:"block-ast",children:"syntax tree"})," node looks like this:"]}),"\n",(0,s.jsx)(n.p,{children:"^code block-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"block-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#block-statement",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.span,{name:"generate",children:"It"})," contains the list of statements that are inside\r\nthe block. Parsing is straightforward. Like other statements, we detect the\r\nbeginning of a block by its leading token -- in this case the ",(0,s.jsx)(n.code,{children:"{"}),". In the\r\n",(0,s.jsx)(n.code,{children:"statement()"})," method, we add:"]}),"\n",(0,s.jsxs)(n.aside,{name:"generate",children:["\n",(0,s.jsx)(n.p,{children:'As always, don\'t forget to run "GenerateAst.java".'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code parse-block (1 before, 2 after)"}),"\n",(0,s.jsx)(n.p,{children:"All the real work happens here:"}),"\n",(0,s.jsx)(n.p,{children:"^code block"}),"\n",(0,s.jsxs)(n.p,{children:["We ",(0,s.jsx)(n.span,{name:"list",children:"create"})," an empty list and then parse statements and\r\nadd them to the list until we reach the end of the block, marked by the closing\r\n",(0,s.jsx)(n.code,{children:"}"}),". Note that the loop also has an explicit check for ",(0,s.jsx)(n.code,{children:"isAtEnd()"}),". We have to\r\nbe careful to avoid infinite loops, even when parsing invalid code. If the user\r\nforgets a closing ",(0,s.jsx)(n.code,{children:"}"}),", the parser needs to not get stuck."]}),"\n",(0,s.jsxs)(n.aside,{name:"list",children:["\n",(0,s.jsxs)(n.p,{children:["Having ",(0,s.jsx)(n.code,{children:"block()"})," return the raw list of statements and leaving it to\r\n",(0,s.jsx)(n.code,{children:"statement()"})," to wrap the list in a Stmt.Block looks a little odd. I did it that\r\nway because we'll reuse ",(0,s.jsx)(n.code,{children:"block()"})," later for parsing function bodies and we don't\r\nwant that body wrapped in a Stmt.Block."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"That's it for syntax. For semantics, we add another visit method to Interpreter."}),"\n",(0,s.jsx)(n.p,{children:"^code visit-block"}),"\n",(0,s.jsx)(n.p,{children:"To execute a block, we create a new environment for the block's scope and pass\r\nit off to this other method:"}),"\n",(0,s.jsx)(n.p,{children:"^code execute-block"}),"\n",(0,s.jsxs)(n.p,{children:["This new method executes a list of statements in the context of a given ",(0,s.jsx)(n.span,{name:"param",children:"environment"}),". Up until now, the ",(0,s.jsx)(n.code,{children:"environment"})," field in\r\nInterpreter always pointed to the same environment -- the global one. Now, that\r\nfield represents the ",(0,s.jsx)(n.em,{children:"current"})," environment. That's the environment that\r\ncorresponds to the innermost scope containing the code to be executed."]}),"\n",(0,s.jsxs)(n.p,{children:["To execute code within a given scope, this method updates the interpreter's\r\n",(0,s.jsx)(n.code,{children:"environment"})," field, visits all of the statements, and then restores the\r\nprevious value. As is always good practice in Java, it restores the previous\r\nenvironment using a finally clause. That way it gets restored even if an\r\nexception is thrown."]}),"\n",(0,s.jsxs)(n.aside,{name:"param",children:["\n",(0,s.jsxs)(n.p,{children:["Manually changing and restoring a mutable ",(0,s.jsx)(n.code,{children:"environment"})," field feels inelegant.\r\nAnother classic approach is to explicitly pass the environment as a parameter to\r\neach visit method. To \"change\" the environment, you pass a different one as you\r\nrecurse down the tree. You don't have to restore the old one, since the new one\r\nlives on the Java stack and is implicitly discarded when the interpreter returns\r\nfrom the block's visit method."]}),"\n",(0,s.jsx)(n.p,{children:"I considered that for jlox, but it's kind of tedious and verbose adding an\r\nenvironment parameter to every single visit method. To keep the book a little\r\nsimpler, I went with the mutable field."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Surprisingly, that's all we need to do in order to fully support local\r\nvariables, nesting, and shadowing. Go ahead and try this out:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var a = "global a";\r\nvar b = "global b";\r\nvar c = "global c";\r\n{\r\n  var a = "outer a";\r\n  var b = "outer b";\r\n  {\r\n    var a = "inner a";\r\n    print a;\r\n    print b;\r\n    print c;\r\n  }\r\n  print a;\r\n  print b;\r\n  print c;\r\n}\r\nprint a;\r\nprint b;\r\nprint c;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Our little interpreter can remember things now. We are inching closer to\r\nsomething resembling a full-featured programming language."}),"\n",(0,s.jsxs)(n.div,{className:"challenges",children:["\n",(0,s.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The REPL no longer supports entering a single expression and automatically\r\nprinting its result value. That's a drag. Add support to the REPL to let\r\nusers type in both statements and expressions. If they enter a statement,\r\nexecute it. If they enter an expression, evaluate it and display the result\r\nvalue."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Maybe you want Lox to be a little more explicit about variable\r\ninitialization. Instead of implicitly initializing variables to ",(0,s.jsx)(n.code,{children:"nil"}),", make\r\nit a runtime error to access a variable that has not been initialized or\r\nassigned to, as in:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'// No initializers.\r\nvar a;\r\nvar b;\r\n\r\na = "assigned";\r\nprint a; // OK, was assigned first.\r\n\r\nprint b; // Error!\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"What does the following program do?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var a = 1;\r\n{\r\n  var a = a + 2;\r\n  print a;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["What did you ",(0,s.jsx)(n.em,{children:"expect"})," it to do? Is it what you think it should do? What\r\ndoes analogous code in other languages you are familiar with do? What do\r\nyou think users will expect this to do?"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.div,{className:"design-note",children:["\n",(0,s.jsx)(n.h2,{id:"design-note-implicit-variable-declaration",children:"Design Note: Implicit Variable Declaration"}),"\n",(0,s.jsxs)(n.p,{children:["Lox has distinct syntax for declaring a new variable and assigning to an\r\nexisting one. Some languages collapse those to only assignment syntax. Assigning\r\nto a non-existent variable automatically brings it into being. This is called\r\n",(0,s.jsx)(n.strong,{children:"implicit variable declaration"})," and exists in Python, Ruby, and CoffeeScript,\r\namong others. JavaScript has an explicit syntax to declare variables, but can\r\nalso create new variables on assignment. Visual Basic has ",(0,s.jsx)(n.a,{href:"https://msdn.microsoft.com/en-us/library/xe53dz5w(v=vs.100).aspx",children:"an option to enable\r\nor disable implicit variables"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"When the same syntax can assign or create a variable, each language must decide\r\nwhat happens when it isn't clear about which behavior the user intends. In\r\nparticular, each language must choose how implicit declaration interacts with\r\nshadowing, and which scope an implicitly declared variable goes into."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"In Python, assignment always creates a variable in the current function's\r\nscope, even if there is a variable with the same name declared outside of\r\nthe function."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'Ruby avoids some ambiguity by having different naming rules for local and\r\nglobal variables. However, blocks in Ruby (which are more like closures than\r\nlike "blocks" in C) have their own scope, so it still has the problem.\r\nAssignment in Ruby assigns to an existing variable outside of the current\r\nblock if there is one with the same name. Otherwise, it creates a new\r\nvariable in the current block\'s scope.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"CoffeeScript, which takes after Ruby in many ways, is similar. It explicitly\r\ndisallows shadowing by saying that assignment always assigns to a variable\r\nin an outer scope if there is one, all the way up to the outermost global\r\nscope. Otherwise, it creates the variable in the current function scope."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["In JavaScript, assignment modifies an existing variable in any enclosing\r\nscope, if found. If not, it implicitly creates a new variable in the\r\n",(0,s.jsx)(n.em,{children:"global"})," scope."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'The main advantage to implicit declaration is simplicity. There\'s less syntax\r\nand no "declaration" concept to learn. Users can just start assigning stuff and\r\nthe language figures it out.'}),"\n",(0,s.jsx)(n.p,{children:'Older, statically typed languages like C benefit from explicit declaration\r\nbecause they give the user a place to tell the compiler what type each variable\r\nhas and how much storage to allocate for it. In a dynamically typed,\r\ngarbage-collected language, that isn\'t really necessary, so you can get away\r\nwith making declarations implicit. It feels a little more "scripty", more "you\r\nknow what I mean".'}),"\n",(0,s.jsx)(n.p,{children:"But is that a good idea? Implicit declaration has some problems."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A user may intend to assign to an existing variable, but may have misspelled\r\nit. The interpreter doesn't know that, so it goes ahead and silently creates\r\nsome new variable and the variable the user wanted to assign to still has\r\nits old value. This is particularly heinous in JavaScript where a typo will\r\ncreate a ",(0,s.jsx)(n.em,{children:"global"})," variable, which may in turn interfere with other code."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"JS, Ruby, and CoffeeScript use the presence of an existing variable with the\r\nsame name -- even in an outer scope -- to determine whether or not an\r\nassignment creates a new variable or assigns to an existing one. That means\r\nadding a new variable in a surrounding scope can change the meaning of\r\nexisting code. What was once a local variable may silently turn into an\r\nassignment to that new outer variable."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["In Python, you may ",(0,s.jsx)(n.em,{children:"want"})," to assign to some variable outside of the current\r\nfunction instead of creating a new variable in the current one, but you\r\ncan't."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Over time, the languages I know with implicit variable declaration ended up\r\nadding more features and complexity to deal with these problems."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'Implicit declaration of global variables in JavaScript is universally\r\nconsidered a mistake today. "Strict mode" disables it and makes it a compile\r\nerror.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Python added a ",(0,s.jsx)(n.code,{children:"global"})," statement to let you explicitly assign to a global\r\nvariable from within a function. Later, as functional programming and nested\r\nfunctions became more popular, they added a similar ",(0,s.jsx)(n.code,{children:"nonlocal"})," statement to\r\nassign to variables in enclosing functions."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Ruby extended its block syntax to allow declaring certain variables to be\r\nexplicitly local to the block even if the same name exists in an outer\r\nscope."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Given those, I think the simplicity argument is mostly lost. There is an\r\nargument that implicit declaration is the right ",(0,s.jsx)(n.em,{children:"default"})," but I personally find\r\nthat less compelling."]}),"\n",(0,s.jsx)(n.p,{children:"My opinion is that implicit declaration made sense in years past when most\r\nscripting languages were heavily imperative and code was pretty flat. As\r\nprogrammers have gotten more comfortable with deep nesting, functional\r\nprogramming, and closures, it's become much more common to want access to\r\nvariables in outer scopes. That makes it more likely that users will run into\r\nthe tricky cases where it's not clear whether they intend their assignment to\r\ncreate a new variable or reuse a surrounding one."}),"\n",(0,s.jsx)(n.p,{children:"So I prefer explicitly declaring variables, which is why Lox requires it."}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);