"use strict";(self.webpackChunkjabberwocky238_github_io=self.webpackChunkjabberwocky238_github_io||[]).push([[9383],{45:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=n(4848),a=n(8453);const i={authors:["jabberwocky238"],tags:["en","tech","rust"],description:"Build tree data structrue from table, in Rust."},s="Build tree from table in Rust",o={permalink:"/blog/2024/10/03/Build-tree-from-table-in-Rust",source:"@site/blog/2024-10-03-Build-tree-from-table-in-Rust.mdx",title:"Build tree from table in Rust",description:"Build tree data structrue from table, in Rust.",date:"2024-10-03T00:00:00.000Z",tags:[{inline:!1,label:"en",permalink:"/blog/tags/en",description:"Blogs Written In English"},{inline:!1,label:"tech",permalink:"/blog/tags/tech",description:"All technical blogs"},{inline:!1,label:"rust",permalink:"/blog/tags/rust",description:"Rust programming language"}],hasTruncateMarker:!0,authors:[{name:"jabberwocky238",title:"WTF",url:"https://github.com/jabberwocky238",page:null,socials:{github:"https://github.com/jabberwocky238"},imageURL:"/jw238_avatar.png",key:"jabberwocky238"}],frontMatter:{authors:["jabberwocky238"],tags:["en","tech","rust"],description:"Build tree data structrue from table, in Rust."},unlisted:!1,lastUpdatedAt:1730697128e3,lastUpdatedBy:"jabberwocky238",prevItem:{title:"Animate girls, ShinyColors.",permalink:"/blog/2024/10/06/ShinyColor-1"},nextItem:{title:"\u575a\u6301\u4e0d\u61c8",permalink:"/blog/2024/09/30/Patience-and-Persistence"}},l={authorsImageUrls:[void 0]},d=[{value:"Motivation",id:"motivation",level:2},{value:"Persistent storage",id:"persistent-storage",level:2},{value:"Why I dont use JSON",id:"why-i-dont-use-json",level:3},{value:"CSV",id:"csv",level:3},{value:"Come to the point",id:"come-to-the-point",level:2},{value:"serialize",id:"serialize",level:3},{value:"deserialize",id:"deserialize",level:3}];function h(e){const t={a:"a",code:"code",details:"details",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",summary:"summary",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["This ",(0,r.jsx)(t.code,{children:"{ truncate }"})," is so fucking ugly..."]}),"\n",(0,r.jsx)(t.p,{children:"{/* truncate */}"}),"\n",(0,r.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,r.jsxs)(t.p,{children:["I have a project named ",(0,r.jsx)(t.a,{href:"https://github.com/jabberwocky238/Jobs",children:"Jobs"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"The duty of this app, maybe is scanning and calculating disk and folders' size. In this process, store the node of files and directories. Therefore we can reuse the nodes to speed up next round of scanning."}),"\n",(0,r.jsx)(t.h2,{id:"persistent-storage",children:"Persistent storage"}),"\n",(0,r.jsx)(t.p,{children:"Obviously, I need to find a good way to persist my data to disk."}),"\n",(0,r.jsx)(t.h3,{id:"why-i-dont-use-json",children:"Why I dont use JSON"}),"\n",(0,r.jsx)(t.p,{children:"At first, I choose JSON, because of its straightforward tree structure. But then I found out that I could be tied up by it."}),"\n",(0,r.jsx)(t.p,{children:"When I want to save a subdirectory, I have to start from the root and traverse the tree, deep down below until I find the target. This is not efficient and robust."}),"\n",(0,r.jsxs)(t.p,{children:["What's more, I will add an additional feature to this app in the future. The most possible one is ",(0,r.jsx)(t.strong,{children:"trie search"}),", which cannot create a good synergy with JSON. Because the insert and delete of trie is not as easy as you think."]}),"\n",(0,r.jsx)(t.h3,{id:"csv",children:"CSV"}),"\n",(0,r.jsx)(t.p,{children:"Before I fall on CSV, I have tried Graph Database, which can maintain the tree structure of my idea before."}),"\n",(0,r.jsx)(t.p,{children:"But then I found out the complexity is definitely too high for me to have a good control of the whole project."}),"\n",(0,r.jsx)(t.p,{children:"Then I turn around to try sqlite, but there is such a apparent thing to wake me up:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Sqlite is a relational database. So why don't I just use a csv file instead?"})}),"\n",(0,r.jsx)(t.p,{children:"So I choose CSV afterward."}),"\n",(0,r.jsx)(t.h2,{id:"come-to-the-point",children:"Come to the point"}),"\n",(0,r.jsxs)(t.p,{children:["Relational database has a table structure. So the problem here has turning into ",(0,r.jsx)(t.strong,{children:'"How to turn a table to a tree and vice versa"'}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"serialize",children:"serialize"}),"\n",(0,r.jsx)(t.p,{children:"First, let talk about serialize, aka turning a tree to a table."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"child_hash, parent_hash, details...\n"})}),"\n",(0,r.jsxs)(t.p,{children:["And everything else is the same as sql",(0,r.jsx)(t.code,{children:"JOIN"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Easy, hah?"}),"\n",(0,r.jsx)(t.h3,{id:"deserialize",children:"deserialize"}),"\n",(0,r.jsx)(t.p,{children:"Now let's talk about deserialize, aka turning a table to a tree."}),"\n",(0,r.jsx)(t.p,{children:"The first idea coming into my mind is build tree in a top-down way. Create the root node first, then its children."}),"\n",(0,r.jsx)(t.p,{children:'What follows is the very strengent regulation of Rust\'s mutation and ownership. If the root create at first, then it must be mutable. Because we need to add children to it. But for the subtree, which can be called "subroot", they also need to be mutable. But the implementation confronts the double use of the same mutable reference.'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub fn deserialize() -> Result<DirInfo, Box<dyn Error>> {\r\n    for row in data.iter() {\r\n        let mut subroot: DirInfo = row.into();\r\n        let mut parent = data.find_parent(subroot); // illegal\r\n        // parent need to be change, but it still in data\r\n        // data itself is borrowed by for loop.\r\n        // so we can't take mutable parent out of it.\r\n        parent.insert(subroot);\r\n    }\r\n    Ok(root)\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"OK, after that, I have tried many different ways, such as maintaining an additional symbol table, hashmap, clone, vector, drain / reduce / rev, etc..."}),"\n",(0,r.jsx)(t.p,{children:"None of them can solve this elegantly."}),"\n",(0,r.jsxs)(t.details,{children:["\n  ",(0,r.jsx)(t.summary,{children:"evil reduce function\ud83d\ude32\ud83d\ude32\ud83d\ude32\ud83d\ude32\ud83d\ude32"}),"\n",(0,r.jsx)(t.p,{children:"Here is a interesting issue that I want to talk about:"}),"\n",(0,r.jsxs)(t.p,{children:["Rust's iterator have a function called ",(0,r.jsx)(t.code,{children:"reduce"}),", which literally means reduce the whole vector into a single element. And this is exactly what I want."]}),"\n",(0,r.jsx)(t.p,{children:"My assumption is like:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"let root = data.iter().reduce(|array, element| {\r\n    array.find_parent(element).insert(element);\r\n    array\r\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"Is that extremely nice? How smart I am!"}),"\n",(0,r.jsx)(t.p,{children:"Fuck!"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"reduce"})," have two paramters, the first one is element, the second one is also the fucking element!"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"let root = data.iter().reduce(|a, b| {\r\n    a + b // how stupid it is!\r\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"It is different with javascript!"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"let root = data.reduce((prev, cur, index, arr) => {\r\n    arr.find_parent(element).insert(element);\r\n    return array;\r\n});\n"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"After all, I came out a solution, which is a bottom-up way. Create the leaf node first, then its parent."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"DumpData"})," is csv format, ",(0,r.jsx)(t.code,{children:"Node"})," is tree format."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"let mut symbols: HashMap<u64, Node> = HashMap::new();\r\nlet data = rdr.deserialize().collect::<Vec<DumpData>>();\r\n    \r\nfor dumpdata in data.iter() {\r\n    // make sure child node exists\r\n    // it will return '$mut Node', but we don't want the ref, but the pure value.\r\n    symbols.entry(dumpdata.chash).or_insert_with(|| dumpdata.to_node()); \r\n    // take child out\r\n    let child_node: Node = symbols.remove(&dumpdata.chash).unwrap(); \r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"In this way, we can make sure the child node is completely owned by loop. And it can be removed after adding into parent."}),"\n",(0,r.jsxs)(t.p,{children:["What about the parent node? We can't remove it from the data, because it is still in the loop. So we need to find it in the ",(0,r.jsx)(t.code,{children:"data"})," again."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"for dumpdata in data.iter() {\r\n    ...\r\n    // make sure parent node exists, and unique\r\n    let parent_node: $mut Node = symbols.entry(dumpdata.phash).or_insert_with(|| {\r\n        data.iter().find(|d| d.chash == dumpdata.phash).unwrap().to_node()\r\n    });\r\n    parent.children.insert(dumpdata.chash, child_node);\r\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["And the parent Node still stays in the ",(0,r.jsx)(t.code,{children:"data"}),", so it can be used in the next loop."]}),"\n",(0,r.jsx)(t.p,{children:"full code below:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'pub fn deserialize() -> Result<DirInfo, Box<dyn Error>> {\r\n    // \u83b7\u53d6\u7528\u6237\u7684 HOME \u76ee\u5f55\r\n    let home_dir = env::var("HOME").or_else(|_| env::var("USERPROFILE"))?;\r\n    // \u521b\u5efa CSV \u6587\u4ef6\u7684\u5b8c\u6574\u8def\u5f84\r\n    let file_path = format!("{}/example.csv", home_dir);\r\n    // \u8bfb\u53d6\u6587\u4ef6\r\n    let file = File::open(&file_path)?;\r\n    let mut rdr = Reader::from_reader(file);\r\n\r\n    let mut symbols: HashMap<u64, JNode> = HashMap::new();\r\n    let mut root: Option<JNode> = None;\r\n    let data = rdr\r\n        .deserialize()\r\n        .map(|result| result.unwrap())\r\n        .collect::<Vec<DumpData>>()\r\n        .into_iter()\r\n        .rev()\r\n        .collect::<Vec<DumpData>>();\r\n\r\n    for dumpdata in data.iter() {\r\n        symbols\r\n            .entry(dumpdata.chash)\r\n            .or_insert_with(|| dumpdata.to_node());\r\n        let child_node = symbols.remove(&dumpdata.chash).unwrap();\r\n\r\n        if dumpdata.phash == 0 {\r\n            root = Some(child_node);\r\n            continue;\r\n        }\r\n\r\n        let parent_node = symbols.entry(dumpdata.phash).or_insert_with(|| {\r\n            data.iter()\r\n                .find(|d| d.chash == dumpdata.phash)\r\n                .unwrap()\r\n                .to_node()\r\n        });\r\n        if let JNode::DirInfo(parent) = parent_node {\r\n            parent.children.insert(dumpdata.chash, child_node);\r\n        }\r\n    }\r\n    match root {\r\n        Some(JNode::DirInfo(root)) => Ok(root),\r\n        _ => Err("Fail to deserialize".into()),\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Ah...The second blog..."})})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(6540);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);