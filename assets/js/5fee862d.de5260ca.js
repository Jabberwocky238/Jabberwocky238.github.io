"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[124],{5788:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=t(4848),a=t(8453);const r={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/classes-and-instances",title:"classes-and-instances",description:"Caring too much for objects can destroy you. Only -- if you care for a thing",source:"@site/docs/Craftinginterpreters/not-translated-yet/classes-and-instances.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/classes-and-instances",permalink:"/docs/Craftinginterpreters/not-translated-yet/classes-and-instances",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/classes-and-instances.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"chunks-of-bytecode",permalink:"/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode"},next:{title:"classes",permalink:"/docs/Craftinginterpreters/not-translated-yet/classes"}},l={},c=[{value:"Class Objects",id:"class-objects",level:2},{value:"Class Declarations",id:"class-declarations",level:2},{value:"Instances of Classes",id:"instances-of-classes",level:2},{value:"Get and Set Expressions",id:"get-and-set-expressions",level:2},{value:"Interpreting getter and setter expressions",id:"interpreting-getter-and-setter-expressions",level:3},{value:"Challenges",id:"challenges",level:2}];function h(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Caring too much for objects can destroy you. Only -- if you care for a thing\r\nenough, it takes on a life of its own, doesn't it? And isn\u2019t the whole point\r\nof things -- beautiful things -- that they connect you to some larger beauty?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.cite,{children:["Donna Tartt, ",(0,s.jsx)(n.em,{children:"The Goldfinch"})]})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The last area left to implement in clox is object-oriented programming. ",(0,s.jsx)(n.span,{name:"oop",children:"OOP"})," is a bundle of intertwined features: classes, instances,\r\nfields, methods, initializers, and inheritance. Using relatively high-level\r\nJava, we packed all that into two chapters. Now that we're coding in C, which\r\nfeels like building a model of the Eiffel tower out of toothpicks, we'll devote\r\nthree chapters to covering the same territory. This makes for a leisurely stroll\r\nthrough the implementation. After strenuous chapters like ",(0,s.jsx)(n.a,{href:"closures.html",children:"closures"})," and the\r\n",(0,s.jsx)(n.a,{href:"garbage-collection.html",children:"garbage collector"}),", you have earned a rest. In fact, the book should be easy\r\nfrom here on out."]}),"\n",(0,s.jsxs)(n.aside,{name:"oop",children:["\n",(0,s.jsx)(n.p,{children:'People who have strong opinions about object-oriented programming -- read\r\n"everyone" -- tend to assume OOP means some very specific list of language\r\nfeatures, but really there\'s a whole space to explore, and each language has its\r\nown ingredients and recipes.'}),"\n",(0,s.jsx)(n.p,{children:"Self has objects but no classes. CLOS has methods but doesn't attach them to\r\nspecific classes. C++ initially had no runtime polymorphism -- no virtual\r\nmethods. Python has multiple inheritance, but Java does not. Ruby attaches\r\nmethods to classes, but you can also define methods on a single object."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, we cover the first three features: classes, instances, and\r\nfields. This is the stateful side of object orientation. Then in the next two\r\nchapters, we will hang behavior and code reuse off of those objects."}),"\n",(0,s.jsx)(n.h2,{id:"class-objects",children:"Class Objects"}),"\n",(0,s.jsx)(n.p,{children:"In a class-based object-oriented language, everything begins with classes. They\r\ndefine what sorts of objects exist in the program and are the factories used to\r\nproduce new instances. Going bottom-up, we'll start with their runtime\r\nrepresentation and then hook that into the language."}),"\n",(0,s.jsx)(n.p,{children:"By this point, we're well-acquainted with the process of adding a new object\r\ntype to the VM. We start with a struct."}),"\n",(0,s.jsx)(n.p,{children:"^code obj-class (1 before, 2 after)"}),"\n",(0,s.jsx)(n.p,{children:"After the Obj header, we store the class's name. This isn't strictly needed for\r\nthe user's program, but it lets us show the name at runtime for things like\r\nstack traces."}),"\n",(0,s.jsx)(n.p,{children:"The new type needs a corresponding case in the ObjType enum."}),"\n",(0,s.jsx)(n.p,{children:"^code obj-type-class (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"And that type gets a corresponding pair of macros. First, for testing an\r\nobject's type:"}),"\n",(0,s.jsx)(n.p,{children:"^code is-class (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"And then for casting a Value to an ObjClass pointer:"}),"\n",(0,s.jsx)(n.p,{children:"^code as-class (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"The VM creates new class objects using this function:"}),"\n",(0,s.jsx)(n.p,{children:"^code new-class-h (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"The implementation lives over here:"}),"\n",(0,s.jsx)(n.p,{children:"^code new-class"}),"\n",(0,s.jsx)(n.p,{children:"Pretty much all boilerplate. It takes in the class's name as a string and stores\r\nit. Every time the user declares a new class, the VM will create a new one of\r\nthese ObjClass structs to represent it."}),"\n",(0,s.jsxs)(n.aside,{name:"klass",children:["\n",(0,s.jsx)(n.img,{src:"image/classes-and-instances/klass.png",alt:"'Klass' in a zany kidz font."}),"\n",(0,s.jsx)(n.p,{children:'I named the variable "klass" not just to give the VM a zany preschool "Kidz\r\nKorner" feel. It makes it easier to get clox compiling as C++ where "class" is\r\na reserved word.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When the VM no longer needs a class, it frees it like so:"}),"\n",(0,s.jsx)(n.p,{children:"^code free-class (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"braces",children:["\n",(0,s.jsx)(n.p,{children:"The braces here are pointless now, but will be useful in the next chapter when\r\nwe add some more code to the switch case."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We have a memory manager now, so we also need to support tracing through class\r\nobjects."}),"\n",(0,s.jsx)(n.p,{children:"^code blacken-class (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"When the GC reaches a class object, it marks the class's name to keep that\r\nstring alive too."}),"\n",(0,s.jsx)(n.p,{children:"The last operation the VM can perform on a class is printing it."}),"\n",(0,s.jsx)(n.p,{children:"^code print-class (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"A class simply says its own name."}),"\n",(0,s.jsx)(n.h2,{id:"class-declarations",children:"Class Declarations"}),"\n",(0,s.jsx)(n.p,{children:"Runtime representation in hand, we are ready to add support for classes to the\r\nlanguage. Next, we move into the parser."}),"\n",(0,s.jsx)(n.p,{children:"^code match-class (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["Class declarations are statements, and the parser recognizes one by the leading\r\n",(0,s.jsx)(n.code,{children:"class"})," keyword. The rest of the compilation happens over here:"]}),"\n",(0,s.jsx)(n.p,{children:"^code class-declaration"}),"\n",(0,s.jsxs)(n.p,{children:["Immediately after the ",(0,s.jsx)(n.code,{children:"class"})," keyword is the class's name. We take that\r\nidentifier and add it to the surrounding function's constant table as a string.\r\nAs you just saw, printing a class shows its name, so the compiler needs to stuff\r\nthe name string somewhere that the runtime can find. The constant table is the\r\nway to do that."]}),"\n",(0,s.jsxs)(n.p,{children:["The class's ",(0,s.jsx)(n.span,{name:"variable",children:"name"})," is also used to bind the class\r\nobject to a variable of the same name. So we declare a variable with that\r\nidentifier right after consuming its token."]}),"\n",(0,s.jsxs)(n.aside,{name:"variable",children:["\n",(0,s.jsxs)(n.p,{children:["We could have made class declarations be ",(0,s.jsx)(n.em,{children:"expressions"})," instead of statements --\r\nthey are essentially a literal that produces a value after all. Then users would\r\nhave to explicitly bind the class to a variable themselves like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var Pie = class {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Sort of like lambda functions but for classes. But since we generally want\r\nclasses to be named anyway, it makes sense to treat them as declarations."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Next, we emit a new instruction to actually create the class object at runtime.\r\nThat instruction takes the constant table index of the class's name as an\r\noperand."}),"\n",(0,s.jsxs)(n.p,{children:["After that, but before compiling the body of the class, we define the variable\r\nfor the class's name. ",(0,s.jsx)(n.em,{children:"Declaring"})," the variable adds it to the scope, but recall\r\nfrom ",(0,s.jsx)(n.a,{href:"local-variables.html#another-scope-edge-case",children:"a previous chapter"})," that we can't ",(0,s.jsx)(n.em,{children:"use"})," the variable until it's\r\n",(0,s.jsx)(n.em,{children:"defined"}),". For classes, we define the variable before the body. That way, users\r\ncan refer to the containing class inside the bodies of its own methods. That's\r\nuseful for things like factory methods that produce new instances of the class."]}),"\n",(0,s.jsx)(n.p,{children:"Finally, we compile the body. We don't have methods yet, so right now it's\r\nsimply an empty pair of braces. Lox doesn't require fields to be declared in the\r\nclass, so we're done with the body -- and the parser -- for now."}),"\n",(0,s.jsx)(n.p,{children:"The compiler is emitting a new instruction, so let's define that."}),"\n",(0,s.jsx)(n.p,{children:"^code class-op (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"And add it to the disassembler:"}),"\n",(0,s.jsx)(n.p,{children:"^code disassemble-class (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"For such a large-seeming feature, the interpreter support is minimal."}),"\n",(0,s.jsx)(n.p,{children:"^code interpret-class (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["We load the string for the class's name from the constant table and pass that to\r\n",(0,s.jsx)(n.code,{children:"newClass()"}),". That creates a new class object with the given name. We push that\r\nonto the stack and we're good. If the class is bound to a global variable, then\r\nthe compiler's call to ",(0,s.jsx)(n.code,{children:"defineVariable()"})," will emit code to store that object\r\nfrom the stack into the global variable table. Otherwise, it's right where it\r\nneeds to be on the stack for a new ",(0,s.jsx)(n.span,{name:"local",children:"local"})," variable."]}),"\n",(0,s.jsxs)(n.aside,{name:"local",children:["\n",(0,s.jsx)(n.p,{children:'"Local" classes -- classes declared inside the body of a function or block, are\r\nan unusual concept. Many languages don\'t allow them at all. But since Lox is a\r\ndynamically typed scripting language, it treats the top level of a program and\r\nthe bodies of functions and blocks uniformly. Classes are just another kind of\r\ndeclaration, and since you can declare variables and functions inside blocks,\r\nyou can declare classes in there too.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"There you have it, our VM supports classes now. You can run this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Brioche {}\r\nprint Brioche;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Unfortunately, printing is about ",(0,s.jsx)(n.em,{children:"all"})," you can do with classes, so next is\r\nmaking them more useful."]}),"\n",(0,s.jsx)(n.h2,{id:"instances-of-classes",children:"Instances of Classes"}),"\n",(0,s.jsx)(n.p,{children:"Classes serve two main purposes in a language:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"They are how you create new instances."})," Sometimes this involves a ",(0,s.jsx)(n.code,{children:"new"}),"\r\nkeyword, other times it's a method call on the class object, but you usually\r\nmention the class by name ",(0,s.jsx)(n.em,{children:"somehow"})," to get a new instance."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"They contain methods."})," These define how all instances of the class\r\nbehave."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We won't get to methods until the next chapter, so for now we will only worry\r\nabout the first part. Before classes can create instances, we need a\r\nrepresentation for them."}),"\n",(0,s.jsx)(n.p,{children:"^code obj-instance (1 before, 2 after)"}),"\n",(0,s.jsx)(n.p,{children:"Instances know their class -- each instance has a pointer to the class that it\r\nis an instance of.  We won't use this much in this chapter, but it will become\r\ncritical when we add methods."}),"\n",(0,s.jsx)(n.p,{children:"More important to this chapter is how instances store their state. Lox lets\r\nusers freely add fields to an instance at runtime. This means we need a storage\r\nmechanism that can grow. We could use a dynamic array, but we also want to look\r\nup fields by name as quickly as possible. There's a data structure that's just\r\nperfect for quickly accessing a set of values by name and\r\n-- even more conveniently -- we've already implemented it. Each instance stores\r\nits fields using a hash table."}),"\n",(0,s.jsxs)(n.aside,{name:"fields",children:["\n",(0,s.jsx)(n.p,{children:"Being able to freely add fields to an object at runtime is a big practical\r\ndifference between most dynamic and static languages. Statically typed languages\r\nusually require fields to be explicitly declared. This way, the compiler knows\r\nexactly what fields each instance has. It can use that to determine the precise\r\namount of memory needed for each instance and the offsets in that memory where\r\neach field can be found."}),"\n",(0,s.jsx)(n.p,{children:"In Lox and other dynamic languages, accessing a field is usually a hash table\r\nlookup. Constant time, but still pretty heavyweight. In a language like C++,\r\naccessing a field is as fast as offsetting a pointer by an integer constant."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We only need to add an include, and we've got it."}),"\n",(0,s.jsx)(n.p,{children:"^code object-include-table (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"This new struct gets a new object type."}),"\n",(0,s.jsx)(n.p,{children:"^code obj-type-instance (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["I want to slow down a bit here because the Lox ",(0,s.jsx)(n.em,{children:"language's"}),' notion of "type" and\r\nthe VM ',(0,s.jsx)(n.em,{children:"implementation's"}),' notion of "type" brush against each other in ways that\r\ncan be confusing. Inside the C code that makes clox, there are a number of\r\ndifferent types of Obj -- ObjString, ObjClosure, etc. Each has its own internal\r\nrepresentation and semantics.']}),"\n",(0,s.jsxs)(n.p,{children:["In the Lox ",(0,s.jsx)(n.em,{children:"language"}),", users can define their own classes -- say Cake and Pie --\r\nand then create instances of those classes. From the user's perspective, an\r\ninstance of Cake is a different type of object than an instance of Pie. But,\r\nfrom the VM's perspective, every class the user defines is simply another value\r\nof type ObjClass. Likewise, each instance in the user's program, no matter what\r\nclass it is an instance of, is an ObjInstance. That one VM object type covers\r\ninstances of all classes. The two worlds map to each other something like this:"]}),"\n",(0,s.jsx)(n.img,{src:"image/classes-and-instances/lox-clox.png",alt:"A set of class declarations and instances, and the runtime representations each maps to."}),"\n",(0,s.jsx)(n.p,{children:"Got it? OK, back to the implementation. We also get our usual macros."}),"\n",(0,s.jsx)(n.p,{children:"^code is-instance (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"And:"}),"\n",(0,s.jsx)(n.p,{children:"^code as-instance (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:'Since fields are added after the instance is created, the "constructor" function\r\nonly needs to know the class.'}),"\n",(0,s.jsx)(n.p,{children:"^code new-instance-h (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"We implement that function here:"}),"\n",(0,s.jsx)(n.p,{children:"^code new-instance"}),"\n",(0,s.jsx)(n.p,{children:"We store a reference to the instance's class. Then we initialize the field\r\ntable to an empty hash table. A new baby object is born!"}),"\n",(0,s.jsx)(n.p,{children:"At the sadder end of the instance's lifespan, it gets freed."}),"\n",(0,s.jsx)(n.p,{children:"^code free-instance (3 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["The instance owns its field table so when freeing the instance, we also free the\r\ntable. We don't explicitly free the entries ",(0,s.jsx)(n.em,{children:"in"})," the table, because there may\r\nbe other references to those objects. The garbage collector will take care of\r\nthose for us. Here we free only the entry array of the table itself."]}),"\n",(0,s.jsx)(n.p,{children:"Speaking of the garbage collector, it needs support for tracing through\r\ninstances."}),"\n",(0,s.jsx)(n.p,{children:"^code blacken-instance (3 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["If the instance is alive, we need to keep its class around. Also, we need to\r\nkeep every object referenced by the instance's fields. Most live objects that\r\nare not roots are reachable because some instance refers to the object in a\r\nfield. Fortunately, we already have a nice ",(0,s.jsx)(n.code,{children:"markTable()"})," function to make\r\ntracing them easy."]}),"\n",(0,s.jsx)(n.p,{children:"Less critical but still important is printing."}),"\n",(0,s.jsx)(n.p,{children:"^code print-instance (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.span,{name:"print",children:"An"}),' instance prints its name followed by "instance".\r\n(The "instance" part is mainly so that classes and instances don\'t print the\r\nsame.)']}),"\n",(0,s.jsxs)(n.aside,{name:"print",children:["\n",(0,s.jsxs)(n.p,{children:["Most object-oriented languages let a class define some sort of ",(0,s.jsx)(n.code,{children:"toString()"}),"\r\nmethod that lets the class specify how its instances are converted to a string\r\nand printed. If Lox was less of a toy language, I would want to support that\r\ntoo."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The real fun happens over in the interpreter. Lox has no special ",(0,s.jsx)(n.code,{children:"new"})," keyword.\r\nThe way to create an instance of a class is to invoke the class itself as if it\r\nwere a function. The runtime already supports function calls, and it checks the\r\ntype of object being called to make sure the user doesn't try to invoke a number\r\nor other invalid type."]}),"\n",(0,s.jsx)(n.p,{children:"We extend that runtime checking with a new case."}),"\n",(0,s.jsx)(n.p,{children:"^code call-class (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["If the value being called -- the object that results when evaluating the\r\nexpression to the left of the opening parenthesis -- is a class, then we treat\r\nit as a constructor call. We ",(0,s.jsx)(n.span,{name:"args",children:"create"})," a new instance of\r\nthe called class and store the result on the stack."]}),"\n",(0,s.jsxs)(n.aside,{name:"args",children:["\n",(0,s.jsxs)(n.p,{children:["We ignore any arguments passed to the call for now. We'll revisit this code in\r\nthe ",(0,s.jsx)(n.a,{href:"methods-and-initializers.html",children:"next chapter"})," when we add support for initializers."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We're one step farther. Now we can define classes and create instances of them."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Brioche {}\r\nprint Brioche();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note the parentheses after ",(0,s.jsx)(n.code,{children:"Brioche"}),' on the second line now. This prints\r\n"Brioche instance".']}),"\n",(0,s.jsx)(n.h2,{id:"get-and-set-expressions",children:"Get and Set Expressions"}),"\n",(0,s.jsx)(n.p,{children:'Our object representation for instances can already store state, so all that\r\nremains is exposing that functionality to the user. Fields are accessed and\r\nmodified using get and set expressions. Not one to break with tradition, Lox\r\nuses the classic "dot" syntax:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'eclair.filling = "pastry creme";\r\nprint eclair.filling;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The period -- full stop for my English friends -- works ",(0,s.jsx)(n.span,{name:"sort",children:"sort"})," of like an infix operator. There is an expression to the\r\nleft that is evaluated first and produces an instance. After that is the ",(0,s.jsx)(n.code,{children:"."}),"\r\nfollowed by a field name. Since there is a preceding operand, we hook this into\r\nthe parse table as an infix expression."]}),"\n",(0,s.jsxs)(n.aside,{name:"sort",children:["\n",(0,s.jsxs)(n.p,{children:['I say "sort of" because the right-hand side after the ',(0,s.jsx)(n.code,{children:"."})," is not an expression,\r\nbut a single identifier whose semantics are handled by the get or set expression\r\nitself. It's really closer to a postfix expression."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code table-dot (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["As in other languages, the ",(0,s.jsx)(n.code,{children:"."})," operator binds tightly, with precedence as high\r\nas the parentheses in a function call. After the parser consumes the dot token,\r\nit dispatches to a new parse function."]}),"\n",(0,s.jsx)(n.p,{children:"^code compile-dot"}),"\n",(0,s.jsxs)(n.p,{children:["The parser expects to find a ",(0,s.jsx)(n.span,{name:"prop",children:"property"})," name immediately\r\nafter the dot. We load that token's lexeme into the constant table as a string\r\nso that the name is available at runtime."]}),"\n",(0,s.jsxs)(n.aside,{name:"prop",children:["\n",(0,s.jsx)(n.p,{children:'The compiler uses "property" instead of "field" here because, remember, Lox also\r\nlets you use dot syntax to access a method without calling it. "Property" is the\r\ngeneral term we use to refer to any named entity you can access on an instance.\r\nFields are the subset of properties that are backed by the instance\'s state.'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We have two new expression forms -- getters and setters -- that this one\r\nfunction handles. If we see an equals sign after the field name, it must be a\r\nset expression that is assigning to a field. But we don't ",(0,s.jsx)(n.em,{children:"always"})," allow an\r\nequals sign after the field to be compiled. Consider:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"a + b.c = 3\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is syntactically invalid according to Lox's grammar, which means our Lox\r\nimplementation is obligated to detect and report the error. If ",(0,s.jsx)(n.code,{children:"dot()"})," silently\r\nparsed the ",(0,s.jsx)(n.code,{children:"= 3"})," part, we would incorrectly interpret the code as if the user\r\nhad written:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"a + (b.c = 3)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The problem is that the ",(0,s.jsx)(n.code,{children:"="})," side of a set expression has much lower precedence\r\nthan the ",(0,s.jsx)(n.code,{children:"."})," part. The parser may call ",(0,s.jsx)(n.code,{children:"dot()"})," in a context that is too high\r\nprecedence to permit a setter to appear. To avoid incorrectly allowing that, we\r\nparse and compile the equals part only when ",(0,s.jsx)(n.code,{children:"canAssign"})," is true. If an equals\r\ntoken appears when ",(0,s.jsx)(n.code,{children:"canAssign"})," is false, ",(0,s.jsx)(n.code,{children:"dot()"})," leaves it alone and returns. In\r\nthat case, the compiler will eventually unwind up to ",(0,s.jsx)(n.code,{children:"parsePrecedence()"}),", which\r\nstops at the unexpected ",(0,s.jsx)(n.code,{children:"="})," still sitting as the next token and reports an\r\nerror."]}),"\n",(0,s.jsxs)(n.p,{children:["If we find an ",(0,s.jsx)(n.code,{children:"="})," in a context where it ",(0,s.jsx)(n.em,{children:"is"})," allowed, then we compile the\r\nexpression that follows. After that, we emit a new ",(0,s.jsx)(n.span,{name:"set",children:(0,s.jsx)(n.code,{children:"OP_SET_PROPERTY"})})," instruction. That takes a single operand for\r\nthe index of the property name in the constant table. If we didn't compile a set\r\nexpression, we assume it's a getter and emit an ",(0,s.jsx)(n.code,{children:"OP_GET_PROPERTY"})," instruction,\r\nwhich also takes an operand for the property name."]}),"\n",(0,s.jsxs)(n.aside,{name:"set",children:["\n",(0,s.jsxs)(n.p,{children:["You can't ",(0,s.jsx)(n.em,{children:"set"})," a non-field property, so I suppose that instruction could have\r\nbeen ",(0,s.jsx)(n.code,{children:"OP_SET_FIELD"}),", but I thought it looked nicer to be consistent with the get\r\ninstruction."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Now is a good time to define these two new instructions."}),"\n",(0,s.jsx)(n.p,{children:"^code property-ops (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"And add support for disassembling them:"}),"\n",(0,s.jsx)(n.p,{children:"^code disassemble-property-ops (1 before, 1 after)"}),"\n",(0,s.jsx)(n.h3,{id:"interpreting-getter-and-setter-expressions",children:"Interpreting getter and setter expressions"}),"\n",(0,s.jsx)(n.p,{children:"Sliding over to the runtime, we'll start with get expressions since those are a\r\nlittle simpler."}),"\n",(0,s.jsx)(n.p,{children:"^code interpret-get-property (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"When the interpreter reaches this instruction, the expression to the left of the\r\ndot has already been executed and the resulting instance is on top of the stack.\r\nWe read the field name from the constant pool and look it up in the instance's\r\nfield table. If the hash table contains an entry with that name, we pop the\r\ninstance and push the entry's value as the result."}),"\n",(0,s.jsx)(n.p,{children:"Of course, the field might not exist. In Lox, we've defined that to be a runtime\r\nerror. So we add a check for that and abort if it happens."}),"\n",(0,s.jsx)(n.p,{children:"^code get-undefined (3 before, 2 after)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.span,{name:"field",children:"There"})," is another failure mode to handle which you've\r\nprobably noticed. The above code assumes the expression to the left of the dot\r\ndid evaluate to an ObjInstance. But there's nothing preventing a user from\r\nwriting this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var obj = "not an instance";\r\nprint obj.field;\n'})}),"\n",(0,s.jsx)(n.p,{children:"The user's program is wrong, but the VM still has to handle it with some grace.\r\nRight now, it will misinterpret the bits of the ObjString as an ObjInstance and,\r\nI don't know, catch on fire or something definitely not graceful."}),"\n",(0,s.jsx)(n.p,{children:"In Lox, only instances are allowed to have fields. You can't stuff a field onto\r\na string or number. So we need to check that the value is an instance before\r\naccessing any fields on it."}),"\n",(0,s.jsxs)(n.aside,{name:"field",children:["\n",(0,s.jsxs)(n.p,{children:["Lox ",(0,s.jsx)(n.em,{children:"could"})," support adding fields to values of other types. It's our language\r\nand we can do what we want. But it's likely a bad idea. It significantly\r\ncomplicates the implementation in ways that hurt performance -- for example,\r\nstring interning gets a lot harder."]}),"\n",(0,s.jsxs)(n.p,{children:["Also, it raises gnarly semantic questions around the equality and identity of\r\nvalues. If I attach a field to the number ",(0,s.jsx)(n.code,{children:"3"}),", does the result of ",(0,s.jsx)(n.code,{children:"1 + 2"}),' have\r\nthat field as well? If so, how does the implementation track that? If not, are\r\nthose two resulting "threes" still considered equal?']}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code get-not-instance (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"If the value on the stack isn't an instance, we report a runtime error and\r\nsafely exit."}),"\n",(0,s.jsx)(n.p,{children:"Of course, get expressions are not very useful when no instances have any\r\nfields. For that we need setters."}),"\n",(0,s.jsx)(n.p,{children:"^code interpret-set-property (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["This is a little more complex than ",(0,s.jsx)(n.code,{children:"OP_GET_PROPERTY"}),". When this executes, the\r\ntop of the stack has the instance whose field is being set and above that, the\r\nvalue to be stored. Like before, we read the instruction's operand and find the\r\nfield name string. Using that, we store the value on top of the stack into the\r\ninstance's field table."]}),"\n",(0,s.jsxs)(n.p,{children:["After that is a little ",(0,s.jsx)(n.span,{name:"stack",children:"stack"})," juggling. We pop the\r\nstored value off, then pop the instance, and finally push the value back on. In\r\nother words, we remove the ",(0,s.jsx)(n.em,{children:"second"})," element from the stack while leaving the top\r\nalone. A setter is itself an expression whose result is the assigned value, so\r\nwe need to leave that value on the stack. Here's what I mean:"]}),"\n",(0,s.jsxs)(n.aside,{name:"stack",children:["\n",(0,s.jsx)(n.p,{children:"The stack operations go like this:"}),"\n",(0,s.jsx)(n.img,{src:"image/classes-and-instances/stack.png",alt:"Popping two values and then pushing the first value back on the stack."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Toast {}\r\nvar toast = Toast();\r\nprint toast.jam = "grape"; // Prints "grape".\n'})}),"\n",(0,s.jsx)(n.p,{children:"Unlike when reading a field, we don't need to worry about the hash table not\r\ncontaining the field. A setter implicitly creates the field if needed. We do\r\nneed to handle the user incorrectly trying to store a field on a value that\r\nisn't an instance."}),"\n",(0,s.jsx)(n.p,{children:"^code set-not-instance (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"Exactly like with get expressions, we check the value's type and report a\r\nruntime error if it's invalid. And, with that, the stateful side of Lox's\r\nsupport for object-oriented programming is in place. Give it a try:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Pair {}\r\n\r\nvar pair = Pair();\r\npair.first = 1;\r\npair.second = 2;\r\nprint pair.first + pair.second; // 3.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This doesn't really feel very ",(0,s.jsx)(n.em,{children:"object"}),"-oriented. It's more like a strange,\r\ndynamically typed variant of C where objects are loose struct-like bags of data.\r\nSort of a dynamic procedural language. But this is a big step in expressiveness.\r\nOur Lox implementation now lets users freely aggregate data into bigger units.\r\nIn the next chapter, we will breathe life into those inert blobs."]}),"\n",(0,s.jsxs)(n.div,{className:"challenges",children:["\n",(0,s.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Trying to access a non-existent field on an object immediately aborts the\r\nentire VM. The user has no way to recover from this runtime error, nor is\r\nthere any way to see if a field exists ",(0,s.jsx)(n.em,{children:"before"})," trying to access it. It's up\r\nto the user to ensure on their own that only valid fields are read."]}),"\n",(0,s.jsx)(n.p,{children:"How do other dynamically typed languages handle missing fields? What do you\r\nthink Lox should do? Implement your solution."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Fields are accessed at runtime by their ",(0,s.jsx)(n.em,{children:"string"})," name. But that name must\r\nalways appear directly in the source code as an ",(0,s.jsx)(n.em,{children:"identifier token"}),". A user\r\nprogram cannot imperatively build a string value and then use that as the\r\nname of a field. Do you think they should be able to? Devise a language\r\nfeature that enables that and implement it."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Conversely, Lox offers no way to ",(0,s.jsx)(n.em,{children:"remove"})," a field from an instance. You can\r\nset a field's value to ",(0,s.jsx)(n.code,{children:"nil"}),", but the entry in the hash table is still\r\nthere. How do other languages handle this? Choose and implement a strategy\r\nfor Lox."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Because fields are accessed by name at runtime, working with instance state\r\nis slow. It's technically a constant-time operation -- thanks, hash tables\r\n-- but the constant factors are relatively large. This is a major component\r\nof why dynamic languages are slower than statically typed ones."}),"\n",(0,s.jsx)(n.p,{children:"How do sophisticated implementations of dynamically typed languages cope\r\nwith and optimize this?"}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);