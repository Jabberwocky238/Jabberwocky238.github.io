"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[4281],{8767:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var o=n(4848),i=n(8453);const r={},s=void 0,a={id:"Craftinginterpreters/not-translated-yet/jumping-back-and-forth",title:"jumping-back-and-forth",description:"The order that our mind imagines is like a net, or like a ladder, built to",source:"@site/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/jumping-back-and-forth",permalink:"/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"inheritance",permalink:"/docs/Craftinginterpreters/not-translated-yet/inheritance"},next:{title:"local-variables",permalink:"/docs/Craftinginterpreters/not-translated-yet/local-variables"}},h={},c=[{value:"If Statements",id:"if-statements",level:2},{value:"Else clauses",id:"else-clauses",level:3},{value:"Logical Operators",id:"logical-operators",level:2},{value:"Logical or operator",id:"logical-or-operator",level:3},{value:"While Statements",id:"while-statements",level:2},{value:"For Statements",id:"for-statements",level:2},{value:"Initializer clause",id:"initializer-clause",level:3},{value:"Condition clause",id:"condition-clause",level:3},{value:"Increment clause",id:"increment-clause",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Considering Goto Harmful",id:"design-note-considering-goto-harmful",level:2}];function l(e){const t={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"The order that our mind imagines is like a net, or like a ladder, built to\r\nattain something. But afterward you must throw the ladder away, because you\r\ndiscover that, even if it was useful, it was meaningless."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.cite,{children:["Umberto Eco, ",(0,o.jsx)(t.em,{children:"The Name of the Rose"})]})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["It's taken a while to get here, but we're finally ready to add control flow to\r\nour virtual machine. In the tree-walk interpreter we built for jlox, we\r\nimplemented Lox's control flow in terms of Java's. To execute a Lox ",(0,o.jsx)(t.code,{children:"if"}),"\r\nstatement, we used a Java ",(0,o.jsx)(t.code,{children:"if"})," statement to run the chosen branch. That works,\r\nbut isn't entirely satisfying. By what magic does the ",(0,o.jsx)(t.em,{children:"JVM itself"})," or a native\r\nCPU implement ",(0,o.jsx)(t.code,{children:"if"})," statements? Now that we have our own bytecode VM to hack on,\r\nwe can answer that."]}),"\n",(0,o.jsxs)(t.p,{children:['When we talk about "control flow", what are we referring to? By "flow" we mean\r\nthe way execution moves through the text of the program. Almost like there is a\r\nlittle robot inside the computer wandering through our code, executing bits and\r\npieces here and there. Flow is the path that robot takes, and by ',(0,o.jsx)(t.em,{children:"controlling"}),"\r\nthe robot, we drive which pieces of code it executes."]}),"\n",(0,o.jsxs)(t.p,{children:["In jlox, the robot's locus of attention -- the ",(0,o.jsx)(t.em,{children:"current"})," bit of code -- was\r\nimplicit based on which AST nodes were stored in various Java variables and what\r\nJava code we were in the middle of running. In clox, it is much more explicit.\r\nThe VM's ",(0,o.jsx)(t.code,{children:"ip"}),' field stores the address of the current bytecode instruction. The\r\nvalue of that field is exactly "where we are" in the program.']}),"\n",(0,o.jsxs)(t.p,{children:["Execution proceeds normally by incrementing the ",(0,o.jsx)(t.code,{children:"ip"}),". But we can mutate that\r\nvariable however we want to. In order to implement control flow, all that's\r\nnecessary is to change the ",(0,o.jsx)(t.code,{children:"ip"})," in more interesting ways. The simplest control\r\nflow construct is an ",(0,o.jsx)(t.code,{children:"if"})," statement with no ",(0,o.jsx)(t.code,{children:"else"})," clause:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lox",children:'if (condition) print("condition was truthy");\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The VM evaluates the bytecode for the condition expression. If the result is\r\ntruthy, then it continues along and executes the ",(0,o.jsx)(t.code,{children:"print"})," statement in the body.\r\nThe interesting case is when the condition is falsey. When that happens,\r\nexecution skips over the then branch and proceeds to the next statement."]}),"\n",(0,o.jsxs)(t.p,{children:["To skip over a chunk of code, we simply set the ",(0,o.jsx)(t.code,{children:"ip"})," field to the address of the\r\nbytecode instruction following that code. To ",(0,o.jsx)(t.em,{children:"conditionally"})," skip over some\r\ncode, we need an instruction that looks at the value on top of the stack. If\r\nit's falsey, it adds a given offset to the ",(0,o.jsx)(t.code,{children:"ip"})," to jump over a range of\r\ninstructions. Otherwise, it does nothing and lets execution proceed to the next\r\ninstruction as usual."]}),"\n",(0,o.jsxs)(t.p,{children:["When we compile to bytecode, the explicit nested block structure of the code\r\nevaporates, leaving only a flat series of instructions behind. Lox is a\r\n",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Structured_programming",children:"structured programming"})," language, but clox bytecode isn't. The right -- or\r\nwrong, depending on how you look at it -- set of bytecode instructions could\r\njump into the middle of a block, or from one scope into another."]}),"\n",(0,o.jsx)(t.p,{children:"The VM will happily execute that, even if the result leaves the stack in an\r\nunknown, inconsistent state. So even though the bytecode is unstructured, we'll\r\ntake care to ensure that our compiler only generates clean code that maintains\r\nthe same structure and nesting that Lox itself does."}),"\n",(0,o.jsx)(t.p,{children:"This is exactly how real CPUs behave. Even though we might program them using\r\nhigher-level languages that mandate structured control flow, the compiler lowers\r\nthat down to raw jumps. At the bottom, it turns out goto is the only real\r\ncontrol flow."}),"\n",(0,o.jsxs)(t.p,{children:["Anyway, I didn't mean to get all philosophical. The important bit is that if we\r\nhave that one conditional jump instruction, that's enough to implement Lox's\r\n",(0,o.jsx)(t.code,{children:"if"})," statement, as long as it doesn't have an ",(0,o.jsx)(t.code,{children:"else"})," clause. So let's go ahead\r\nand get started with that."]}),"\n",(0,o.jsx)(t.h2,{id:"if-statements",children:"If Statements"}),"\n",(0,o.jsxs)(t.p,{children:["This many chapters in, you know the drill. Any new feature starts in the front\r\nend and works its way through the pipeline. An ",(0,o.jsx)(t.code,{children:"if"})," statement is, well, a\r\nstatement, so that's where we hook it into the parser."]}),"\n",(0,o.jsx)(t.p,{children:"^code parse-if (2 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["When we see an ",(0,o.jsx)(t.code,{children:"if"})," keyword, we hand off compilation to this function:"]}),"\n",(0,o.jsx)(t.p,{children:"^code if-statement"}),"\n",(0,o.jsxs)(t.aside,{name:"paren",children:["\n",(0,o.jsxs)(t.p,{children:["Have you ever noticed that the ",(0,o.jsx)(t.code,{children:"("})," after the ",(0,o.jsx)(t.code,{children:"if"})," keyword doesn't actually do\r\nanything useful? The language would be just as unambiguous and easy to parse\r\nwithout it, like:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lox",children:'if condition) print("looks weird");\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The closing ",(0,o.jsx)(t.code,{children:")"})," is useful because it separates the condition expression from the\r\nbody. Some languages use a ",(0,o.jsx)(t.code,{children:"then"})," keyword instead. But the opening ",(0,o.jsx)(t.code,{children:"("})," doesn't\r\ndo anything. It's just there because unmatched parentheses look bad to us\r\nhumans."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"First we compile the condition expression, bracketed by parentheses. At runtime,\r\nthat will leave the condition value on top of the stack. We'll use that to\r\ndetermine whether to execute the then branch or skip it."}),"\n",(0,o.jsxs)(t.p,{children:["Then we emit a new ",(0,o.jsx)(t.code,{children:"OP_JUMP_IF_FALSE"})," instruction. It has an operand for how\r\nmuch to offset the ",(0,o.jsx)(t.code,{children:"ip"})," -- how many bytes of code to skip. If the condition is\r\nfalsey, it adjusts the ",(0,o.jsx)(t.code,{children:"ip"})," by that amount. Something like this:"]}),"\n",(0,o.jsxs)(t.aside,{name:"legend",children:["\n",(0,o.jsx)(t.p,{children:'The boxes with the torn edges here represent the blob of bytecode generated by\r\ncompiling some sub-clause of a control flow construct. So the "condition\r\nexpression" box is all of the instructions emitted when we compiled that\r\nexpression.'}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.span,{name:"legend"})}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/if-without-else.png",alt:"Flowchart of the compiled bytecode of an if statement."}),"\n",(0,o.jsxs)(t.p,{children:["But we have a problem. When we're writing the ",(0,o.jsx)(t.code,{children:"OP_JUMP_IF_FALSE"})," instruction's\r\noperand, how do we know how far to jump? We haven't compiled the then branch\r\nyet, so we don't know how much bytecode it contains."]}),"\n",(0,o.jsxs)(t.p,{children:["To fix that, we use a classic trick called ",(0,o.jsx)(t.strong,{children:"backpatching"}),". We emit the jump\r\ninstruction first with a placeholder offset operand. We keep track of where that\r\nhalf-finished instruction is. Next, we compile the then body. Once that's done,\r\nwe know how far to jump. So we go back and replace that placeholder offset with\r\nthe real one now that we can calculate it. Sort of like sewing a patch onto the\r\nexisting fabric of the compiled code."]}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/patch.png",alt:"A patch containing a number being sewn onto a sheet of bytecode."}),"\n",(0,o.jsx)(t.p,{children:"We encode this trick into two helper functions."}),"\n",(0,o.jsx)(t.p,{children:"^code emit-jump"}),"\n",(0,o.jsxs)(t.p,{children:["The first emits a bytecode instruction and writes a placeholder operand for the\r\njump offset. We pass in the opcode as an argument because later we'll have two\r\ndifferent instructions that use this helper. We use two bytes for the jump\r\noffset operand. A 16-bit ",(0,o.jsx)(t.span,{name:"offset",children:"offset"})," lets us jump over up\r\nto 65,535 bytes of code, which should be plenty for our needs."]}),"\n",(0,o.jsxs)(t.aside,{name:"offset",children:["\n",(0,o.jsx)(t.p,{children:'Some instruction sets have separate "long" jump instructions that take larger\r\noperands for when you need to jump a greater distance.'}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The function returns the offset of the emitted instruction in the chunk. After\r\ncompiling the then branch, we take that offset and pass it to this:"}),"\n",(0,o.jsx)(t.p,{children:"^code patch-jump"}),"\n",(0,o.jsxs)(t.p,{children:["This goes back into the bytecode and replaces the operand at the given location\r\nwith the calculated jump offset. We call ",(0,o.jsx)(t.code,{children:"patchJump()"})," right before we emit the\r\nnext instruction that we want the jump to land on, so it uses the current\r\nbytecode count to determine how far to jump. In the case of an ",(0,o.jsx)(t.code,{children:"if"})," statement,\r\nthat means right after we compile the then branch and before we compile the next\r\nstatement."]}),"\n",(0,o.jsx)(t.p,{children:"That's all we need at compile time. Let's define the new instruction."}),"\n",(0,o.jsx)(t.p,{children:"^code jump-if-false-op (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"Over in the VM, we get it working like so:"}),"\n",(0,o.jsx)(t.p,{children:"^code op-jump-if-false (2 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"This is the first instruction we've added that takes a 16-bit operand. To read\r\nthat from the chunk, we use a new macro."}),"\n",(0,o.jsx)(t.p,{children:"^code read-short (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"It yanks the next two bytes from the chunk and builds a 16-bit unsigned integer\r\nout of them. As usual, we clean up our macro when we're done with it."}),"\n",(0,o.jsx)(t.p,{children:"^code undef-read-short (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["After reading the offset, we check the condition value on top of the stack.\r\n",(0,o.jsx)(t.span,{name:"if",children:"If"})," it's falsey, we apply this jump offset to the ",(0,o.jsx)(t.code,{children:"ip"}),".\r\nOtherwise, we leave the ",(0,o.jsx)(t.code,{children:"ip"})," alone and execution will automatically proceed to\r\nthe next instruction following the jump instruction."]}),"\n",(0,o.jsxs)(t.p,{children:["In the case where the condition is falsey, we don't need to do any other work.\r\nWe've offset the ",(0,o.jsx)(t.code,{children:"ip"}),", so when the outer instruction dispatch loop turns again,\r\nit will pick up execution at that new instruction, past all of the code in the\r\nthen branch."]}),"\n",(0,o.jsxs)(t.aside,{name:"if",children:["\n",(0,o.jsxs)(t.p,{children:["I said we wouldn't use C's ",(0,o.jsx)(t.code,{children:"if"})," statement to implement Lox's control flow, but\r\nwe do use one here to determine whether or not to offset the instruction\r\npointer. But we aren't really using C for ",(0,o.jsx)(t.em,{children:"control flow"}),". If we wanted to, we\r\ncould do the same thing purely arithmetically. Let's assume we have a function\r\n",(0,o.jsx)(t.code,{children:"falsey()"})," that takes a Lox Value and returns 1 if it's falsey or 0 otherwise.\r\nThen we could implement the jump instruction like:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:"case OP_JUMP_IF_FALSE: {\r\n  uint16_t offset = READ_SHORT();\r\n  vm.ip += falsey() * offset;\r\n  break;\r\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"falsey()"})," function would probably use some control flow to handle the\r\ndifferent value types, but that's an implementation detail of that function and\r\ndoesn't affect how our VM does its own control flow."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Note that the jump instruction doesn't pop the condition value off the stack. So\r\nwe aren't totally done here, since this leaves an extra value floating around on\r\nthe stack. We'll clean that up soon. Ignoring that for the moment, we do have a\r\nworking ",(0,o.jsx)(t.code,{children:"if"})," statement in Lox now, with only one little instruction required to\r\nsupport it at runtime in the VM."]}),"\n",(0,o.jsx)(t.h3,{id:"else-clauses",children:"Else clauses"}),"\n",(0,o.jsxs)(t.p,{children:["An ",(0,o.jsx)(t.code,{children:"if"})," statement without support for ",(0,o.jsx)(t.code,{children:"else"})," clauses is like Morticia Addams\r\nwithout Gomez. So, after we compile the then branch, we look for an ",(0,o.jsx)(t.code,{children:"else"}),"\r\nkeyword. If we find one, we compile the else branch."]}),"\n",(0,o.jsx)(t.p,{children:"^code compile-else (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["When the condition is falsey, we'll jump over the then branch. If there's an\r\nelse branch, the ",(0,o.jsx)(t.code,{children:"ip"})," will land right at the beginning of its code. But that's\r\nnot enough, though. Here's the flow that leads to:"]}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/bad-else.png",alt:"Flowchart of the compiled bytecode with the then branch incorrectly falling through to the else branch."}),"\n",(0,o.jsx)(t.p,{children:"If the condition is truthy, we execute the then branch like we want. But after\r\nthat, execution rolls right on through into the else branch. Oops! When the\r\ncondition is true, after we run the then branch, we need to jump over the else\r\nbranch. That way, in either case, we only execute a single branch, like this:"}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/if-else.png",alt:"Flowchart of the compiled bytecode for an if with an else clause."}),"\n",(0,o.jsx)(t.p,{children:"To implement that, we need another jump from the end of the then branch."}),"\n",(0,o.jsx)(t.p,{children:"^code jump-over-else (2 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"We patch that offset after the end of the else body."}),"\n",(0,o.jsx)(t.p,{children:"^code patch-else (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"After executing the then branch, this jumps to the next statement after the else\r\nbranch. Unlike the other jump, this jump is unconditional. We always take it, so\r\nwe need another instruction that expresses that."}),"\n",(0,o.jsx)(t.p,{children:"^code jump-op (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"We interpret it like so:"}),"\n",(0,o.jsx)(t.p,{children:"^code op-jump (2 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"Nothing too surprising here -- the only difference is that it doesn't check a\r\ncondition and always applies the offset."}),"\n",(0,o.jsx)(t.p,{children:"We have then and else branches working now, so we're close. The last bit is to\r\nclean up that condition value we left on the stack. Remember, each statement is\r\nrequired to have zero stack effect -- after the statement is finished executing,\r\nthe stack should be as tall as it was before."}),"\n",(0,o.jsxs)(t.p,{children:["We could have the ",(0,o.jsx)(t.code,{children:"OP_JUMP_IF_FALSE"})," instruction pop the condition itself, but\r\nsoon we'll use that same instruction for the logical operators where we don't\r\nwant the condition popped. Instead, we'll have the compiler emit a couple of\r\nexplicit ",(0,o.jsx)(t.code,{children:"OP_POP"})," instructions when compiling an ",(0,o.jsx)(t.code,{children:"if"})," statement. We need to take\r\ncare that every execution path through the generated code pops the condition."]}),"\n",(0,o.jsx)(t.p,{children:"When the condition is truthy, we pop it right before the code inside the then\r\nbranch."}),"\n",(0,o.jsx)(t.p,{children:"^code pop-then (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"Otherwise, we pop it at the beginning of the else branch."}),"\n",(0,o.jsx)(t.p,{children:"^code pop-end (1 before, 2 after)"}),"\n",(0,o.jsxs)(t.p,{children:["This little instruction here also means that every ",(0,o.jsx)(t.code,{children:"if"})," statement has an\r\nimplicit else branch even if the user didn't write an ",(0,o.jsx)(t.code,{children:"else"})," clause. In the case\r\nwhere they left it off, all the branch does is discard the condition value."]}),"\n",(0,o.jsx)(t.p,{children:"The full correct flow looks like this:"}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/full-if-else.png",alt:"Flowchart of the compiled bytecode including necessary pop instructions."}),"\n",(0,o.jsx)(t.p,{children:"If you trace through, you can see that it always executes a single branch and\r\nensures the condition is popped first. All that remains is a little disassembler\r\nsupport."}),"\n",(0,o.jsx)(t.p,{children:"^code disassemble-jump (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"These two instructions have a new format with a 16-bit operand, so we add a new\r\nutility function to disassemble them."}),"\n",(0,o.jsx)(t.p,{children:"^code jump-instruction"}),"\n",(0,o.jsxs)(t.p,{children:["There we go, that's one complete control flow construct. If this were an '80s\r\nmovie, the montage music would kick in and the rest of the control flow syntax\r\nwould take care of itself. Alas, the ",(0,o.jsx)(t.span,{name:"80s",children:"'80s"})," are long over,\r\nso we'll have to grind it out ourselves."]}),"\n",(0,o.jsxs)(t.aside,{name:"80s",children:["\n",(0,o.jsx)(t.p,{children:"My enduring love of Depeche Mode notwithstanding."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"logical-operators",children:"Logical Operators"}),"\n",(0,o.jsxs)(t.p,{children:["You probably remember this from jlox, but the logical operators ",(0,o.jsx)(t.code,{children:"and"})," and ",(0,o.jsx)(t.code,{children:"or"}),"\r\naren't just another pair of binary operators like ",(0,o.jsx)(t.code,{children:"+"})," and ",(0,o.jsx)(t.code,{children:"-"}),". Because they\r\nshort-circuit and may not evaluate their right operand depending on the value of\r\nthe left one, they work more like control flow expressions."]}),"\n",(0,o.jsxs)(t.p,{children:["They're basically a little variation on an ",(0,o.jsx)(t.code,{children:"if"})," statement with an ",(0,o.jsx)(t.code,{children:"else"})," clause.\r\nThe easiest way to explain them is to just show you the compiler code and the\r\ncontrol flow it produces in the resulting bytecode. Starting with ",(0,o.jsx)(t.code,{children:"and"}),", we hook\r\nit into the expression parsing table here:"]}),"\n",(0,o.jsx)(t.p,{children:"^code table-and (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"That hands off to a new parser function."}),"\n",(0,o.jsx)(t.p,{children:"^code and"}),"\n",(0,o.jsxs)(t.p,{children:["At the point this is called, the left-hand side expression has already been\r\ncompiled. That means at runtime, its value will be on top of the stack. If that\r\nvalue is falsey, then we know the entire ",(0,o.jsx)(t.code,{children:"and"})," must be false, so we skip the\r\nright operand and leave the left-hand side value as the result of the entire\r\nexpression. Otherwise, we discard the left-hand value and evaluate the right\r\noperand which becomes the result of the whole ",(0,o.jsx)(t.code,{children:"and"})," expression."]}),"\n",(0,o.jsx)(t.p,{children:"Those four lines of code right there produce exactly that. The flow looks like\r\nthis:"}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/and.png",alt:"Flowchart of the compiled bytecode of an 'and' expression."}),"\n",(0,o.jsxs)(t.p,{children:["Now you can see why ",(0,o.jsx)(t.code,{children:"OP_JUMP_IF_FALSE"})," ",(0,o.jsx)(t.span,{name:"instr",children:"leaves"})," the\r\nvalue on top of the stack. When the left-hand side of the ",(0,o.jsx)(t.code,{children:"and"})," is falsey, that\r\nvalue sticks around to become the result of the entire expression."]}),"\n",(0,o.jsxs)(t.aside,{name:"instr",children:["\n",(0,o.jsx)(t.p,{children:"We've got plenty of space left in our opcode range, so we could have separate\r\ninstructions for conditional jumps that implicitly pop and those that don't, I\r\nsuppose. But I'm trying to keep things minimal for the book. In your bytecode\r\nVM, it's worth exploring adding more specialized instructions and seeing how\r\nthey affect performance."}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"logical-or-operator",children:"Logical or operator"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"or"})," operator is a little more complex. First we add it to the parse table."]}),"\n",(0,o.jsx)(t.p,{children:"^code table-or (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["When that parser consumes an infix ",(0,o.jsx)(t.code,{children:"or"})," token, it calls this:"]}),"\n",(0,o.jsx)(t.p,{children:"^code or"}),"\n",(0,o.jsxs)(t.p,{children:["In an ",(0,o.jsx)(t.code,{children:"or"})," expression, if the left-hand side is ",(0,o.jsx)(t.em,{children:"truthy"}),", then we skip over the\r\nright operand. Thus we need to jump when a value is truthy. We could add a\r\nseparate instruction, but just to show how our compiler is free to map the\r\nlanguage's semantics to whatever instruction sequence it wants, I implemented it\r\nin terms of the jump instructions we already have."]}),"\n",(0,o.jsx)(t.p,{children:"When the left-hand side is falsey, it does a tiny jump over the next statement.\r\nThat statement is an unconditional jump over the code for the right operand.\r\nThis little dance effectively does a jump when the value is truthy. The flow\r\nlooks like this:"}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/or.png",alt:"Flowchart of the compiled bytecode of a logical or expression."}),"\n",(0,o.jsxs)(t.p,{children:["If I'm honest with you, this isn't the best way to do this. There are more\r\ninstructions to dispatch and more overhead. There's no good reason why ",(0,o.jsx)(t.code,{children:"or"}),"\r\nshould be slower than ",(0,o.jsx)(t.code,{children:"and"}),". But it is kind of fun to see that it's possible to\r\nimplement both operators without adding any new instructions. Forgive me my\r\nindulgences."]}),"\n",(0,o.jsxs)(t.p,{children:["OK, those are the three ",(0,o.jsx)(t.em,{children:"branching"})," constructs in Lox. By that, I mean, these\r\nare the control flow features that only jump ",(0,o.jsx)(t.em,{children:"forward"})," over code. Other\r\nlanguages often have some kind of multi-way branching statement like ",(0,o.jsx)(t.code,{children:"switch"}),"\r\nand maybe a conditional expression like ",(0,o.jsx)(t.code,{children:"?:"}),", but Lox keeps it simple."]}),"\n",(0,o.jsx)(t.h2,{id:"while-statements",children:"While Statements"}),"\n",(0,o.jsxs)(t.p,{children:["That takes us to the ",(0,o.jsx)(t.em,{children:"looping"})," statements, which jump ",(0,o.jsx)(t.em,{children:"backward"})," so that code\r\ncan be executed more than once. Lox only has two loop constructs, ",(0,o.jsx)(t.code,{children:"while"})," and\r\n",(0,o.jsx)(t.code,{children:"for"}),". A ",(0,o.jsx)(t.code,{children:"while"})," loop is (much) simpler, so we start the party there."]}),"\n",(0,o.jsx)(t.p,{children:"^code parse-while (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["When we reach a ",(0,o.jsx)(t.code,{children:"while"})," token, we call:"]}),"\n",(0,o.jsx)(t.p,{children:"^code while-statement"}),"\n",(0,o.jsxs)(t.p,{children:["Most of this mirrors ",(0,o.jsx)(t.code,{children:"if"})," statements -- we compile the condition expression,\r\nsurrounded by mandatory parentheses. That's followed by a jump instruction that\r\nskips over the subsequent body statement if the condition is falsey."]}),"\n",(0,o.jsxs)(t.p,{children:["We patch the jump after compiling the body and take care to ",(0,o.jsx)(t.span,{name:"pop",children:"pop"})," the condition value from the stack on either path. The\r\nonly difference from an ",(0,o.jsx)(t.code,{children:"if"})," statement is the loop. That looks like this:"]}),"\n",(0,o.jsxs)(t.aside,{name:"pop",children:["\n",(0,o.jsx)(t.p,{children:"Really starting to second-guess my decision to use the same jump instructions\r\nfor the logical operators."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"^code loop (1 before, 2 after)"}),"\n",(0,o.jsx)(t.p,{children:"After the body, we call this function to emit a \"loop\" instruction. That\r\ninstruction needs to know how far back to jump. When jumping forward, we had to\r\nemit the instruction in two stages since we didn't know how far we were going to\r\njump until after we emitted the jump instruction. We don't have that problem\r\nnow. We've already compiled the point in code that we want to jump back to --\r\nit's right before the condition expression."}),"\n",(0,o.jsx)(t.p,{children:"All we need to do is capture that location as we compile it."}),"\n",(0,o.jsx)(t.p,{children:"^code loop-start (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["After executing the body of a ",(0,o.jsx)(t.code,{children:"while"})," loop, we jump all the way back to before\r\nthe condition. That way, we re-evaluate the condition expression on each\r\niteration. We store the chunk's current instruction count in ",(0,o.jsx)(t.code,{children:"loopStart"})," to\r\nrecord the offset in the bytecode right before the condition expression we're\r\nabout to compile. Then we pass that into this helper function:"]}),"\n",(0,o.jsx)(t.p,{children:"^code emit-loop"}),"\n",(0,o.jsxs)(t.p,{children:["It's a bit like ",(0,o.jsx)(t.code,{children:"emitJump()"})," and ",(0,o.jsx)(t.code,{children:"patchJump()"})," combined. It emits a new loop\r\ninstruction, which unconditionally jumps ",(0,o.jsx)(t.em,{children:"backwards"})," by a given offset. Like the\r\njump instructions, after that we have a 16-bit operand. We calculate the offset\r\nfrom the instruction we're currently at to the ",(0,o.jsx)(t.code,{children:"loopStart"})," point that we want to\r\njump back to. The ",(0,o.jsx)(t.code,{children:"+ 2"})," is to take into account the size of the ",(0,o.jsx)(t.code,{children:"OP_LOOP"}),"\r\ninstruction's own operands which we also need to jump over."]}),"\n",(0,o.jsxs)(t.p,{children:["From the VM's perspective, there really is no semantic difference between\r\n",(0,o.jsx)(t.code,{children:"OP_LOOP"})," and ",(0,o.jsx)(t.code,{children:"OP_JUMP"}),". Both just add an offset to the ",(0,o.jsx)(t.code,{children:"ip"}),". We could have used\r\na single instruction for both and given it a signed offset operand. But I\r\nfigured it was a little easier to sidestep the annoying bit twiddling required\r\nto manually pack a signed 16-bit integer into two bytes, and we've got the\r\nopcode space available, so why not use it?"]}),"\n",(0,o.jsx)(t.p,{children:"The new instruction is here:"}),"\n",(0,o.jsx)(t.p,{children:"^code loop-op (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"And in the VM, we implement it thusly:"}),"\n",(0,o.jsx)(t.p,{children:"^code op-loop (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["The only difference from ",(0,o.jsx)(t.code,{children:"OP_JUMP"})," is a subtraction instead of an addition.\r\nDisassembly is similar too."]}),"\n",(0,o.jsx)(t.p,{children:"^code disassemble-loop (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["That's our ",(0,o.jsx)(t.code,{children:"while"})," statement. It contains two jumps -- a conditional forward one\r\nto escape the loop when the condition is not met, and an unconditional loop\r\nbackward after we have executed the body. The flow looks like this:"]}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/while.png",alt:"Flowchart of the compiled bytecode of a while statement."}),"\n",(0,o.jsx)(t.h2,{id:"for-statements",children:"For Statements"}),"\n",(0,o.jsxs)(t.p,{children:["The other looping statement in Lox is the venerable ",(0,o.jsx)(t.code,{children:"for"})," loop, inherited from\r\nC. It's got a lot more going on with it compared to a ",(0,o.jsx)(t.code,{children:"while"})," loop. It has three\r\nclauses, all of which are optional:"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.span,{name:"detail"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"The initializer can be a variable declaration or an expression. It runs once\r\nat the beginning of the statement."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The condition clause is an expression. Like in a ",(0,o.jsx)(t.code,{children:"while"})," loop, we exit the\r\nloop when it evaluates to something falsey."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"The increment expression runs once at the end of each loop iteration."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.aside,{name:"detail",children:["\n",(0,o.jsxs)(t.p,{children:["If you want a refresher, the corresponding chapter in part II goes through the\r\nsemantics ",(0,o.jsx)(t.a,{href:"control-flow.html#for-loops",children:"in more detail"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["In jlox, the parser desugared a ",(0,o.jsx)(t.code,{children:"for"})," loop to a synthesized AST for a ",(0,o.jsx)(t.code,{children:"while"}),"\r\nloop with some extra stuff before it and at the end of the body. We'll do\r\nsomething similar, though we won't go through anything like an AST. Instead,\r\nour bytecode compiler will use the jump and loop instructions we already have."]}),"\n",(0,o.jsxs)(t.p,{children:["We'll work our way through the implementation a piece at a time, starting with\r\nthe ",(0,o.jsx)(t.code,{children:"for"})," keyword."]}),"\n",(0,o.jsx)(t.p,{children:"^code parse-for (1 before, 1 after)"}),"\n",(0,o.jsxs)(t.p,{children:["It calls a helper function. If we only supported ",(0,o.jsx)(t.code,{children:"for"})," loops with empty clauses\r\nlike ",(0,o.jsx)(t.code,{children:"for (;;)"}),", then we could implement it like this:"]}),"\n",(0,o.jsx)(t.p,{children:"^code for-statement"}),"\n",(0,o.jsxs)(t.p,{children:["There's a bunch of mandatory punctuation at the top. Then we compile the body.\r\nLike we did for ",(0,o.jsx)(t.code,{children:"while"})," loops, we record the bytecode offset at the top of the\r\nbody and emit a loop to jump back to that point after it. We've got a working\r\nimplementation of ",(0,o.jsx)(t.span,{name:"infinite",children:"infinite"})," loops now."]}),"\n",(0,o.jsxs)(t.aside,{name:"infinite",children:["\n",(0,o.jsxs)(t.p,{children:["Alas, without ",(0,o.jsx)(t.code,{children:"return"})," statements, there isn't any way to terminate it short of\r\na runtime error."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"initializer-clause",children:"Initializer clause"}),"\n",(0,o.jsx)(t.p,{children:"Now we'll add the first clause, the initializer. It executes only once, before\r\nthe body, so compiling is straightforward."}),"\n",(0,o.jsx)(t.p,{children:"^code for-initializer (1 before, 2 after)"}),"\n",(0,o.jsxs)(t.p,{children:["The syntax is a little complex since we allow either a variable declaration or\r\nan expression. We use the presence of the ",(0,o.jsx)(t.code,{children:"var"})," keyword to tell which we have.\r\nFor the expression case, we call ",(0,o.jsx)(t.code,{children:"expressionStatement()"})," instead of\r\n",(0,o.jsx)(t.code,{children:"expression()"}),". That looks for a semicolon, which we need here too, and also\r\nemits an ",(0,o.jsx)(t.code,{children:"OP_POP"})," instruction to discard the value. We don't want the\r\ninitializer to leave anything on the stack."]}),"\n",(0,o.jsxs)(t.p,{children:["If a ",(0,o.jsx)(t.code,{children:"for"})," statement declares a variable, that variable should be scoped to the\r\nloop body. We ensure that by wrapping the whole statement in a scope."]}),"\n",(0,o.jsx)(t.p,{children:"^code for-begin-scope (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"Then we close it at the end."}),"\n",(0,o.jsx)(t.p,{children:"^code for-end-scope (1 before, 1 after)"}),"\n",(0,o.jsx)(t.h3,{id:"condition-clause",children:"Condition clause"}),"\n",(0,o.jsx)(t.p,{children:"Next, is the condition expression that can be used to exit the loop."}),"\n",(0,o.jsx)(t.p,{children:"^code for-exit (1 before, 1 after)"}),"\n",(0,o.jsx)(t.p,{children:"Since the clause is optional, we need to see if it's actually present. If the\r\nclause is omitted, the next token must be a semicolon, so we look for that to\r\ntell. If there isn't a semicolon, there must be a condition expression."}),"\n",(0,o.jsx)(t.p,{children:"In that case, we compile it. Then, just like with while, we emit a conditional\r\njump that exits the loop if the condition is falsey. Since the jump leaves the\r\nvalue on the stack, we pop it before executing the body. That ensures we discard\r\nthe value when the condition is true."}),"\n",(0,o.jsx)(t.p,{children:"After the loop body, we need to patch that jump."}),"\n",(0,o.jsx)(t.p,{children:"^code exit-jump (1 before, 2 after)"}),"\n",(0,o.jsx)(t.p,{children:"We do this only when there is a condition clause. If there isn't, there's no\r\njump to patch and no condition value on the stack to pop."}),"\n",(0,o.jsx)(t.h3,{id:"increment-clause",children:"Increment clause"}),"\n",(0,o.jsxs)(t.p,{children:["I've saved the best for last, the increment clause. It's pretty convoluted. It\r\nappears textually before the body, but executes ",(0,o.jsx)(t.em,{children:"after"})," it. If we parsed to an\r\nAST and generated code in a separate pass, we could simply traverse into and\r\ncompile the ",(0,o.jsx)(t.code,{children:"for"})," statement AST's body field before its increment clause."]}),"\n",(0,o.jsxs)(t.p,{children:["Unfortunately, we can't compile the increment clause later, since our compiler\r\nonly makes a single pass over the code. Instead, we'll ",(0,o.jsx)(t.em,{children:"jump over"})," the\r\nincrement, run the body, jump ",(0,o.jsx)(t.em,{children:"back"})," up to the increment, run it, and then go to\r\nthe next iteration."]}),"\n",(0,o.jsx)(t.p,{children:"I know, a little weird, but hey, it beats manually managing ASTs in memory in C,\r\nright? Here's the code:"}),"\n",(0,o.jsx)(t.p,{children:"^code for-increment (2 before, 2 after)"}),"\n",(0,o.jsx)(t.p,{children:"Again, it's optional. Since this is the last clause, when omitted, the next\r\ntoken will be the closing parenthesis. When an increment is present, we need to\r\ncompile it now, but it shouldn't execute yet. So, first, we emit an\r\nunconditional jump that hops over the increment clause's code to the body of the\r\nloop."}),"\n",(0,o.jsx)(t.p,{children:"Next, we compile the increment expression itself. This is usually an assignment.\r\nWhatever it is, we only execute it for its side effect, so we also emit a pop to\r\ndiscard its value."}),"\n",(0,o.jsxs)(t.p,{children:["The last part is a little tricky. First, we emit a loop instruction. This is the\r\nmain loop that takes us back to the top of the ",(0,o.jsx)(t.code,{children:"for"})," loop -- right before the\r\ncondition expression if there is one. That loop happens right after the\r\nincrement, since the increment executes at the end of each loop iteration."]}),"\n",(0,o.jsxs)(t.p,{children:["Then we change ",(0,o.jsx)(t.code,{children:"loopStart"})," to point to the offset where the increment expression\r\nbegins. Later, when we emit the loop instruction after the body statement, this\r\nwill cause it to jump up to the ",(0,o.jsx)(t.em,{children:"increment"})," expression instead of the top of the\r\nloop like it does when there is no increment. This is how we weave the\r\nincrement in to run after the body."]}),"\n",(0,o.jsx)(t.p,{children:"It's convoluted, but it all works out. A complete loop with all the clauses\r\ncompiles to a flow like this:"}),"\n",(0,o.jsx)(t.img,{src:"image/jumping-back-and-forth/for.png",alt:"Flowchart of the compiled bytecode of a for statement."}),"\n",(0,o.jsxs)(t.p,{children:["As with implementing ",(0,o.jsx)(t.code,{children:"for"})," loops in jlox, we didn't need to touch the runtime.\r\nIt all gets compiled down to primitive control flow operations the VM already\r\nsupports. In this chapter, we've taken a big ",(0,o.jsx)(t.span,{name:"leap",children:"leap"}),"\r\nforward -- clox is now Turing complete. We've also covered quite a bit of new\r\nsyntax: three statements and two expression forms. Even so, it only took three\r\nnew simple instructions. That's a pretty good effort-to-reward ratio for the\r\narchitecture of our VM."]}),"\n",(0,o.jsxs)(t.aside,{name:"leap",children:["\n",(0,o.jsx)(t.p,{children:"I couldn't resist the pun. I regret nothing."}),"\n"]}),"\n",(0,o.jsxs)(t.div,{className:"challenges",children:["\n",(0,o.jsx)(t.h2,{id:"challenges",children:"Challenges"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["In addition to ",(0,o.jsx)(t.code,{children:"if"})," statements, most C-family languages have a multi-way\r\n",(0,o.jsx)(t.code,{children:"switch"})," statement. Add one to clox. The grammar is:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ebnf",children:'switchStmt     \u2192 "switch" "(" expression ")"\r\n                 "{" switchCase* defaultCase? "}" ;\r\nswitchCase     \u2192 "case" expression ":" statement* ;\r\ndefaultCase    \u2192 "default" ":" statement* ;\n'})}),"\n",(0,o.jsxs)(t.p,{children:["To execute a ",(0,o.jsx)(t.code,{children:"switch"})," statement, first evaluate the parenthesized switch\r\nvalue expression. Then walk the cases. For each case, evaluate its value\r\nexpression. If the case value is equal to the switch value, execute the\r\nstatements under the case and then exit the ",(0,o.jsx)(t.code,{children:"switch"})," statement. Otherwise,\r\ntry the next case. If no case matches and there is a ",(0,o.jsx)(t.code,{children:"default"})," clause,\r\nexecute its statements."]}),"\n",(0,o.jsxs)(t.p,{children:["To keep things simpler, we're omitting fallthrough and ",(0,o.jsx)(t.code,{children:"break"})," statements.\r\nEach case automatically jumps to the end of the switch statement after its\r\nstatements are done."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["In jlox, we had a challenge to add support for ",(0,o.jsx)(t.code,{children:"break"})," statements. This\r\ntime, let's do ",(0,o.jsx)(t.code,{children:"continue"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ebnf",children:'continueStmt   \u2192 "continue" ";" ;\n'})}),"\n",(0,o.jsxs)(t.p,{children:["A ",(0,o.jsx)(t.code,{children:"continue"})," statement jumps directly to the top of the nearest enclosing\r\nloop, skipping the rest of the loop body. Inside a ",(0,o.jsx)(t.code,{children:"for"})," loop, a ",(0,o.jsx)(t.code,{children:"continue"}),"\r\njumps to the increment clause, if there is one. It's a compile-time error to\r\nhave a ",(0,o.jsx)(t.code,{children:"continue"})," statement not enclosed in a loop."]}),"\n",(0,o.jsxs)(t.p,{children:["Make sure to think about scope. What should happen to local variables\r\ndeclared inside the body of the loop or in blocks nested inside the loop\r\nwhen a ",(0,o.jsx)(t.code,{children:"continue"})," is executed?"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Control flow constructs have been mostly unchanged since Algol 68. Language\r\nevolution since then has focused on making code more declarative and high\r\nlevel, so imperative control flow hasn't gotten much attention."}),"\n",(0,o.jsx)(t.p,{children:"For fun, try to invent a useful novel control flow feature for Lox. It can\r\nbe a refinement of an existing form or something entirely new. In practice,\r\nit's hard to come up with something useful enough at this low expressiveness\r\nlevel to outweigh the cost of forcing a user to learn an unfamiliar notation\r\nand behavior, but it's a good chance to practice your design skills."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.div,{className:"design-note",children:["\n",(0,o.jsx)(t.h2,{id:"design-note-considering-goto-harmful",children:"Design Note: Considering Goto Harmful"}),"\n",(0,o.jsxs)(t.p,{children:["Discovering that all of our beautiful structured control flow in Lox is actually\r\ncompiled to raw unstructured jumps is like the moment in Scooby Doo when the\r\nmonster rips the mask off their face. It was goto all along! Except in this\r\ncase, the monster is ",(0,o.jsx)(t.em,{children:"under"})," the mask. We all know goto is evil. But... why?"]}),"\n",(0,o.jsx)(t.p,{children:"It is true that you can write outrageously unmaintainable code using goto. But I\r\ndon't think most programmers around today have seen that first hand. It's been a\r\nlong time since that style was common. These days, it's a boogie man we invoke\r\nin scary stories around the campfire."}),"\n",(0,o.jsxs)(t.p,{children:['The reason we rarely confront that monster in person is because Edsger Dijkstra\r\nslayed it with his famous letter "Go To Statement Considered Harmful", published\r\nin ',(0,o.jsx)(t.em,{children:"Communications of the ACM"})," (March, 1968). Debate around structured\r\nprogramming had been fierce for some time with adherents on both sides, but I\r\nthink Dijkstra deserves the most credit for effectively ending it. Most new\r\nlanguages today have no unstructured jump statements."]}),"\n",(0,o.jsxs)(t.p,{children:["A one-and-a-half page letter that almost single-handedly destroyed a language\r\nfeature must be pretty impressive stuff. If you haven't read it, I encourage you\r\nto do so. It's a seminal piece of computer science lore, one of our tribe's\r\nancestral songs. Also, it's a nice, short bit of practice for reading academic\r\nCS ",(0,o.jsx)(t.span,{name:"style",children:"writing"}),", which is a useful skill to develop."]}),"\n",(0,o.jsxs)(t.aside,{name:"style",children:["\n",(0,o.jsx)(t.p,{children:"That is, if you can get past Dijkstra's insufferable faux-modest\r\nself-aggrandizing writing style:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"More recently I discovered why the use of the go to statement has such\r\ndisastrous effects. ...At that time I did not attach too much importance to\r\nthis discovery; I now submit my considerations for publication because in very\r\nrecent discussions in which the subject turned up, I have been urged to do so."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Ah, yet another one of my many discoveries. I couldn't even be bothered to write\r\nit up until the clamoring masses begged me to."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"I've read it through a number of times, along with a few critiques, responses,\r\nand commentaries. I ended up with mixed feelings, at best. At a very high level,\r\nI'm with him. His general argument is something like this:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"As programmers, we write programs -- static text -- but what we care about\r\nis the actual running program -- its dynamic behavior."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"We're better at reasoning about static things than dynamic things. (He\r\ndoesn't provide any evidence to support this claim, but I accept it.)"}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Thus, the more we can make the dynamic execution of the program reflect its\r\ntextual structure, the better."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:'This is a good start. Drawing our attention to the separation between the code\r\nwe write and the code as it runs inside the machine is an interesting insight.\r\nThen he tries to define a "correspondence" between program text and execution.\r\nFor someone who spent literally his entire career advocating greater rigor in\r\nprogramming, his definition is pretty hand-wavey. He says:'}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Let us now consider how we can characterize the progress of a process. (You\r\nmay think about this question in a very concrete manner: suppose that a\r\nprocess, considered as a time succession of actions, is stopped after an\r\narbitrary action, what data do we have to fix in order that we can redo the\r\nprocess until the very same point?)"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Imagine it like this. You have two computers with the same program running on\r\nthe exact same inputs -- so totally deterministic. You pause one of them at an\r\narbitrary point in its execution. What data would you need to send to the other\r\ncomputer to be able to stop it exactly as far along as the first one was?"}),"\n",(0,o.jsxs)(t.p,{children:["If your program allows only simple statements like assignment, it's easy. You\r\njust need to know the point after the last statement you executed. Basically a\r\nbreakpoint, the ",(0,o.jsx)(t.code,{children:"ip"})," in our VM, or the line number in an error message. Adding\r\nbranching control flow like ",(0,o.jsx)(t.code,{children:"if"})," and ",(0,o.jsx)(t.code,{children:"switch"})," doesn't add any more to this. Even\r\nif the marker points inside a branch, we can still tell where we are."]}),"\n",(0,o.jsxs)(t.p,{children:["Once you add function calls, you need something more. You could have paused the\r\nfirst computer in the middle of a function, but that function may be called from\r\nmultiple places. To pause the second machine at exactly the same point in ",(0,o.jsx)(t.em,{children:"the\r\nentire program's"})," execution, you need to pause it on the ",(0,o.jsx)(t.em,{children:"right"})," call to that\r\nfunction."]}),"\n",(0,o.jsx)(t.p,{children:"So you need to know not just the current statement, but, for function calls that\r\nhaven't returned yet, you need to know the locations of the callsites. In other\r\nwords, a call stack, though I don't think that term existed when Dijkstra wrote\r\nthis. Groovy."}),"\n",(0,o.jsx)(t.p,{children:"He notes that loops make things harder. If you pause in the middle of a loop\r\nbody, you don't know how many iterations have run. So he says you also need to\r\nkeep an iteration count. And, since loops can nest, you need a stack of those\r\n(presumably interleaved with the call stack pointers since you can be in loops\r\nin outer calls too)."}),"\n",(0,o.jsx)(t.p,{children:"This is where it gets weird. So we're really building to something now, and you\r\nexpect him to explain how goto breaks all of this. Instead, he just says:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"The unbridled use of the go to statement has an immediate consequence that it\r\nbecomes terribly hard to find a meaningful set of coordinates in which to\r\ndescribe the process progress."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"He doesn't prove that this is hard, or say why. He just says it. He does say\r\nthat one approach is unsatisfactory:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"With the go to statement one can, of course, still describe the progress\r\nuniquely by a counter counting the number of actions performed since program\r\nstart (viz. a kind of normalized clock). The difficulty is that such a\r\ncoordinate, although unique, is utterly unhelpful."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["But... that's effectively what loop counters do, and he was fine with those.\r\nIt's not like every loop is a simple \"for every integer from 0 to 10\"\r\nincrementing count. Many are ",(0,o.jsx)(t.code,{children:"while"})," loops with complex conditionals."]}),"\n",(0,o.jsxs)(t.p,{children:["Taking an example close to home, consider the core bytecode execution loop at\r\nthe heart of clox. Dijkstra argues that that loop is tractable because we can\r\nsimply count how many times the loop has run to reason about its progress. But\r\nthat loop runs once for each executed instruction in some user's compiled Lox\r\nprogram. Does knowing that it executed 6,201 bytecode instructions really tell\r\nus VM maintainers ",(0,o.jsx)(t.em,{children:"anything"})," edifying about the state of the interpreter?"]}),"\n",(0,o.jsxs)(t.p,{children:["In fact, this particular example points to a deeper truth. B\xf6hm and Jacopini\r\n",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Structured_program_theorem",children:"proved"})," that ",(0,o.jsx)(t.em,{children:"any"})," control flow using goto can be transformed into one using\r\njust sequencing, loops, and branches. Our bytecode interpreter loop is a living\r\nexample of that proof: it implements the unstructured control flow of the clox\r\nbytecode instruction set without using any gotos itself."]}),"\n",(0,o.jsxs)(t.p,{children:["That seems to offer a counter-argument to Dijkstra's claim: you ",(0,o.jsx)(t.em,{children:"can"})," define a\r\ncorrespondence for a program using gotos by transforming it to one that doesn't\r\nand then use the correspondence from that program, which -- according to him --\r\nis acceptable because it uses only branches and loops."]}),"\n",(0,o.jsx)(t.p,{children:"But, honestly, my argument here is also weak. I think both of us are basically\r\ndoing pretend math and using fake logic to make what should be an empirical,\r\nhuman-centered argument. Dijkstra is right that some code using goto is really\r\nbad. Much of that could and should be turned into clearer code by using\r\nstructured control flow."}),"\n",(0,o.jsx)(t.p,{children:"By eliminating goto completely from languages, you're definitely prevented from\r\nwriting bad code using gotos. It may be that forcing users to use structured\r\ncontrol flow and making it an uphill battle to write goto-like code using those\r\nconstructs is a net win for all of our productivity."}),"\n",(0,o.jsx)(t.p,{children:'But I do wonder sometimes if we threw out the baby with the bathwater. In the\r\nabsence of goto, we often resort to more complex structured patterns. The\r\n"switch inside a loop" is a classic one. Another is using a guard variable to\r\nexit out of a series of nested loops:'}),"\n",(0,o.jsx)(t.span,{name:"break",children:"\n"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:'// See if the matrix contains a zero.\r\nbool found = false;\r\nfor (int x = 0; x < xSize; x++) {\r\n  for (int y = 0; y < ySize; y++) {\r\n    for (int z = 0; z < zSize; z++) {\r\n      if (matrix[x][y][z] == 0) {\r\n        printf("found");\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (found) break;\r\n  }\r\n  if (found) break;\r\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"Is that really better than:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:'for (int x = 0; x < xSize; x++) {\r\n  for (int y = 0; y < ySize; y++) {\r\n    for (int z = 0; z < zSize; z++) {\r\n      if (matrix[x][y][z] == 0) {\r\n        printf("found");\r\n        goto done;\r\n      }\r\n    }\r\n  }\r\n}\r\ndone:\n'})}),"\n",(0,o.jsxs)(t.aside,{name:"break",children:["\n",(0,o.jsxs)(t.p,{children:["You could do this without ",(0,o.jsx)(t.code,{children:"break"})," statements -- themselves a limited goto-ish\r\nconstruct -- by inserting ",(0,o.jsx)(t.code,{children:"!found &&"})," at the beginning of the condition clause\r\nof each loop."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"I guess what I really don't like is that we're making language design and\r\nengineering decisions today based on fear. Few people today have any subtle\r\nunderstanding of the problems and benefits of goto. Instead, we just think it's\r\n\"considered harmful\". Personally, I've never found dogma a good starting place\r\nfor quality creative work."}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(6540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);