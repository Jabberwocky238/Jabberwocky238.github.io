"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[2939],{8111:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=t(4848),a=t(8453);const r={},o=void 0,i={id:"Craftinginterpreters/not-translated-yet/the-lox-language",title:"the-lox-language",description:"What nicer thing can you do for somebody than make them breakfast?",source:"@site/docs/Craftinginterpreters/not-translated-yet/the-lox-language.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/the-lox-language",permalink:"/docs/Craftinginterpreters/not-translated-yet/the-lox-language",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/the-lox-language.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"superclasses",permalink:"/docs/Craftinginterpreters/not-translated-yet/superclasses"},next:{title:"types-of-values",permalink:"/docs/Craftinginterpreters/not-translated-yet/types-of-values"}},l={},c=[{value:"Hello, Lox",id:"hello-lox",level:2},{value:"A High-Level Language",id:"a-high-level-language",level:2},{value:"Dynamic typing",id:"dynamic-typing",level:3},{value:"Automatic memory management",id:"automatic-memory-management",level:3},{value:"Data Types",id:"data-types",level:2},{value:"Expressions",id:"expressions",level:2},{value:"Arithmetic",id:"arithmetic",level:3},{value:"Comparison and equality",id:"comparison-and-equality",level:3},{value:"Logical operators",id:"logical-operators",level:3},{value:"Precedence and grouping",id:"precedence-and-grouping",level:3},{value:"Statements",id:"statements",level:2},{value:"Variables",id:"variables",level:2},{value:"Control Flow",id:"control-flow",level:2},{value:"Functions",id:"functions",level:2},{value:"Closures",id:"closures",level:3},{value:"Classes",id:"classes",level:2},{value:"Why might any language want to be object oriented?",id:"why-might-any-language-want-to-be-object-oriented",level:3},{value:"Why is Lox object oriented?",id:"why-is-lox-object-oriented",level:3},{value:"Classes or prototypes",id:"classes-or-prototypes",level:3},{value:"Classes in Lox",id:"classes-in-lox",level:3},{value:"Instantiation and initialization",id:"instantiation-and-initialization",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"The Standard Library",id:"the-standard-library",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Expressions and Statements",id:"design-note-expressions-and-statements",level:2}];function d(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"What nicer thing can you do for somebody than make them breakfast?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.cite,{children:"Anthony Bourdain"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We'll spend the rest of this book illuminating every dark and sundry corner of\r\nthe Lox language, but it seems cruel to have you immediately start grinding out\r\ncode for the interpreter without at least a glimpse of what we're going to end\r\nup with."}),"\n",(0,s.jsxs)(n.p,{children:["At the same time, I don't want to drag you through reams of language lawyering\r\nand specification-ese before you get to touch your text ",(0,s.jsx)(n.span,{name:"home",children:"editor"}),". So this will be a gentle, friendly introduction to\r\nLox. It will leave out a lot of details and edge cases. We've got plenty of time\r\nfor those later."]}),"\n",(0,s.jsxs)(n.aside,{name:"home",children:["\n",(0,s.jsx)(n.p,{children:"A tutorial isn't very fun if you can't try the code out yourself. Alas, you\r\ndon't have a Lox interpreter yet, since you haven't built one!"}),"\n",(0,s.jsxs)(n.p,{children:["Fear not. You can use ",(0,s.jsx)(n.a,{href:"https://github.com/munificent/craftinginterpreters",children:"mine"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"hello-lox",children:"Hello, Lox"}),"\n",(0,s.jsxs)(n.p,{children:["Here's your very first taste of ",(0,s.jsx)(n.span,{name:"salmon",children:"Lox"}),":"]}),"\n",(0,s.jsxs)(n.aside,{name:"salmon",children:["\n",(0,s.jsx)(n.p,{children:"Your first taste of Lox, the language, that is. I don't know if you've ever had\r\nthe cured, cold-smoked salmon before. If not, give it a try too."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'// Your first Lox program!\r\nprint "Hello, world!";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As that ",(0,s.jsx)(n.code,{children:"//"})," line comment and the trailing semicolon imply, Lox's syntax is a\r\nmember of the C family. (There are no parentheses around the string because\r\n",(0,s.jsx)(n.code,{children:"print"})," is a built-in statement, and not a library function.)"]}),"\n",(0,s.jsxs)(n.p,{children:["Now, I won't claim that ",(0,s.jsx)(n.span,{name:"c",children:"C"})," has a ",(0,s.jsx)(n.em,{children:"great"})," syntax. If we\r\nwanted something elegant, we'd probably mimic Pascal or Smalltalk. If we wanted\r\nto go full Scandinavian-furniture-minimalism, we'd do a Scheme. Those all have\r\ntheir virtues."]}),"\n",(0,s.jsxs)(n.aside,{name:"c",children:["\n",(0,s.jsxs)(n.p,{children:["I'm surely biased, but I think Lox's syntax is pretty clean. C's most egregious\r\ngrammar problems are around types. Dennis Ritchie had this idea called\r\n\"",(0,s.jsx)(n.a,{href:"http://softwareengineering.stackexchange.com/questions/117024/why-was-the-c-syntax-for-arrays-pointers-and-functions-designed-this-way",children:"declaration reflects use"}),"\", where variable declarations mirror the\r\noperations you would have to perform on the variable to get to a value of the\r\nbase type. Clever idea, but I don't think it worked out great in practice."]}),"\n",(0,s.jsx)(n.p,{children:"Lox doesn't have static types, so we avoid that."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["What C-like syntax has instead is something you'll often find more valuable\r\nin a language: ",(0,s.jsx)(n.em,{children:"familiarity"}),". I know you are already comfortable with that style\r\nbecause the two languages we'll be using to ",(0,s.jsx)(n.em,{children:"implement"})," Lox -- Java and C --\r\nalso inherit it. Using a similar syntax for Lox gives you one less thing to\r\nlearn."]}),"\n",(0,s.jsx)(n.h2,{id:"a-high-level-language",children:"A High-Level Language"}),"\n",(0,s.jsx)(n.p,{children:"While this book ended up bigger than I was hoping, it's still not big enough to\r\nfit a huge language like Java in it. In order to fit two complete\r\nimplementations of Lox in these pages, Lox itself has to be pretty compact."}),"\n",(0,s.jsxs)(n.p,{children:['When I think of languages that are small but useful, what comes to mind are\r\nhigh-level "scripting" languages like ',(0,s.jsx)(n.span,{name:"js",children:"JavaScript"}),", Scheme,\r\nand Lua. Of those three, Lox looks most like JavaScript, mainly because most\r\nC-syntax languages do. As we'll learn later, Lox's approach to scoping hews\r\nclosely to Scheme. The C flavor of Lox we'll build in ",(0,s.jsx)(n.a,{href:"a-bytecode-virtual-machine.html",children:"Part III"})," is heavily\r\nindebted to Lua's clean, efficient implementation."]}),"\n",(0,s.jsxs)(n.aside,{name:"js",children:["\n",(0,s.jsxs)(n.p,{children:['Now that JavaScript has taken over the world and is used to build ginormous\r\napplications, it\'s hard to think of it as a "little scripting language". But\r\nBrendan Eich hacked the first JS interpreter into Netscape Navigator in ',(0,s.jsx)(n.em,{children:"ten\r\ndays"})," to make buttons animate on web pages. JavaScript has grown up since then,\r\nbut it was once a cute little language."]}),"\n",(0,s.jsxs)(n.p,{children:["Because Eich slapped JS together with roughly the same raw materials and time as\r\nan episode of MacGyver, it has some weird semantic corners where the duct tape\r\nand paper clips show through. Things like variable hoisting, dynamically bound\r\n",(0,s.jsx)(n.code,{children:"this"}),", holes in arrays, and implicit conversions."]}),"\n",(0,s.jsx)(n.p,{children:"I had the luxury of taking my time on Lox, so it should be a little cleaner."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Lox shares two other aspects with those three languages:"}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-typing",children:"Dynamic typing"}),"\n",(0,s.jsx)(n.p,{children:"Lox is dynamically typed. Variables can store values of any type, and a single\r\nvariable can even store values of different types at different times. If you try\r\nto perform an operation on values of the wrong type -- say, dividing a number by\r\na string -- then the error is detected and reported at runtime."}),"\n",(0,s.jsxs)(n.p,{children:["There are plenty of reasons to like ",(0,s.jsx)(n.span,{name:"static",children:"static"})," types, but\r\nthey don't outweigh the pragmatic reasons to pick dynamic types for Lox. A\r\nstatic type system is a ton of work to learn and implement. Skipping it gives\r\nyou a simpler language and a shorter book. We'll get our interpreter up and\r\nexecuting bits of code sooner if we defer our type checking to runtime."]}),"\n",(0,s.jsxs)(n.aside,{name:"static",children:["\n",(0,s.jsxs)(n.p,{children:["After all, the two languages we'll be using to ",(0,s.jsx)(n.em,{children:"implement"})," Lox are both\r\nstatically typed."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"automatic-memory-management",children:"Automatic memory management"}),"\n",(0,s.jsxs)(n.p,{children:["High-level languages exist to eliminate error-prone, low-level drudgery, and what\r\ncould be more tedious than manually managing the allocation and freeing of\r\nstorage? No one rises and greets the morning sun with, \"I can't wait to figure\r\nout the correct place to call ",(0,s.jsx)(n.code,{children:"free()"}),' for every byte of memory I allocate\r\ntoday!"']}),"\n",(0,s.jsxs)(n.p,{children:["There are two main ",(0,s.jsx)(n.span,{name:"gc",children:"techniques"})," for managing memory:\r\n",(0,s.jsx)(n.strong,{children:"reference counting"})," and ",(0,s.jsx)(n.strong,{children:"tracing garbage collection"})," (usually just called\r\n",(0,s.jsx)(n.strong,{children:"garbage collection"})," or ",(0,s.jsx)(n.strong,{children:"GC"}),"). Ref counters are much simpler to implement --\r\nI think that's why Perl, PHP, and Python all started out using them. But, over\r\ntime, the limitations of ref counting become too troublesome. All of those\r\nlanguages eventually ended up adding a full tracing GC, or at least enough of\r\none to clean up object cycles."]}),"\n",(0,s.jsxs)(n.aside,{name:"gc",children:["\n",(0,s.jsx)(n.p,{children:"In practice, ref counting and tracing are more ends of a continuum than\r\nopposing sides. Most ref counting systems end up doing some tracing to handle\r\ncycles, and the write barriers of a generational collector look a bit like\r\nretain calls if you squint."}),"\n",(0,s.jsxs)(n.p,{children:['For lots more on this, see "',(0,s.jsx)(n.a,{href:"https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf",children:"A Unified Theory of Garbage Collection"}),'" (PDF).']}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Tracing garbage collection has a fearsome reputation. It ",(0,s.jsx)(n.em,{children:"is"})," a little harrowing\r\nworking at the level of raw memory. Debugging a GC can sometimes leave you\r\nseeing hex dumps in your dreams. But, remember, this book is about dispelling\r\nmagic and slaying those monsters, so we ",(0,s.jsx)(n.em,{children:"are"})," going to write our own garbage\r\ncollector. I think you'll find the algorithm is quite simple and a lot of fun to\r\nimplement."]}),"\n",(0,s.jsx)(n.h2,{id:"data-types",children:"Data Types"}),"\n",(0,s.jsx)(n.p,{children:"In Lox's little universe, the atoms that make up all matter are the built-in\r\ndata types. There are only a few:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.span,{name:"bool",children:"Booleans"}),"."]}),' You can\'t code without logic and you\r\ncan\'t logic without Boolean values. "True" and "false", the yin and yang of\r\nsoftware. Unlike some ancient languages that repurpose an existing type to\r\nrepresent truth and falsehood, Lox has a dedicated Boolean type. We may\r\nbe roughing it on this expedition, but we aren\'t ',(0,s.jsx)(n.em,{children:"savages"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"bool",children:["\n",(0,s.jsx)(n.p,{children:'Boolean variables are the only data type in Lox named after a person, George\r\nBoole, which is why "Boolean" is capitalized. He died in 1864, nearly a\r\ncentury before digital computers turned his algebra into electricity. I\r\nwonder what he\'d think to see his name all over billions of lines of Java\r\ncode.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"There are two Boolean values, obviously, and a literal for each one."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"true;  // Not false.\r\nfalse; // Not *not* false.\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Numbers."})," Lox has only one kind of number: double-precision floating\r\npoint. Since floating-point numbers can also represent a wide range of\r\nintegers, that covers a lot of territory, while keeping things simple."]}),"\n",(0,s.jsx)(n.p,{children:"Full-featured languages have lots of syntax for numbers -- hexadecimal,\r\nscientific notation, octal, all sorts of fun stuff. We'll settle for basic\r\ninteger and decimal literals."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"1234;  // An integer.\r\n12.34; // A decimal number.\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Strings."})," We've already seen one string literal in the first example.\r\nLike most languages, they are enclosed in double quotes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'"I am a string";\r\n"";    // The empty string.\r\n"123"; // This is a string, not a number.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As we'll see when we get to implementing them, there is quite a lot of\r\ncomplexity hiding in that innocuous sequence of ",(0,s.jsx)(n.span,{name:"char",children:"characters"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"char",children:["\n",(0,s.jsx)(n.p,{children:'Even that word "character" is a trickster. Is it ASCII? Unicode? A\r\ncode point or a "grapheme cluster"? How are characters encoded? Is each\r\ncharacter a fixed size, or can they vary?'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nil."}),' There\'s one last built-in value who\'s never invited to the party\r\nbut always seems to show up. It represents "no value". It\'s called "null" in\r\nmany other languages. In Lox we spell it ',(0,s.jsx)(n.code,{children:"nil"}),". (When we get to implementing\r\nit, that will help distinguish when we're talking about Lox's ",(0,s.jsx)(n.code,{children:"nil"})," versus\r\nJava or C's ",(0,s.jsx)(n.code,{children:"null"}),".)"]}),"\n",(0,s.jsx)(n.p,{children:"There are good arguments for not having a null value in a language since\r\nnull pointer errors are the scourge of our industry. If we were doing a\r\nstatically typed language, it would be worth trying to ban it. In a\r\ndynamically typed one, though, eliminating it is often more annoying\r\nthan having it."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"expressions",children:"Expressions"}),"\n",(0,s.jsxs)(n.p,{children:["If built-in data types and their literals are atoms, then ",(0,s.jsx)(n.strong,{children:"expressions"})," must\r\nbe the molecules. Most of these will be familiar."]}),"\n",(0,s.jsx)(n.h3,{id:"arithmetic",children:"Arithmetic"}),"\n",(0,s.jsx)(n.p,{children:"Lox features the basic arithmetic operators you know and love from C and other\r\nlanguages:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"add + me;\r\nsubtract - me;\r\nmultiply * me;\r\ndivide / me;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The subexpressions on either side of the operator are ",(0,s.jsx)(n.strong,{children:"operands"}),". Because\r\nthere are ",(0,s.jsx)(n.em,{children:"two"})," of them, these are called ",(0,s.jsx)(n.strong,{children:"binary"}),' operators. (It has nothing\r\nto do with the ones-and-zeroes use of "binary".) Because the operator is ',(0,s.jsx)(n.span,{name:"fixity",children:"fixed"})," ",(0,s.jsx)(n.em,{children:"in"})," the middle of the operands, these are also\r\ncalled ",(0,s.jsx)(n.strong,{children:"infix"})," operators (as opposed to ",(0,s.jsx)(n.strong,{children:"prefix"})," operators where the\r\noperator comes before the operands, and ",(0,s.jsx)(n.strong,{children:"postfix"})," where it comes after)."]}),"\n",(0,s.jsxs)(n.aside,{name:"fixity",children:["\n",(0,s.jsx)(n.p,{children:'There are some operators that have more than two operands and the operators are\r\ninterleaved between them. The only one in wide usage is the "conditional" or\r\n"ternary" operator of C and friends:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"condition ? thenArm : elseArm;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Some call these ",(0,s.jsx)(n.strong,{children:"mixfix"}),' operators. A few languages let you define your own\r\noperators and control how they are positioned -- their "fixity".']}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["One arithmetic operator is actually ",(0,s.jsx)(n.em,{children:"both"})," an infix and a prefix one. The ",(0,s.jsx)(n.code,{children:"-"}),"\r\noperator can also be used to negate a number."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"-negateMe;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All of these operators work on numbers, and it's an error to pass any other\r\ntypes to them. The exception is the ",(0,s.jsx)(n.code,{children:"+"})," operator -- you can also pass it two\r\nstrings to concatenate them."]}),"\n",(0,s.jsx)(n.h3,{id:"comparison-and-equality",children:"Comparison and equality"}),"\n",(0,s.jsx)(n.p,{children:"Moving along, we have a few more operators that always return a Boolean result.\r\nWe can compare numbers (and only numbers), using Ye Olde Comparison Operators."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"less < than;\r\nlessThan <= orEqual;\r\ngreater > than;\r\ngreaterThan >= orEqual;\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can test two values of any kind for equality or inequality."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'1 == 2;         // false.\r\n"cat" != "dog"; // true.\n'})}),"\n",(0,s.jsx)(n.p,{children:"Even different types."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'314 == "pi"; // false.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Values of different types are ",(0,s.jsx)(n.em,{children:"never"})," equivalent."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'123 == "123"; // false.\n'})}),"\n",(0,s.jsx)(n.p,{children:"I'm generally against implicit conversions."}),"\n",(0,s.jsx)(n.h3,{id:"logical-operators",children:"Logical operators"}),"\n",(0,s.jsxs)(n.p,{children:["The not operator, a prefix ",(0,s.jsx)(n.code,{children:"!"}),", returns ",(0,s.jsx)(n.code,{children:"false"})," if its operand is true, and vice\r\nversa."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"!true;  // false.\r\n!false; // true.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The other two logical operators really are control flow constructs in the guise\r\nof expressions. An ",(0,s.jsx)(n.span,{name:"and",children:(0,s.jsx)(n.code,{children:"and"})})," expression determines if two\r\nvalues are ",(0,s.jsx)(n.em,{children:"both"})," true. It returns the left operand if it's false, or the\r\nright operand otherwise."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"true and false; // false.\r\ntrue and true;  // true.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And an ",(0,s.jsx)(n.code,{children:"or"})," expression determines if ",(0,s.jsx)(n.em,{children:"either"})," of two values (or both) are true.\r\nIt returns the left operand if it is true and the right operand otherwise."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"false or false; // false.\r\ntrue or false;  // true.\n"})}),"\n",(0,s.jsxs)(n.aside,{name:"and",children:["\n",(0,s.jsxs)(n.p,{children:["I used ",(0,s.jsx)(n.code,{children:"and"})," and ",(0,s.jsx)(n.code,{children:"or"})," for these instead of ",(0,s.jsx)(n.code,{children:"&&"})," and ",(0,s.jsx)(n.code,{children:"||"})," because Lox doesn't use\r\n",(0,s.jsx)(n.code,{children:"&"})," and ",(0,s.jsx)(n.code,{children:"|"})," for bitwise operators. It felt weird to introduce the\r\ndouble-character forms without the single-character ones."]}),"\n",(0,s.jsx)(n.p,{children:"I also kind of like using words for these since they are really control flow\r\nstructures and not simple operators."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The reason ",(0,s.jsx)(n.code,{children:"and"})," and ",(0,s.jsx)(n.code,{children:"or"})," are like control flow structures is that they\r\n",(0,s.jsx)(n.strong,{children:"short-circuit"}),". Not only does ",(0,s.jsx)(n.code,{children:"and"})," return the left operand if it is false,\r\nit doesn't even ",(0,s.jsx)(n.em,{children:"evaluate"})," the right one in that case. Conversely\r\n(contrapositively?), if the left operand of an ",(0,s.jsx)(n.code,{children:"or"})," is true, the right is\r\nskipped."]}),"\n",(0,s.jsx)(n.h3,{id:"precedence-and-grouping",children:"Precedence and grouping"}),"\n",(0,s.jsxs)(n.p,{children:["All of these operators have the same precedence and associativity that you'd\r\nexpect coming from C. (When we get to parsing, we'll get ",(0,s.jsx)(n.em,{children:"way"})," more precise\r\nabout that.) In cases where the precedence isn't what you want, you can use ",(0,s.jsx)(n.code,{children:"()"}),"\r\nto group stuff."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var average = (min + max) / 2;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Since they aren't very technically interesting, I've cut the remainder of the\r\ntypical operator menagerie out of our little language. No bitwise, shift,\r\nmodulo, or conditional operators. I'm not grading you, but you will get bonus\r\npoints in my heart if you augment your own implementation of Lox with them."}),"\n",(0,s.jsx)(n.p,{children:"Those are the expression forms (except for a couple related to specific features\r\nthat we'll get to later), so let's move up a level."}),"\n",(0,s.jsx)(n.h2,{id:"statements",children:"Statements"}),"\n",(0,s.jsxs)(n.p,{children:["Now we're at statements. Where an expression's main job is to produce a ",(0,s.jsx)(n.em,{children:"value"}),",\r\na statement's job is to produce an ",(0,s.jsx)(n.em,{children:"effect"}),". Since, by definition, statements\r\ndon't evaluate to a value, to be useful they have to otherwise change the world\r\nin some way -- usually modifying some state, reading input, or producing output."]}),"\n",(0,s.jsx)(n.p,{children:"You've seen a couple of kinds of statements already. The first one was:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'print "Hello, world!";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsxs)(n.span,{name:"print",children:[(0,s.jsx)(n.code,{children:"print"})," statement"]})," evaluates a single expression\r\nand displays the result to the user. You've also seen some statements like:"]}),"\n",(0,s.jsxs)(n.aside,{name:"print",children:["\n",(0,s.jsxs)(n.p,{children:["Baking ",(0,s.jsx)(n.code,{children:"print"})," into the language instead of just making it a core library\r\nfunction is a hack. But it's a ",(0,s.jsx)(n.em,{children:"useful"})," hack for us: it means our in-progress\r\ninterpreter can start producing output before we've implemented all of the\r\nmachinery required to define functions, look them up by name, and call them."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'"some expression";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["An expression followed by a semicolon (",(0,s.jsx)(n.code,{children:";"}),") promotes the expression to\r\nstatement-hood. This is called (imaginatively enough), an ",(0,s.jsx)(n.strong,{children:"expression\r\nstatement"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you want to pack a series of statements where a single one is expected, you\r\ncan wrap them up in a ",(0,s.jsx)(n.strong,{children:"block"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'{\r\n  print "One statement.";\r\n  print "Two statements.";\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Blocks also affect scoping, which leads us to the next section..."}),"\n",(0,s.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,s.jsxs)(n.p,{children:["You declare variables using ",(0,s.jsx)(n.code,{children:"var"})," statements. If you ",(0,s.jsx)(n.span,{name:"omit",children:"omit"})," the initializer, the variable's value defaults to ",(0,s.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"omit",children:["\n",(0,s.jsxs)(n.p,{children:["This is one of those cases where not having ",(0,s.jsx)(n.code,{children:"nil"})," and forcing every variable to\r\nbe initialized to some value would be more annoying than dealing with ",(0,s.jsx)(n.code,{children:"nil"}),"\r\nitself."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var imAVariable = "here is my value";\r\nvar iAmNil;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Once declared, you can, naturally, access and assign a variable using its name."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.span,{name:"breakfast"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var breakfast = "bagels";\r\nprint breakfast; // "bagels".\r\nbreakfast = "beignets";\r\nprint breakfast; // "beignets".\n'})}),"\n",(0,s.jsxs)(n.aside,{name:"breakfast",children:["\n",(0,s.jsx)(n.p,{children:"Can you tell that I tend to work on this book in the morning before I've had\r\nanything to eat?"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"I won't get into the rules for variable scope here, because we're going to spend\r\na surprising amount of time in later chapters mapping every square inch of the\r\nrules. In most cases, it works like you would expect coming from C or Java."}),"\n",(0,s.jsx)(n.h2,{id:"control-flow",children:"Control Flow"}),"\n",(0,s.jsxs)(n.p,{children:["It's hard to write ",(0,s.jsx)(n.span,{name:"flow",children:"useful"})," programs if you can't skip\r\nsome code or execute some more than once. That means control flow. In addition\r\nto the logical operators we already covered, Lox lifts three statements straight\r\nfrom C."]}),"\n",(0,s.jsxs)(n.aside,{name:"flow",children:["\n",(0,s.jsxs)(n.p,{children:["We already have ",(0,s.jsx)(n.code,{children:"and"})," and ",(0,s.jsx)(n.code,{children:"or"})," for branching, and we ",(0,s.jsx)(n.em,{children:"could"})," use recursion to\r\nrepeat code, so that's theoretically sufficient. It would be pretty awkward to\r\nprogram that way in an imperative-styled language, though."]}),"\n",(0,s.jsxs)(n.p,{children:["Scheme, on the other hand, has no built-in looping constructs. It ",(0,s.jsx)(n.em,{children:"does"})," rely on\r\nrecursion for repetition. Smalltalk has no built-in branching constructs, and\r\nrelies on dynamic dispatch for selectively executing code."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"if"})," statement executes one of two statements based on some condition."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'if (condition) {\r\n  print "yes";\r\n} else {\r\n  print "no";\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"while"})," ",(0,s.jsx)(n.span,{name:"do",children:"loop"})," executes the body repeatedly as long as\r\nthe condition expression evaluates to true."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var a = 1;\r\nwhile (a < 10) {\r\n  print a;\r\n  a = a + 1;\r\n}\n"})}),"\n",(0,s.jsxs)(n.aside,{name:"do",children:["\n",(0,s.jsxs)(n.p,{children:["I left ",(0,s.jsx)(n.code,{children:"do while"})," loops out of Lox because they aren't that common and wouldn't\r\nteach you anything that you won't already learn from ",(0,s.jsx)(n.code,{children:"while"}),". Go ahead and add\r\nit to your implementation if it makes you happy. It's your party."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Finally, we have ",(0,s.jsx)(n.code,{children:"for"})," loops."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"for (var a = 1; a < 10; a = a + 1) {\r\n  print a;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This loop does the same thing as the previous ",(0,s.jsx)(n.code,{children:"while"})," loop. Most modern\r\nlanguages also have some sort of ",(0,s.jsx)(n.span,{name:"foreach",children:(0,s.jsx)(n.code,{children:"for-in"})})," or\r\n",(0,s.jsx)(n.code,{children:"foreach"})," loop for explicitly iterating over various sequence types. In a real\r\nlanguage, that's nicer than the crude C-style ",(0,s.jsx)(n.code,{children:"for"})," loop we got here. Lox keeps\r\nit basic."]}),"\n",(0,s.jsxs)(n.aside,{name:"foreach",children:["\n",(0,s.jsxs)(n.p,{children:["This is a concession I made because of how the implementation is split across\r\nchapters. A ",(0,s.jsx)(n.code,{children:"for-in"})," loop needs some sort of dynamic dispatch in the iterator\r\nprotocol to handle different kinds of sequences, but we don't get that until\r\nafter we're done with control flow. We could circle back and add ",(0,s.jsx)(n.code,{children:"for-in"})," loops\r\nlater, but I didn't think doing so would teach you anything super interesting."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.p,{children:"A function call expression looks the same as it does in C."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"makeBreakfast(bacon, eggs, toast);\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can also call a function without passing anything to it."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"makeBreakfast();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Unlike in, say, Ruby, the parentheses are mandatory in this case. If you leave them\r\noff, the name doesn't ",(0,s.jsx)(n.em,{children:"call"})," the function, it just refers to it."]}),"\n",(0,s.jsxs)(n.p,{children:["A language isn't very fun if you can't define your own functions. In Lox, you do\r\nthat with ",(0,s.jsx)(n.span,{name:"fun",children:(0,s.jsx)(n.code,{children:"fun"})}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"fun",children:["\n",(0,s.jsxs)(n.p,{children:["I've seen languages that use ",(0,s.jsx)(n.code,{children:"fn"}),", ",(0,s.jsx)(n.code,{children:"fun"}),", ",(0,s.jsx)(n.code,{children:"func"}),", and ",(0,s.jsx)(n.code,{children:"function"}),". I'm still\r\nhoping to discover a ",(0,s.jsx)(n.code,{children:"funct"}),", ",(0,s.jsx)(n.code,{children:"functi"}),", or ",(0,s.jsx)(n.code,{children:"functio"})," somewhere."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"fun printSum(a, b) {\r\n  print a + b;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now's a good time to clarify some ",(0,s.jsx)(n.span,{name:"define",children:"terminology"}),'. Some\r\npeople throw around "parameter" and "argument" like they are interchangeable\r\nand, to many, they are. We\'re going to spend a lot of time splitting the finest\r\nof downy hairs around semantics, so let\'s sharpen our words. From here on out:']}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.strong,{children:"argument"})," is an actual value you pass to a function when you call it.\r\nSo a function ",(0,s.jsx)(n.em,{children:"call"})," has an ",(0,s.jsx)(n.em,{children:"argument"})," list. Sometimes you hear ",(0,s.jsx)(n.strong,{children:"actual\r\nparameter"})," used for these."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"parameter"})," is a variable that holds the value of the argument inside\r\nthe body of the function. Thus, a function ",(0,s.jsx)(n.em,{children:"declaration"})," has a ",(0,s.jsx)(n.em,{children:"parameter"}),"\r\nlist. Others call these ",(0,s.jsx)(n.strong,{children:"formal parameters"})," or simply ",(0,s.jsx)(n.strong,{children:"formals"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.aside,{name:"define",children:["\n",(0,s.jsxs)(n.p,{children:["Speaking of terminology, some statically typed languages like C make a\r\ndistinction between ",(0,s.jsx)(n.em,{children:"declaring"})," a function and ",(0,s.jsx)(n.em,{children:"defining"})," it. A declaration\r\nbinds the function's type to its name so that calls can be type-checked but does\r\nnot provide a body. A definition declares the function and also fills in the\r\nbody so that the function can be compiled."]}),"\n",(0,s.jsx)(n.p,{children:"Since Lox is dynamically typed, this distinction isn't meaningful. A function\r\ndeclaration fully specifies the function including its body."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The body of a function is always a block. Inside it, you can return a value\r\nusing a ",(0,s.jsx)(n.code,{children:"return"})," statement."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"fun returnSum(a, b) {\r\n  return a + b;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If execution reaches the end of the block without hitting a ",(0,s.jsx)(n.code,{children:"return"}),", it\r\n",(0,s.jsx)(n.span,{name:"sneaky",children:"implicitly"})," returns ",(0,s.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"sneaky",children:["\n",(0,s.jsxs)(n.p,{children:["See, I told you ",(0,s.jsx)(n.code,{children:"nil"})," would sneak in when we weren't looking."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"closures",children:"Closures"}),"\n",(0,s.jsxs)(n.p,{children:["Functions are ",(0,s.jsx)(n.em,{children:"first class"})," in Lox, which just means they are real values that\r\nyou can get a reference to, store in variables, pass around, etc. This works:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'fun addPair(a, b) {\r\n  return a + b;\r\n}\r\n\r\nfun identity(a) {\r\n  return a;\r\n}\r\n\r\nprint identity(addPair)(1, 2); // Prints "3".\n'})}),"\n",(0,s.jsx)(n.p,{children:"Since function declarations are statements, you can declare local functions\r\ninside another function."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'fun outerFunction() {\r\n  fun localFunction() {\r\n    print "I\'m local!";\r\n  }\r\n\r\n  localFunction();\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"If you combine local functions, first-class functions, and block scope, you run\r\ninto this interesting situation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'fun returnFunction() {\r\n  var outside = "outside";\r\n\r\n  fun inner() {\r\n    print outside;\r\n  }\r\n\r\n  return inner;\r\n}\r\n\r\nvar fn = returnFunction();\r\nfn();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"inner()"})," accesses a local variable declared outside of its body in the\r\nsurrounding function. Is this kosher? Now that lots of languages have borrowed\r\nthis feature from Lisp, you probably know the answer is yes."]}),"\n",(0,s.jsxs)(n.p,{children:["For that to work, ",(0,s.jsx)(n.code,{children:"inner()"}),' has to "hold on" to references to any surrounding\r\nvariables that it uses so that they stay around even after the outer function\r\nhas returned. We call functions that do this ',(0,s.jsx)(n.span,{name:"closure",children:(0,s.jsx)(n.strong,{children:"closures"})}),". These days, the term is often used for ",(0,s.jsx)(n.em,{children:"any"}),"\r\nfirst-class function, though it's sort of a misnomer if the function doesn't\r\nhappen to close over any variables."]}),"\n",(0,s.jsxs)(n.aside,{name:"closure",children:["\n",(0,s.jsxs)(n.p,{children:['Peter J. Landin coined the term "closure". Yes, he invented damn near half the\r\nterms in programming languages. Most of them came out of one incredible paper,\r\n"',(0,s.jsx)(n.a,{href:"https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/landin-next-700.pdf",children:"The Next 700 Programming Languages"}),'".']}),"\n",(0,s.jsxs)(n.p,{children:['In order to implement these kind of functions, you need to create a data\r\nstructure that bundles together the function\'s code and the surrounding\r\nvariables it needs. He called this a "closure" because it ',(0,s.jsx)(n.em,{children:"closes over"})," and\r\nholds on to the variables it needs."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"As you can imagine, implementing these adds some complexity because we can no\r\nlonger assume variable scope works strictly like a stack where local variables\r\nevaporate the moment the function returns. We're going to have a fun time\r\nlearning how to make these work correctly and efficiently."}),"\n",(0,s.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,s.jsxs)(n.p,{children:["Since Lox has dynamic typing, lexical (roughly, \"block\") scope, and closures,\r\nit's about halfway to being a functional language. But as you'll see, it's\r\n",(0,s.jsx)(n.em,{children:"also"})," about halfway to being an object-oriented language. Both paradigms have a\r\nlot going for them, so I thought it was worth covering some of each."]}),"\n",(0,s.jsx)(n.p,{children:"Since classes have come under fire for not living up to their hype, let me first\r\nexplain why I put them into Lox and this book. There are really two questions:"}),"\n",(0,s.jsx)(n.h3,{id:"why-might-any-language-want-to-be-object-oriented",children:"Why might any language want to be object oriented?"}),"\n",(0,s.jsxs)(n.p,{children:["Now that object-oriented languages like Java have sold out and only play arena\r\nshows, it's not cool to like them anymore. Why would anyone make a ",(0,s.jsx)(n.em,{children:"new"}),"\r\nlanguage with objects? Isn't that like releasing music on 8-track?"]}),"\n",(0,s.jsxs)(n.p,{children:['It is true that the "all inheritance all the time" binge of the \'90s produced\r\nsome monstrous class hierarchies, but ',(0,s.jsx)(n.strong,{children:"object-oriented programming"})," (",(0,s.jsx)(n.strong,{children:"OOP"}),")\r\nis still pretty rad. Billions of lines of successful code have been written in\r\nOOP languages, shipping millions of apps to happy users. Likely a majority of\r\nworking programmers today are using an object-oriented language. They can't all\r\nbe ",(0,s.jsx)(n.em,{children:"that"})," wrong."]}),"\n",(0,s.jsxs)(n.p,{children:["In particular, for a dynamically typed language, objects are pretty handy. We\r\nneed ",(0,s.jsx)(n.em,{children:"some"})," way of defining compound data types to bundle blobs of stuff\r\ntogether."]}),"\n",(0,s.jsxs)(n.p,{children:["If we can also hang methods off of those, then we avoid the need to prefix all\r\nof our functions with the name of the data type they operate on to avoid\r\ncolliding with similar functions for different types. In, say, Racket, you end\r\nup having to name your functions like ",(0,s.jsx)(n.code,{children:"hash-copy"})," (to copy a hash table) and\r\n",(0,s.jsx)(n.code,{children:"vector-copy"})," (to copy a vector) so that they don't step on each other. Methods\r\nare scoped to the object, so that problem goes away."]}),"\n",(0,s.jsx)(n.h3,{id:"why-is-lox-object-oriented",children:"Why is Lox object oriented?"}),"\n",(0,s.jsx)(n.p,{children:"I could claim objects are groovy but still out of scope for the book. Most\r\nprogramming language books, especially ones that try to implement a whole\r\nlanguage, leave objects out. To me, that means the topic isn't well covered.\r\nWith such a widespread paradigm, that omission makes me sad."}),"\n",(0,s.jsxs)(n.p,{children:["Given how many of us spend all day ",(0,s.jsx)(n.em,{children:"using"})," OOP languages, it seems like the\r\nworld could use a little documentation on how to ",(0,s.jsx)(n.em,{children:"make"})," one. As you'll see, it\r\nturns out to be pretty interesting. Not as hard as you might fear, but not as\r\nsimple as you might presume, either."]}),"\n",(0,s.jsx)(n.h3,{id:"classes-or-prototypes",children:"Classes or prototypes"}),"\n",(0,s.jsxs)(n.p,{children:["When it comes to objects, there are actually two approaches to them, ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Class-based_programming",children:"classes"}),"\r\nand ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Prototype-based_programming",children:"prototypes"}),". Classes came first, and are more common thanks to C++, Java,\r\nC#, and friends. Prototypes were a virtually forgotten offshoot until JavaScript\r\naccidentally took over the world."]}),"\n",(0,s.jsxs)(n.p,{children:["In class-based languages, there are two core concepts: instances and classes.\r\nInstances store the state for each object and have a reference to the instance's\r\nclass. Classes contain the methods and inheritance chain. To call a method on an\r\ninstance, there is always a level of indirection. You ",(0,s.jsx)(n.span,{name:"dispatch",children:"look"})," up the instance's class and then you find the method\r\n",(0,s.jsx)(n.em,{children:"there"}),":"]}),"\n",(0,s.jsxs)(n.aside,{name:"dispatch",children:["\n",(0,s.jsxs)(n.p,{children:["In a statically typed language like C++, method lookup typically happens at\r\ncompile time based on the ",(0,s.jsx)(n.em,{children:"static"})," type of the instance, giving you ",(0,s.jsx)(n.strong,{children:"static\r\ndispatch"}),". In contrast, ",(0,s.jsx)(n.strong,{children:"dynamic dispatch"})," looks up the class of the actual\r\ninstance object at runtime. This is how virtual methods in statically typed\r\nlanguages and all methods in a dynamically typed language like Lox work."]}),"\n"]}),"\n",(0,s.jsx)(n.img,{src:"image/the-lox-language/class-lookup.png",alt:"How fields and methods are looked up on classes and instances"}),"\n",(0,s.jsxs)(n.p,{children:["Prototype-based languages ",(0,s.jsx)(n.span,{name:"blurry",children:"merge"}),' these two concepts.\r\nThere are only objects -- no classes -- and each individual object may contain\r\nstate and methods. Objects can directly inherit from each other (or "delegate\r\nto" in prototypal lingo):']}),"\n",(0,s.jsxs)(n.aside,{name:"blurry",children:["\n",(0,s.jsxs)(n.p,{children:['In practice the line between class-based and prototype-based languages blurs.\r\nJavaScript\'s "constructor function" notion ',(0,s.jsx)(n.a,{href:"http://gameprogrammingpatterns.com/prototype.html#what-about-javascript",children:"pushes you pretty hard"}),"\r\ntowards defining class-like objects. Meanwhile, class-based Ruby is perfectly\r\nhappy to let you attach methods to individual instances."]}),"\n"]}),"\n",(0,s.jsx)(n.img,{src:"image/the-lox-language/prototype-lookup.png",alt:"How fields and methods are looked up in a prototypal system"}),"\n",(0,s.jsxs)(n.p,{children:["This means that in some ways prototypal languages are more fundamental than\r\nclasses. They are really neat to implement because they're ",(0,s.jsx)(n.em,{children:"so"})," simple. Also,\r\nthey can express lots of unusual patterns that classes steer you away from."]}),"\n",(0,s.jsxs)(n.p,{children:["But I've looked at a ",(0,s.jsx)(n.em,{children:"lot"})," of code written in prototypal languages -- including\r\n",(0,s.jsx)(n.a,{href:"http://finch.stuffwithstuff.com/",children:"some of my own devising"}),". Do you know what people generally do with all\r\nof the power and flexibility of prototypes? ...They use them to reinvent\r\nclasses."]}),"\n",(0,s.jsxs)(n.p,{children:["I don't know ",(0,s.jsx)(n.em,{children:"why"})," that is, but people naturally seem to prefer a class-based\r\n(Classic? Classy?) style. Prototypes ",(0,s.jsx)(n.em,{children:"are"})," simpler in the language, but they\r\nseem to accomplish that only by ",(0,s.jsx)(n.span,{name:"waterbed",children:"pushing"})," the\r\ncomplexity onto the user. So, for Lox, we'll save our users the trouble and bake\r\nclasses right in."]}),"\n",(0,s.jsxs)(n.aside,{name:"waterbed",children:["\n",(0,s.jsxs)(n.p,{children:["Larry Wall, Perl's inventor/prophet calls this the \"",(0,s.jsx)(n.a,{href:"http://wiki.c2.com/?WaterbedTheory",children:"waterbed theory"}),'". Some\r\ncomplexity is essential and cannot be eliminated. If you push it down in one\r\nplace, it swells up in another.']}),"\n",(0,s.jsxs)(n.p,{children:["Prototypal languages don't so much ",(0,s.jsx)(n.em,{children:"eliminate"})," the complexity of classes as they\r\ndo make the ",(0,s.jsx)(n.em,{children:"user"})," take that complexity by building their own class-like\r\nmetaprogramming libraries."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"classes-in-lox",children:"Classes in Lox"}),"\n",(0,s.jsx)(n.p,{children:"Enough rationale, let's see what we actually have. Classes encompass a\r\nconstellation of features in most languages. For Lox, I've selected what I think\r\nare the brightest stars. You declare a class and its methods like so:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Breakfast {\r\n  cook() {\r\n    print "Eggs a-fryin\'!";\r\n  }\r\n\r\n  serve(who) {\r\n    print "Enjoy your breakfast, " + who + ".";\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The body of a class contains its methods. They look like function declarations\r\nbut without the ",(0,s.jsx)(n.code,{children:"fun"})," ",(0,s.jsx)(n.span,{name:"method",children:"keyword"}),". When the class\r\ndeclaration is executed, Lox creates a class object and stores that in a\r\nvariable named after the class. Just like functions, classes are first class in\r\nLox."]}),"\n",(0,s.jsxs)(n.aside,{name:"method",children:["\n",(0,s.jsx)(n.p,{children:"They are still just as fun, though."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"// Store it in variables.\r\nvar someVariable = Breakfast;\r\n\r\n// Pass it to functions.\r\nsomeFunction(Breakfast);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, we need a way to create instances. We could add some sort of ",(0,s.jsx)(n.code,{children:"new"}),"\r\nkeyword, but to keep things simple, in Lox the class itself is a factory\r\nfunction for instances. Call a class like a function, and it produces a new\r\ninstance of itself."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var breakfast = Breakfast();\r\nprint breakfast; // "Breakfast instance".\n'})}),"\n",(0,s.jsx)(n.h3,{id:"instantiation-and-initialization",children:"Instantiation and initialization"}),"\n",(0,s.jsxs)(n.p,{children:["Classes that only have behavior aren't super useful. The idea behind\r\nobject-oriented programming is encapsulating behavior ",(0,s.jsx)(n.em,{children:"and state"})," together. To\r\ndo that, you need fields. Lox, like other dynamically typed languages, lets you\r\nfreely add properties onto objects."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'breakfast.meat = "sausage";\r\nbreakfast.bread = "sourdough";\n'})}),"\n",(0,s.jsx)(n.p,{children:"Assigning to a field creates it if it doesn't already exist."}),"\n",(0,s.jsxs)(n.p,{children:["If you want to access a field or method on the current object from within a\r\nmethod, you use good old ",(0,s.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Breakfast {\r\n  serve(who) {\r\n    print "Enjoy your " + this.meat + " and " +\r\n        this.bread + ", " + who + ".";\r\n  }\r\n\r\n  // ...\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Part of encapsulating data within an object is ensuring the object is in a valid\r\nstate when it's created. To do that, you can define an initializer. If your\r\nclass has a method named ",(0,s.jsx)(n.code,{children:"init()"}),", it is called automatically when the object is\r\nconstructed. Any parameters passed to the class are forwarded to its\r\ninitializer."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Breakfast {\r\n  init(meat, bread) {\r\n    this.meat = meat;\r\n    this.bread = bread;\r\n  }\r\n\r\n  // ...\r\n}\r\n\r\nvar baconAndToast = Breakfast("bacon", "toast");\r\nbaconAndToast.serve("Dear Reader");\r\n// "Enjoy your bacon and toast, Dear Reader."\n'})}),"\n",(0,s.jsx)(n.h3,{id:"inheritance",children:"Inheritance"}),"\n",(0,s.jsxs)(n.p,{children:["Every object-oriented language lets you not only define methods, but reuse them\r\nacross multiple classes or objects. For that, Lox supports single inheritance.\r\nWhen you declare a class, you can specify a class that it inherits from using a less-than\r\n",(0,s.jsxs)(n.span,{className:"origin-text",children:['span name="less"',(0,s.jsx)(n.span,{className:"translated-text",children:(0,s.jsx)(n.code,{children:"<"})})]})," operator."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Brunch < Breakfast {\r\n  drink() {\r\n    print "How about a Bloody Mary?";\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(n.aside,{name:"less",children:["\n",(0,s.jsxs)(n.p,{children:["Why the ",(0,s.jsx)(n.code,{children:"<"})," operator? I didn't feel like introducing a new keyword like\r\n",(0,s.jsx)(n.code,{children:"extends"}),". Lox doesn't use ",(0,s.jsx)(n.code,{children:":"})," for anything else so I didn't want to reserve\r\nthat either. Instead, I took a page from Ruby and used ",(0,s.jsx)(n.code,{children:"<"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you know any type theory, you'll notice it's not a ",(0,s.jsx)(n.em,{children:"totally"})," arbitrary\r\nchoice. Every instance of a subclass is an instance of its superclass too, but\r\nthere may be instances of the superclass that are not instances of the subclass.\r\nThat means, in the universe of objects, the set of subclass objects is smaller\r\nthan the superclass's set, though type nerds usually use ",(0,s.jsx)(n.code,{children:"<:"})," for that relation."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Here, Brunch is the ",(0,s.jsx)(n.strong,{children:"derived class"})," or ",(0,s.jsx)(n.strong,{children:"subclass"}),", and Breakfast is the\r\n",(0,s.jsx)(n.strong,{children:"base class"})," or ",(0,s.jsx)(n.strong,{children:"superclass"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Every method defined in the superclass is also available to its subclasses."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'var benedict = Brunch("ham", "English muffin");\r\nbenedict.serve("Noble Reader");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Even the ",(0,s.jsx)(n.code,{children:"init()"})," method gets ",(0,s.jsx)(n.span,{name:"init",children:"inherited"}),". In practice,\r\nthe subclass usually wants to define its own ",(0,s.jsx)(n.code,{children:"init()"})," method too. But the\r\noriginal one also needs to be called so that the superclass can maintain its\r\nstate. We need some way to call a method on our own ",(0,s.jsx)(n.em,{children:"instance"})," without hitting\r\nour own ",(0,s.jsx)(n.em,{children:"methods"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"init",children:["\n",(0,s.jsx)(n.p,{children:"Lox is different from C++, Java, and C#, which do not inherit constructors, but\r\nsimilar to Smalltalk and Ruby, which do."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As in Java, you use ",(0,s.jsx)(n.code,{children:"super"})," for that."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Brunch < Breakfast {\r\n  init(meat, bread, drink) {\r\n    super.init(meat, bread);\r\n    this.drink = drink;\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["That's about it for object orientation. I tried to keep the feature set minimal.\r\nThe structure of the book did force one compromise. Lox is not a ",(0,s.jsx)(n.em,{children:"pure"}),"\r\nobject-oriented language. In a true OOP language every object is an instance of\r\na class, even primitive values like numbers and Booleans."]}),"\n",(0,s.jsx)(n.p,{children:"Because we don't implement classes until well after we start working with the\r\nbuilt-in types, that would have been hard. So values of primitive types aren't\r\nreal objects in the sense of being instances of classes. They don't have methods\r\nor properties. If I were trying to make Lox a real language for real users, I\r\nwould fix that."}),"\n",(0,s.jsx)(n.h2,{id:"the-standard-library",children:"The Standard Library"}),"\n",(0,s.jsx)(n.p,{children:'We\'re almost done. That\'s the whole language, so all that\'s left is the "core"\r\nor "standard" library -- the set of functionality that is implemented directly\r\nin the interpreter and that all user-defined behavior is built on top of.'}),"\n",(0,s.jsxs)(n.p,{children:["This is the saddest part of Lox. Its standard library goes beyond minimalism and\r\nveers close to outright nihilism. For the sample code in the book, we only need\r\nto demonstrate that code is running and doing what it's supposed to do. For\r\nthat, we already have the built-in ",(0,s.jsx)(n.code,{children:"print"})," statement."]}),"\n",(0,s.jsxs)(n.p,{children:["Later, when we start optimizing, we'll write some benchmarks and see how long it\r\ntakes to execute code. That means we need to track time, so we'll define one\r\nbuilt-in function, ",(0,s.jsx)(n.code,{children:"clock()"}),", that returns the number of seconds since the\r\nprogram started."]}),"\n",(0,s.jsx)(n.p,{children:"And... that's it. I know, right? It's embarrassing."}),"\n",(0,s.jsxs)(n.p,{children:["If you wanted to turn Lox into an actual useful language, the very first thing\r\nyou should do is flesh this out. String manipulation, trigonometric functions,\r\nfile I/O, networking, heck, even ",(0,s.jsx)(n.em,{children:"reading input from the user"})," would help. But we\r\ndon't need any of that for this book, and adding it wouldn't teach you anything\r\ninteresting, so I've left it out."]}),"\n",(0,s.jsx)(n.p,{children:"Don't worry, we'll have plenty of exciting stuff in the language itself to keep\r\nus busy."}),"\n",(0,s.jsxs)(n.div,{className:"challenges",children:["\n",(0,s.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Write some sample Lox programs and run them (you can use the implementations\r\nof Lox in ",(0,s.jsx)(n.a,{href:"https://github.com/munificent/craftinginterpreters",children:"my repository"}),"). Try to come up with edge case behavior I\r\ndidn't specify here. Does it do what you expect? Why or why not?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["This informal introduction leaves a ",(0,s.jsx)(n.em,{children:"lot"})," unspecified. List several open\r\nquestions you have about the language's syntax and semantics. What do you\r\nthink the answers should be?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Lox is a pretty tiny language. What features do you think it is missing that\r\nwould make it annoying to use for real programs? (Aside from the standard\r\nlibrary, of course.)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.div,{className:"design-note",children:["\n",(0,s.jsx)(n.h2,{id:"design-note-expressions-and-statements",children:"Design Note: Expressions and Statements"}),"\n",(0,s.jsx)(n.p,{children:'Lox has both expressions and statements. Some languages omit the latter.\r\nInstead, they treat declarations and control flow constructs as expressions too.\r\nThese "everything is an expression" languages tend to have functional pedigrees\r\nand include most Lisps, SML, Haskell, Ruby, and CoffeeScript.'}),"\n",(0,s.jsx)(n.p,{children:'To do that, for each "statement-like" construct in the language, you need to\r\ndecide what value it evaluates to. Some of those are easy:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"if"})," expression evaluates to the result of whichever branch is chosen.\r\nLikewise, a ",(0,s.jsx)(n.code,{children:"switch"})," or other multi-way branch evaluates to whichever case\r\nis picked."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A variable declaration evaluates to the value of the variable."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A block evaluates to the result of the last expression in the sequence."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Some get a little stranger. What should a loop evaluate to? A ",(0,s.jsx)(n.code,{children:"while"})," loop in\r\nCoffeeScript evaluates to an array containing each element that the body\r\nevaluated to. That can be handy, or a waste of memory if you don't need the\r\narray."]}),"\n",(0,s.jsx)(n.p,{children:"You also have to decide how these statement-like expressions compose with other\r\nexpressions -- you have to fit them into the grammar's precedence table. For\r\nexample, Ruby allows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"puts 1 + if true then 2 else 3 end + 4\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Is this what you'd expect? Is it what your ",(0,s.jsx)(n.em,{children:"users"}),' expect? How does this affect\r\nhow you design the syntax for your "statements"? Note that Ruby has an explicit\r\n',(0,s.jsx)(n.code,{children:"end"})," to tell when the ",(0,s.jsx)(n.code,{children:"if"})," expression is complete. Without it, the ",(0,s.jsx)(n.code,{children:"+ 4"})," would\r\nlikely be parsed as part of the ",(0,s.jsx)(n.code,{children:"else"})," clause."]}),"\n",(0,s.jsxs)(n.p,{children:["Turning every statement into an expression forces you to answer a few hairy\r\nquestions like that. In return, you eliminate some redundancy. C has both blocks\r\nfor sequencing statements, and the comma operator for sequencing expressions. It\r\nhas both the ",(0,s.jsx)(n.code,{children:"if"})," statement and the ",(0,s.jsx)(n.code,{children:"?:"})," conditional operator. If everything was\r\nan expression in C, you could unify each of those."]}),"\n",(0,s.jsxs)(n.p,{children:["Languages that do away with statements usually also feature ",(0,s.jsx)(n.strong,{children:"implicit returns"}),"\r\n-- a function automatically returns whatever value its body evaluates to without\r\nneed for some explicit ",(0,s.jsx)(n.code,{children:"return"})," syntax. For small functions and methods, this is\r\nreally handy. In fact, many languages that do have statements have added syntax\r\nlike ",(0,s.jsx)(n.code,{children:"=>"})," to be able to define functions whose body is the result of evaluating\r\na single expression."]}),"\n",(0,s.jsxs)(n.p,{children:["But making ",(0,s.jsx)(n.em,{children:"all"})," functions work that way can be a little strange. If you aren't\r\ncareful, your function will leak a return value even if you only intend it to\r\nproduce a side effect. In practice, though, users of these languages don't find\r\nit to be a problem."]}),"\n",(0,s.jsx)(n.p,{children:"For Lox, I gave it statements for prosaic reasons. I picked a C-like syntax for\r\nfamiliarity's sake, and trying to take the existing C statement syntax and\r\ninterpret it like expressions gets weird pretty fast."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(6540);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);