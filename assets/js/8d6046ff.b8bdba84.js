"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[5023],{2527:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var r=t(4848),a=t(8453);const s={},o=void 0,i={id:"Craftinginterpreters/not-translated-yet/closures",title:"closures",description:"As the man said, for every complex problem there's a simple solution, and it's",source:"@site/docs/Craftinginterpreters/not-translated-yet/closures.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/closures",permalink:"/docs/Craftinginterpreters/not-translated-yet/closures",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/closures.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"classes",permalink:"/docs/Craftinginterpreters/not-translated-yet/classes"},next:{title:"compiling-expressions",permalink:"/docs/Craftinginterpreters/not-translated-yet/compiling-expressions"}},l={},c=[{value:"Closure Objects",id:"closure-objects",level:2},{value:"Compiling to closure objects",id:"compiling-to-closure-objects",level:3},{value:"Interpreting function declarations",id:"interpreting-function-declarations",level:3},{value:"Upvalues",id:"upvalues",level:2},{value:"Compiling upvalues",id:"compiling-upvalues",level:3},{value:"Flattening upvalues",id:"flattening-upvalues",level:3},{value:"Upvalue Objects",id:"upvalue-objects",level:2},{value:"Upvalues in closures",id:"upvalues-in-closures",level:3},{value:"Closed Upvalues",id:"closed-upvalues",level:2},{value:"Values and variables",id:"values-and-variables",level:3},{value:"Closing upvalues",id:"closing-upvalues",level:3},{value:"Tracking open upvalues",id:"tracking-open-upvalues",level:3},{value:"Closing upvalues at runtime",id:"closing-upvalues-at-runtime",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Closing Over the Loop Variable",id:"design-note-closing-over-the-loop-variable",level:2}];function h(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"As the man said, for every complex problem there's a simple solution, and it's\r\nwrong."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["Umberto Eco, ",(0,r.jsx)(n.em,{children:"Foucault's Pendulum"})]})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Thanks to our diligent labor in ",(0,r.jsx)(n.a,{href:"calls-and-functions.html",children:"the last chapter"}),", we have a virtual\r\nmachine with working functions. What it lacks is closures. Aside from global\r\nvariables, which are their own breed of animal, a function has no way to\r\nreference a variable declared outside of its own body."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var x = "global";\r\nfun outer() {\r\n  var x = "outer";\r\n  fun inner() {\r\n    print x;\r\n  }\r\n  inner();\r\n}\r\nouter();\n'})}),"\n",(0,r.jsx)(n.p,{children:'Run this example now and it prints "global". It\'s supposed to print "outer". To\r\nfix this, we need to include the entire lexical scope of all surrounding\r\nfunctions when resolving a variable.'}),"\n",(0,r.jsxs)(n.p,{children:["This problem is harder in clox than it was in jlox because our bytecode VM\r\nstores locals on a stack. We used a stack because I claimed locals have stack\r\nsemantics -- variables are discarded in the reverse order that they are created.\r\nBut with closures, that's only ",(0,r.jsx)(n.em,{children:"mostly"})," true."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun makeClosure() {\r\n  var local = "local";\r\n  fun closure() {\r\n    print local;\r\n  }\r\n  return closure;\r\n}\r\n\r\nvar closure = makeClosure();\r\nclosure();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The outer function ",(0,r.jsx)(n.code,{children:"makeClosure()"})," declares a variable, ",(0,r.jsx)(n.code,{children:"local"}),". It also creates\r\nan inner function, ",(0,r.jsx)(n.code,{children:"closure()"})," that captures that variable. Then ",(0,r.jsx)(n.code,{children:"makeClosure()"}),"\r\nreturns a reference to that function. Since the closure ",(0,r.jsx)(n.span,{name:"flying",children:"escapes"})," while holding on to the local variable, ",(0,r.jsx)(n.code,{children:"local"})," must\r\noutlive the function call where it was created."]}),"\n",(0,r.jsxs)(n.aside,{name:"flying",children:["\n",(0,r.jsx)(n.img,{src:"image/closures/flying.png",className:"above",alt:"A local variable flying away from the stack."}),"\n",(0,r.jsx)(n.p,{children:"Oh no, it's escaping!"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We could solve this problem by dynamically allocating memory for all local\r\nvariables. That's what jlox does by putting everything in those Environment\r\nobjects that float around in Java's heap. But we don't want to. Using a ",(0,r.jsx)(n.span,{name:"stack",children:"stack"})," is ",(0,r.jsx)(n.em,{children:"really"})," fast. Most local variables are ",(0,r.jsx)(n.em,{children:"not"}),"\r\ncaptured by closures and do have stack semantics. It would suck to make all of\r\nthose slower for the benefit of the rare local that is captured."]}),"\n",(0,r.jsxs)(n.aside,{name:"stack",children:["\n",(0,r.jsx)(n.p,{children:"There is a reason that C and Java use the stack for their local variables, after\r\nall."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This means a more complex approach than we used in our Java interpreter. Because\r\nsome locals have very different lifetimes, we will have two implementation\r\nstrategies. For locals that aren't used in closures, we'll keep them just as\r\nthey are on the stack. When a local is captured by a closure, we'll adopt\r\nanother solution that lifts them onto the heap where they can live as long as\r\nneeded."}),"\n",(0,r.jsxs)(n.p,{children:["Closures have been around since the early Lisp days when bytes of memory and CPU\r\ncycles were more precious than emeralds. Over the intervening decades, hackers\r\ndevised all ",(0,r.jsx)(n.span,{name:"lambda",children:"manner"})," of ways to compile closures to\r\noptimized runtime representations. Some are more efficient but require a more\r\ncomplex compilation process than we could easily retrofit into clox."]}),"\n",(0,r.jsxs)(n.aside,{name:"lambda",children:["\n",(0,r.jsx)(n.p,{children:'Search for "closure conversion" or "lambda lifting" to start exploring.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The technique I explain here comes from the design of the Lua VM. It is fast,\r\nparsimonious with memory, and implemented with relatively little code. Even more\r\nimpressive, it fits naturally into the single-pass compilers clox and Lua both\r\nuse. It is somewhat intricate, though. It might take a while before all the\r\npieces click together in your mind. We'll build them one step at a time, and\r\nI'll try to introduce the concepts in stages."}),"\n",(0,r.jsx)(n.h2,{id:"closure-objects",children:"Closure Objects"}),"\n",(0,r.jsxs)(n.p,{children:['Our VM represents functions at runtime using ObjFunction. These objects are\r\ncreated by the front end during compilation. At runtime, all the VM does is load\r\nthe function object from a constant table and bind it to a name. There is no\r\noperation to "create" a function at runtime. Much like string and number ',(0,r.jsx)(n.span,{name:"literal",children:"literals"}),", they are constants instantiated purely at\r\ncompile time."]}),"\n",(0,r.jsxs)(n.aside,{name:"literal",children:["\n",(0,r.jsxs)(n.p,{children:["In other words, a function declaration in Lox ",(0,r.jsx)(n.em,{children:"is"})," a kind of literal -- a piece\r\nof syntax that defines a constant value of a built-in type."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"That made sense because all of the data that composes a function is known at\r\ncompile time: the chunk of bytecode compiled from the function's body, and the\r\nconstants used in the body. Once we introduce closures, though, that\r\nrepresentation is no longer sufficient. Take a gander at:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun makeClosure(value) {\r\n  fun closure() {\r\n    print value;\r\n  }\r\n  return closure;\r\n}\r\n\r\nvar doughnut = makeClosure("doughnut");\r\nvar bagel = makeClosure("bagel");\r\ndoughnut();\r\nbagel();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"makeClosure()"})," function defines and returns a function. We call it twice\r\nand get two closures back. They are created by the same nested function\r\ndeclaration, ",(0,r.jsx)(n.code,{children:"closure"}),", but close over different values. When we call the two\r\nclosures, each prints a different string. That implies we need some runtime\r\nrepresentation for a closure that captures the local variables surrounding the\r\nfunction as they exist when the function declaration is ",(0,r.jsx)(n.em,{children:"executed"}),", not just\r\nwhen it is compiled."]}),"\n",(0,r.jsxs)(n.p,{children:["We'll work our way up to capturing variables, but a good first step is defining\r\nthat object representation. Our existing ObjFunction type represents the ",(0,r.jsx)(n.span,{name:"raw",children:'"raw"'})," compile-time state of a function declaration, since all\r\nclosures created from a single declaration share the same code and constants. At\r\nruntime, when we execute a function declaration, we wrap the ObjFunction in a\r\nnew ObjClosure structure. The latter has a reference to the underlying bare\r\nfunction along with runtime state for the variables the function closes over."]}),"\n",(0,r.jsxs)(n.aside,{name:"raw",children:["\n",(0,r.jsxs)(n.p,{children:['The Lua implementation refers to the raw function object containing the bytecode\r\nas a "prototype", which is a great word to describe this, except that word also\r\ngets overloaded to refer to ',(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Prototype-based_programming",children:"prototypal inheritance"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.img,{src:"image/closures/obj-closure.png",alt:"An ObjClosure with a reference to an ObjFunction."}),"\n",(0,r.jsx)(n.p,{children:"We'll wrap every function in an ObjClosure, even if the function doesn't\r\nactually close over and capture any surrounding local variables. This is a\r\nlittle wasteful, but it simplifies the VM because we can always assume that the\r\nfunction we're calling is an ObjClosure. That new struct starts out like this:"}),"\n",(0,r.jsx)(n.p,{children:"^code obj-closure"}),"\n",(0,r.jsx)(n.p,{children:"Right now, it simply points to an ObjFunction and adds the necessary object\r\nheader stuff. Grinding through the usual ceremony for adding a new object type\r\nto clox, we declare a C function to create a new closure."}),"\n",(0,r.jsx)(n.p,{children:"^code new-closure-h (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Then we implement it here:"}),"\n",(0,r.jsx)(n.p,{children:"^code new-closure"}),"\n",(0,r.jsx)(n.p,{children:"It takes a pointer to the ObjFunction it wraps. It also initializes the type\r\nfield to a new type."}),"\n",(0,r.jsx)(n.p,{children:"^code obj-type-closure (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And when we're done with a closure, we release its memory."}),"\n",(0,r.jsx)(n.p,{children:"^code free-closure (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We free only the ObjClosure itself, not the ObjFunction. That's because the\r\nclosure doesn't ",(0,r.jsx)(n.em,{children:"own"})," the function. There may be multiple closures that all\r\nreference the same function, and none of them claims any special privilege over\r\nit. We can't free the ObjFunction until ",(0,r.jsx)(n.em,{children:"all"})," objects referencing it are gone --\r\nincluding even the surrounding function whose constant table contains it.\r\nTracking that sounds tricky, and it is! That's why we'll write a garbage\r\ncollector soon to manage it for us."]}),"\n",(0,r.jsxs)(n.p,{children:["We also have the usual ",(0,r.jsx)(n.span,{name:"macro",children:"macros"})," for checking a value's\r\ntype."]}),"\n",(0,r.jsxs)(n.aside,{name:"macro",children:["\n",(0,r.jsx)(n.p,{children:"Perhaps I should have defined a macro to make it easier to generate these\r\nmacros. Maybe that would be a little too meta."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code is-closure (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And to cast a value:"}),"\n",(0,r.jsx)(n.p,{children:"^code as-closure (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Closures are first-class objects, so you can print them."}),"\n",(0,r.jsx)(n.p,{children:"^code print-closure (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"They display exactly as ObjFunction does. From the user's perspective, the\r\ndifference between ObjFunction and ObjClosure is purely a hidden implementation\r\ndetail. With that out of the way, we have a working but empty representation for\r\nclosures."}),"\n",(0,r.jsx)(n.h3,{id:"compiling-to-closure-objects",children:"Compiling to closure objects"}),"\n",(0,r.jsx)(n.p,{children:"We have closure objects, but our VM never creates them. The next step is getting\r\nthe compiler to emit instructions to tell the runtime when to create a new\r\nObjClosure to wrap a given ObjFunction. This happens right at the end of a\r\nfunction declaration."}),"\n",(0,r.jsx)(n.p,{children:"^code emit-closure (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Before, the final bytecode for a function declaration was a single ",(0,r.jsx)(n.code,{children:"OP_CONSTANT"}),"\r\ninstruction to load the compiled function from the surrounding function's\r\nconstant table and push it onto the stack. Now we have a new instruction."]}),"\n",(0,r.jsx)(n.p,{children:"^code closure-op (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Like ",(0,r.jsx)(n.code,{children:"OP_CONSTANT"}),", it takes a single operand that represents a constant table\r\nindex for the function. But when we get over to the runtime implementation, we\r\ndo something more interesting."]}),"\n",(0,r.jsx)(n.p,{children:"First, let's be diligent VM hackers and slot in disassembler support for the\r\ninstruction."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-closure (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["There's more going on here than we usually have in the disassembler. By the end\r\nof the chapter, you'll discover that ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"})," is quite an unusual\r\ninstruction. It's straightforward right now -- just a single byte operand -- but\r\nwe'll be adding to it. This code here anticipates that future."]}),"\n",(0,r.jsx)(n.h3,{id:"interpreting-function-declarations",children:"Interpreting function declarations"}),"\n",(0,r.jsx)(n.p,{children:"Most of the work we need to do is in the runtime. We have to handle the new\r\ninstruction, naturally. But we also need to touch every piece of code in the VM\r\nthat works with ObjFunction and change it to use ObjClosure instead -- function\r\ncalls, call frames, etc. We'll start with the instruction, though."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-closure (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Like the ",(0,r.jsx)(n.code,{children:"OP_CONSTANT"})," instruction we used before, first we load the compiled\r\nfunction from the constant table. The difference now is that we wrap that\r\nfunction in a new ObjClosure and push the result onto the stack."]}),"\n",(0,r.jsx)(n.p,{children:"Once you have a closure, you'll eventually want to call it."}),"\n",(0,r.jsx)(n.p,{children:"^code call-value-closure (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We remove the code for calling objects whose type is ",(0,r.jsx)(n.code,{children:"OBJ_FUNCTION"}),". Since we\r\nwrap all functions in ObjClosures, the runtime will never try to invoke a bare\r\nObjFunction anymore. Those objects live only in constant tables and get\r\nimmediately ",(0,r.jsx)(n.span,{name:"naked",children:"wrapped"})," in closures before anything else\r\nsees them."]}),"\n",(0,r.jsxs)(n.aside,{name:"naked",children:["\n",(0,r.jsx)(n.p,{children:"We don't want any naked functions wandering around the VM! What would the\r\nneighbors say?"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We replace the old code with very similar code for calling a closure instead.\r\nThe only difference is the type of object we pass to ",(0,r.jsx)(n.code,{children:"call()"}),". The real changes\r\nare over in that function. First, we update its signature."]}),"\n",(0,r.jsx)(n.p,{children:"^code call-signature (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Then, in the body, we need to fix everything that referenced the function to\r\nhandle the fact that we've introduced a layer of indirection. We start with the\r\narity checking:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-arity (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The only change is that we unwrap the closure to get to the underlying function.\r\nThe next thing ",(0,r.jsx)(n.code,{children:"call()"})," does is create a new CallFrame. We change that code to\r\nstore the closure in the CallFrame and get the bytecode pointer from the\r\nclosure's function."]}),"\n",(0,r.jsx)(n.p,{children:"^code call-init-closure (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"This necessitates changing the declaration of CallFrame too."}),"\n",(0,r.jsx)(n.p,{children:"^code call-frame-closure (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That change triggers a few other cascading changes. Every place in the VM that\r\naccessed CallFrame's function needs to use a closure instead. First, the macro\r\nfor reading a constant from the current function's constant table:"}),"\n",(0,r.jsx)(n.p,{children:"^code read-constant (2 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"DEBUG_TRACE_EXECUTION"})," is enabled, it needs to get to the chunk from the\r\nclosure."]}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-instruction (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Likewise when reporting a runtime error:"}),"\n",(0,r.jsx)(n.p,{children:"^code runtime-error-function (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Almost there. The last piece is the blob of code that sets up the very first\r\nCallFrame to begin executing the top-level code for a Lox script."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"pop",children:"The"})," compiler still returns a raw ObjFunction when\r\ncompiling a script. That's fine, but it means we need to wrap it in an\r\nObjClosure here, before the VM can execute it."]}),"\n",(0,r.jsxs)(n.aside,{name:"pop",children:["\n",(0,r.jsxs)(n.p,{children:["The code looks a little silly because we still push the original ObjFunction\r\nonto the stack. Then we pop it after creating the closure, only to then push the\r\nclosure. Why put the ObjFunction on there at all? As usual, when you see weird\r\nstack stuff going on, it's to keep the ",(0,r.jsx)(n.a,{href:"garbage-collection.html",children:"forthcoming garbage collector"})," aware\r\nof some heap-allocated objects."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We are back to a working interpreter. The ",(0,r.jsx)(n.em,{children:"user"})," can't tell any difference, but\r\nthe compiler now generates code telling the VM to create a closure for each\r\nfunction declaration. Every time the VM executes a function declaration, it\r\nwraps the ObjFunction in a new ObjClosure. The rest of the VM now handles those\r\nObjClosures floating around. That's the boring stuff out of the way. Now we're\r\nready to make these closures actually ",(0,r.jsx)(n.em,{children:"do"})," something."]}),"\n",(0,r.jsx)(n.h2,{id:"upvalues",children:"Upvalues"}),"\n",(0,r.jsx)(n.p,{children:"Our existing instructions for reading and writing local variables are limited to\r\na single function's stack window. Locals from a surrounding function are outside\r\nof the inner function's window. We're going to need some new instructions."}),"\n",(0,r.jsxs)(n.p,{children:["The easiest approach might be an instruction that takes a relative stack slot\r\noffset that can reach ",(0,r.jsx)(n.em,{children:"before"})," the current function's window. That would work if\r\nclosed-over variables were always on the stack. But as we saw earlier, these\r\nvariables sometimes outlive the function where they are declared. That means\r\nthey won't always be on the stack."]}),"\n",(0,r.jsx)(n.p,{children:"The next easiest approach, then, would be to take any local variable that gets\r\nclosed over and have it always live on the heap. When the local variable\r\ndeclaration in the surrounding function is executed, the VM would allocate\r\nmemory for it dynamically. That way it could live as long as needed."}),"\n",(0,r.jsx)(n.p,{children:"This would be a fine approach if clox didn't have a single-pass compiler. But\r\nthat restriction we chose in our implementation makes things harder. Take a look\r\nat this example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun outer() {\r\n  var x = 1;    // (1)\r\n  x = 2;        // (2)\r\n  fun inner() { // (3)\r\n    print x;\r\n  }\r\n  inner();\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the compiler compiles the declaration of ",(0,r.jsx)(n.code,{children:"x"})," at ",(0,r.jsx)(n.code,{children:"(1)"})," and emits code for\r\nthe assignment at ",(0,r.jsx)(n.code,{children:"(2)"}),". It does that before reaching the declaration of\r\n",(0,r.jsx)(n.code,{children:"inner()"})," at ",(0,r.jsx)(n.code,{children:"(3)"})," and discovering that ",(0,r.jsx)(n.code,{children:"x"})," is in fact closed over. We don't\r\nhave an easy way to go back and fix that already-emitted code to treat ",(0,r.jsx)(n.code,{children:"x"}),"\r\nspecially. Instead, we want a solution that allows a closed-over variable to\r\nlive on the stack exactly like a normal local variable ",(0,r.jsx)(n.em,{children:"until the point that it\r\nis closed over"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Fortunately, thanks to the Lua dev team, we have a solution. We use a level of\r\nindirection that they call an ",(0,r.jsx)(n.strong,{children:"upvalue"}),". An upvalue refers to a local variable\r\nin an enclosing function. Every closure maintains an array of upvalues, one for\r\neach surrounding local variable that the closure uses."]}),"\n",(0,r.jsx)(n.p,{children:'The upvalue points back into the stack to where the variable it captured lives.\r\nWhen the closure needs to access a closed-over variable, it goes through the\r\ncorresponding upvalue to reach it. When a function declaration is first executed\r\nand we create a closure for it, the VM creates the array of upvalues and wires\r\nthem up to "capture" the surrounding local variables that the closure needs.'}),"\n",(0,r.jsx)(n.p,{children:"For example, if we throw this program at clox,"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"{\r\n  var a = 3;\r\n  fun f() {\r\n    print a;\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"the compiler and runtime will conspire together to build up a set of objects in\r\nmemory like this:"}),"\n",(0,r.jsx)(n.img,{src:"image/closures/open-upvalue.png",alt:"The object graph of the stack, ObjClosure, ObjFunction, and upvalue array."}),"\n",(0,r.jsx)(n.p,{children:"That might look overwhelming, but fear not. We'll work our way through it. The\r\nimportant part is that upvalues serve as the layer of indirection needed to\r\ncontinue to find a captured local variable even after it moves off the stack.\r\nBut before we get to all that, let's focus on compiling captured variables."}),"\n",(0,r.jsx)(n.h3,{id:"compiling-upvalues",children:"Compiling upvalues"}),"\n",(0,r.jsxs)(n.p,{children:["As usual, we want to do as much work as possible during compilation to keep\r\nexecution simple and fast. Since local variables are lexically scoped in Lox, we\r\nhave enough knowledge at compile time to resolve which surrounding local\r\nvariables a function accesses and where those locals are declared. That, in\r\nturn, means we know ",(0,r.jsx)(n.em,{children:"how many"})," upvalues a closure needs, ",(0,r.jsx)(n.em,{children:"which"})," variables they\r\ncapture, and ",(0,r.jsx)(n.em,{children:"which stack slots"})," contain those variables in the declaring\r\nfunction's stack window."]}),"\n",(0,r.jsx)(n.p,{children:"Currently, when the compiler resolves an identifier, it walks the block scopes\r\nfor the current function from innermost to outermost. If we don't find the\r\nvariable in that function, we assume the variable must be a global. We don't\r\nconsider the local scopes of enclosing functions -- they get skipped right over.\r\nThe first change, then, is inserting a resolution step for those outer local\r\nscopes."}),"\n",(0,r.jsx)(n.p,{children:"^code named-variable-upvalue (3 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This new ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," function looks for a local variable declared in any\r\nof the surrounding functions. If it finds one, it returns an \"upvalue index\" for\r\nthat variable. (We'll get into what that means later.) Otherwise, it returns -1\r\nto indicate the variable wasn't found. If it was found, we use these two new\r\ninstructions for reading or writing to the variable through its upvalue:"]}),"\n",(0,r.jsx)(n.p,{children:"^code upvalue-ops (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We're implementing this sort of top-down, so I'll show you how these work at\r\nruntime soon. The part to focus on now is how the compiler actually resolves the\r\nidentifier."}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-upvalue"}),"\n",(0,r.jsxs)(n.p,{children:["We call this after failing to resolve a local variable in the current function's\r\nscope, so we know the variable isn't in the current compiler. Recall that\r\nCompiler stores a pointer to the Compiler for the enclosing function, and these\r\npointers form a linked chain that goes all the way to the root Compiler for the\r\ntop-level code. Thus, if the enclosing Compiler is ",(0,r.jsx)(n.code,{children:"NULL"}),", we know we've reached\r\nthe outermost function without finding a local variable. The variable must be\r\n",(0,r.jsx)(n.span,{name:"undefined",children:"global"}),", so we return -1."]}),"\n",(0,r.jsxs)(n.aside,{name:"undefined",children:["\n",(0,r.jsx)(n.p,{children:"It might end up being an entirely undefined variable and not even global. But in\r\nLox, we don't detect that error until runtime, so from the compiler's\r\nperspective, it's \"hopefully global\"."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Otherwise, we try to resolve the identifier as a ",(0,r.jsx)(n.em,{children:"local"})," variable in the\r\n",(0,r.jsx)(n.em,{children:"enclosing"})," compiler. In other words, we look for it right outside the current\r\nfunction. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun outer() {\r\n  var x = 1;\r\n  fun inner() {\r\n    print x; // (1)\r\n  }\r\n  inner();\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When compiling the identifier expression at ",(0,r.jsx)(n.code,{children:"(1)"}),", ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," looks for\r\na local variable ",(0,r.jsx)(n.code,{children:"x"})," declared in ",(0,r.jsx)(n.code,{children:"outer()"}),". If found -- like it is in this\r\nexample -- then we've successfully resolved the variable. We create an upvalue\r\nso that the inner function can access the variable through that. The upvalue is\r\ncreated here:"]}),"\n",(0,r.jsx)(n.p,{children:"^code add-upvalue"}),"\n",(0,r.jsx)(n.p,{children:"The compiler keeps an array of upvalue structures to track the closed-over\r\nidentifiers that it has resolved in the body of each function. Remember how the\r\ncompiler's Local array mirrors the stack slot indexes where locals live at\r\nruntime? This new upvalue array works the same way. The indexes in the\r\ncompiler's array match the indexes where upvalues will live in the ObjClosure at\r\nruntime."}),"\n",(0,r.jsxs)(n.p,{children:["This function adds a new upvalue to that array. It also keeps track of the\r\nnumber of upvalues the function uses. It stores that count directly in the\r\nObjFunction itself because we'll also ",(0,r.jsx)(n.span,{name:"bridge",children:"need"})," that\r\nnumber for use at runtime."]}),"\n",(0,r.jsxs)(n.aside,{name:"bridge",children:["\n",(0,r.jsx)(n.p,{children:"Like constants and function arity, the upvalue count is another one of those\r\nlittle pieces of data that form the bridge between the compiler and runtime."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"index"})," field tracks the closed-over local variable's slot index. That way\r\nthe compiler knows ",(0,r.jsx)(n.em,{children:"which"})," variable in the enclosing function needs to be\r\ncaptured. We'll circle back to what that ",(0,r.jsx)(n.code,{children:"isLocal"})," field is for before too long.\r\nFinally, ",(0,r.jsx)(n.code,{children:"addUpvalue()"})," returns the index of the created upvalue in the\r\nfunction's upvalue list. That index becomes the operand to the ",(0,r.jsx)(n.code,{children:"OP_GET_UPVALUE"}),"\r\nand ",(0,r.jsx)(n.code,{children:"OP_SET_UPVALUE"})," instructions."]}),"\n",(0,r.jsx)(n.p,{children:"That's the basic idea for resolving upvalues, but the function isn't fully\r\nbaked. A closure may reference the same variable in a surrounding function\r\nmultiple times. In that case, we don't want to waste time and memory creating a\r\nseparate upvalue for each identifier expression. To fix that, before we add a\r\nnew upvalue, we first check to see if the function already has an upvalue that\r\ncloses over that variable."}),"\n",(0,r.jsx)(n.p,{children:"^code existing-upvalue (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["If we find an upvalue in the array whose slot index matches the one we're\r\nadding, we just return that ",(0,r.jsx)(n.em,{children:"upvalue"})," index and reuse it. Otherwise, we fall\r\nthrough and add the new upvalue."]}),"\n",(0,r.jsx)(n.p,{children:"These two functions access and modify a bunch of new state, so let's define\r\nthat. First, we add the upvalue count to ObjFunction."}),"\n",(0,r.jsx)(n.p,{children:"^code upvalue-count (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We're conscientious C programmers, so we zero-initialize that when an\r\nObjFunction is first allocated."}),"\n",(0,r.jsx)(n.p,{children:"^code init-upvalue-count (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"In the compiler, we add a field for the upvalue array."}),"\n",(0,r.jsx)(n.p,{children:"^code upvalues-array (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["For simplicity, I gave it a fixed size. The ",(0,r.jsx)(n.code,{children:"OP_GET_UPVALUE"})," and\r\n",(0,r.jsx)(n.code,{children:"OP_SET_UPVALUE"})," instructions encode an upvalue index using a single byte\r\noperand, so there's a restriction on how many upvalues a function can have --\r\nhow many unique variables it can close over. Given that, we can afford a static\r\narray that large. We also need to make sure the compiler doesn't overflow that\r\nlimit."]}),"\n",(0,r.jsx)(n.p,{children:"^code too-many-upvalues (5 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Finally, the Upvalue struct type itself."}),"\n",(0,r.jsx)(n.p,{children:"^code upvalue-struct"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"index"})," field stores which local slot the upvalue is capturing. The\r\n",(0,r.jsx)(n.code,{children:"isLocal"})," field deserves its own section, which we'll get to next."]}),"\n",(0,r.jsx)(n.h3,{id:"flattening-upvalues",children:"Flattening upvalues"}),"\n",(0,r.jsxs)(n.p,{children:["In the example I showed before, the closure is accessing a variable declared in\r\nthe immediately enclosing function. Lox also supports accessing local variables\r\ndeclared in ",(0,r.jsx)(n.em,{children:"any"})," enclosing scope, as in:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun outer() {\r\n  var x = 1;\r\n  fun middle() {\r\n    fun inner() {\r\n      print x;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here, we're accessing ",(0,r.jsx)(n.code,{children:"x"})," in ",(0,r.jsx)(n.code,{children:"inner()"}),". That variable is defined not in\r\n",(0,r.jsx)(n.code,{children:"middle()"}),", but all the way out in ",(0,r.jsx)(n.code,{children:"outer()"}),". We need to handle cases like this\r\ntoo. You ",(0,r.jsx)(n.em,{children:"might"})," think that this isn't much harder since the variable will\r\nsimply be somewhere farther down on the stack. But consider this ",(0,r.jsx)(n.span,{name:"devious",children:"devious"})," example:"]}),"\n",(0,r.jsxs)(n.aside,{name:"devious",children:["\n",(0,r.jsx)(n.p,{children:"If you work on programming languages long enough, you will develop a\r\nfinely honed skill at creating bizarre programs like this that are technically\r\nvalid but likely to trip up an implementation written by someone with a less\r\nperverse imagination than you."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun outer() {\r\n  var x = "value";\r\n  fun middle() {\r\n    fun inner() {\r\n      print x;\r\n    }\r\n\r\n    print "create inner closure";\r\n    return inner;\r\n  }\r\n\r\n  print "return from outer";\r\n  return middle;\r\n}\r\n\r\nvar mid = outer();\r\nvar in = mid();\r\nin();\n'})}),"\n",(0,r.jsx)(n.p,{children:"When you run this, it should print:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"return from outer\r\ncreate inner closure\r\nvalue\n"})}),"\n",(0,r.jsxs)(n.p,{children:["I know, it's convoluted. The important part is that ",(0,r.jsx)(n.code,{children:"outer()"})," -- where ",(0,r.jsx)(n.code,{children:"x"})," is\r\ndeclared -- returns and pops all of its variables off the stack before the\r\n",(0,r.jsx)(n.em,{children:"declaration"})," of ",(0,r.jsx)(n.code,{children:"inner()"})," executes. So, at the point in time that we create the\r\nclosure for ",(0,r.jsx)(n.code,{children:"inner()"}),", ",(0,r.jsx)(n.code,{children:"x"})," is already off the stack."]}),"\n",(0,r.jsx)(n.p,{children:"Here, I traced out the execution flow for you:"}),"\n",(0,r.jsx)(n.img,{src:"image/closures/execution-flow.png",alt:"Tracing through the previous example program."}),"\n",(0,r.jsxs)(n.p,{children:["See how ",(0,r.jsx)(n.code,{children:"x"})," is popped \u2460 before it is captured \u2461 and then later\r\naccessed \u2462? We really have two problems:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"We need to resolve local variables that are declared in surrounding\r\nfunctions beyond the immediately enclosing one."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"We need to be able to capture variables that have already left the stack."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Fortunately, we're in the middle of adding upvalues to the VM, and upvalues are\r\nexplicitly designed for tracking variables that have escaped the stack. So, in a\r\nclever bit of self-reference, we can use upvalues to allow upvalues to capture\r\nvariables declared outside of the immediately surrounding function."}),"\n",(0,r.jsxs)(n.p,{children:["The solution is to allow a closure to capture either a local variable or ",(0,r.jsx)(n.em,{children:"an\r\nexisting upvalue"})," in the immediately enclosing function. If a deeply nested\r\nfunction references a local variable declared several hops away, we'll thread it\r\nthrough all of the intermediate functions by having each function capture an\r\nupvalue for the next function to grab."]}),"\n",(0,r.jsx)(n.img,{src:"image/closures/linked-upvalues.png",alt:"An upvalue in inner() points to an upvalue in middle(), which points to a local variable in outer()."}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, ",(0,r.jsx)(n.code,{children:"middle()"})," captures the local variable ",(0,r.jsx)(n.code,{children:"x"})," in the\r\nimmediately enclosing function ",(0,r.jsx)(n.code,{children:"outer()"})," and stores it in its own upvalue. It\r\ndoes this even though ",(0,r.jsx)(n.code,{children:"middle()"})," itself doesn't reference ",(0,r.jsx)(n.code,{children:"x"}),". Then, when the\r\ndeclaration of ",(0,r.jsx)(n.code,{children:"inner()"})," executes, its closure grabs the ",(0,r.jsx)(n.em,{children:"upvalue"})," from the\r\nObjClosure for ",(0,r.jsx)(n.code,{children:"middle()"})," that captured ",(0,r.jsx)(n.code,{children:"x"}),". A function captures -- either a\r\nlocal or upvalue -- ",(0,r.jsx)(n.em,{children:"only"})," from the immediately surrounding function, which is\r\nguaranteed to still be around at the point that the inner function declaration\r\nexecutes."]}),"\n",(0,r.jsxs)(n.p,{children:["In order to implement this, ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," becomes recursive."]}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-upvalue-recurse (4 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["It's only another three lines of code, but I found this function really\r\nchallenging to get right the first time. This in spite of the fact that I wasn't\r\ninventing anything new, just porting the concept over from Lua. Most recursive\r\nfunctions either do all their work before the recursive call (a ",(0,r.jsx)(n.strong,{children:"pre-order\r\ntraversal"}),', or "on the way down"), or they do all the work after the recursive\r\ncall (a ',(0,r.jsx)(n.strong,{children:"post-order traversal"}),', or "on the way back up"). This function does\r\nboth. The recursive call is right in the middle.']}),"\n",(0,r.jsxs)(n.p,{children:["We'll walk through it slowly. First, we look for a matching local variable in\r\nthe enclosing function. If we find one, we capture that local and return. That's\r\nthe ",(0,r.jsx)(n.span,{name:"base",children:"base"})," case."]}),"\n",(0,r.jsxs)(n.aside,{name:"base",children:["\n",(0,r.jsx)(n.p,{children:"The other base case, of course, is if there is no enclosing function. In that\r\ncase, the variable can't be resolved lexically and is treated as global."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Otherwise, we look for a local variable beyond the immediately enclosing\r\nfunction. We do that by recursively calling ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," on the\r\n",(0,r.jsx)(n.em,{children:"enclosing"})," compiler, not the current one. This series of ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"}),"\r\ncalls works its way along the chain of nested compilers until it hits one of\r\nthe base cases -- either it finds an actual local variable to capture or it\r\nruns out of compilers."]}),"\n",(0,r.jsxs)(n.p,{children:["When a local variable is found, the most deeply ",(0,r.jsx)(n.span,{name:"outer",children:"nested"}),"\r\ncall to ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," captures it and returns the upvalue index. That\r\nreturns to the next call for the inner function declaration. That call captures\r\nthe ",(0,r.jsx)(n.em,{children:"upvalue"})," from the surrounding function, and so on. As each nested call to\r\n",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," returns, we drill back down into the innermost function\r\ndeclaration where the identifier we are resolving appears. At each step along\r\nthe way, we add an upvalue to the intervening function and pass the resulting\r\nupvalue index down to the next call."]}),"\n",(0,r.jsxs)(n.aside,{name:"outer",children:["\n",(0,r.jsxs)(n.p,{children:["Each recursive call to ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," walks ",(0,r.jsx)(n.em,{children:"out"})," one level of function\r\nnesting. So an inner ",(0,r.jsx)(n.em,{children:"recursive call"})," refers to an ",(0,r.jsx)(n.em,{children:"outer"})," nested declaration.\r\nThe innermost recursive call to ",(0,r.jsx)(n.code,{children:"resolveUpvalue()"})," that finds the local variable\r\nwill be for the ",(0,r.jsx)(n.em,{children:"outermost"})," function, just inside the enclosing function where\r\nthat variable is actually declared."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["It might help to walk through the original example when resolving ",(0,r.jsx)(n.code,{children:"x"}),":"]}),"\n",(0,r.jsx)(n.img,{src:"image/closures/recursion.png",alt:"Tracing through a recursive call to resolveUpvalue()."}),"\n",(0,r.jsxs)(n.p,{children:["Note that the new call to ",(0,r.jsx)(n.code,{children:"addUpvalue()"})," passes ",(0,r.jsx)(n.code,{children:"false"})," for the ",(0,r.jsx)(n.code,{children:"isLocal"}),"\r\nparameter. Now you see that that flag controls whether the closure captures a\r\nlocal variable or an upvalue from the surrounding function."]}),"\n",(0,r.jsx)(n.p,{children:"By the time the compiler reaches the end of a function declaration, every\r\nvariable reference has been resolved as either a local, an upvalue, or a global.\r\nEach upvalue may in turn capture a local variable from the surrounding function,\r\nor an upvalue in the case of transitive closures. We finally have enough data to\r\nemit bytecode which creates a closure at runtime that captures all of the\r\ncorrect variables."}),"\n",(0,r.jsx)(n.p,{children:"^code capture-upvalues (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"})," instruction is unique in that it has a variably sized encoding.\r\nFor each upvalue the closure captures, there are two single-byte operands. Each\r\npair of operands specifies what that upvalue captures. If the first byte is one,\r\nit captures a local variable in the enclosing function. If zero, it captures one\r\nof the function's upvalues. The next byte is the local slot or upvalue index to\r\ncapture."]}),"\n",(0,r.jsxs)(n.p,{children:["This odd encoding means we need some bespoke support in the disassembly code\r\nfor ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-upvalues (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"For example, take this script:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun outer() {\r\n  var a = 1;\r\n  var b = 2;\r\n  fun middle() {\r\n    var c = 3;\r\n    var d = 4;\r\n    fun inner() {\r\n      print a + c + b + d;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If we disassemble the instruction that creates the closure for ",(0,r.jsx)(n.code,{children:"inner()"}),", it\r\nprints this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"0004    9 OP_CLOSURE          2 <fn inner>\r\n0006      |                     upvalue 0\r\n0008      |                     local 1\r\n0010      |                     upvalue 1\r\n0012      |                     local 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"We have two other, simpler instructions to add disassembler support for."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-upvalue-ops (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["These both have a single-byte operand, so there's nothing exciting going on. We\r\ndo need to add an include so the debug module can get to ",(0,r.jsx)(n.code,{children:"AS_FUNCTION()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code debug-include-object (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["With that, our compiler is where we want it. For each function declaration, it\r\noutputs an ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"})," instruction followed by a series of operand byte pairs\r\nfor each upvalue it needs to capture at runtime. It's time to hop over to that\r\nside of the VM and get things running."]}),"\n",(0,r.jsx)(n.h2,{id:"upvalue-objects",children:"Upvalue Objects"}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"})," instruction is now followed by the series of bytes that\r\nspecify the upvalues the ObjClosure should own. Before we process those\r\noperands, we need a runtime representation for upvalues."]}),"\n",(0,r.jsx)(n.p,{children:"^code obj-upvalue"}),"\n",(0,r.jsxs)(n.p,{children:["We know upvalues must manage closed-over variables that no longer live on the\r\nstack, which implies some amount of dynamic allocation. The easiest way to do\r\nthat in our VM is by building on the object system we already have. That way,\r\nwhen we implement a garbage collector in ",(0,r.jsx)(n.a,{href:"garbage-collection.html",children:"the next chapter"}),", the GC can\r\nmanage memory for upvalues too."]}),"\n",(0,r.jsxs)(n.p,{children:["Thus, our runtime upvalue structure is an ObjUpvalue with the typical Obj header\r\nfield. Following that is a ",(0,r.jsx)(n.code,{children:"location"})," field that points to the closed-over\r\nvariable. Note that this is a ",(0,r.jsx)(n.em,{children:"pointer"})," to a Value, not a Value itself. It's a\r\nreference to a ",(0,r.jsx)(n.em,{children:"variable"}),", not a ",(0,r.jsx)(n.em,{children:"value"}),". This is important because it means\r\nthat when we assign to the variable the upvalue captures, we're assigning to the\r\nactual variable, not a copy. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun outer() {\r\n  var x = "before";\r\n  fun inner() {\r\n    x = "assigned";\r\n  }\r\n  inner();\r\n  print x;\r\n}\r\nouter();\n'})}),"\n",(0,r.jsxs)(n.p,{children:['This program should print "assigned" even though the closure assigns to ',(0,r.jsx)(n.code,{children:"x"})," and\r\nthe surrounding function accesses it."]}),"\n",(0,r.jsx)(n.p,{children:"Because upvalues are objects, we've got all the usual object machinery, starting\r\nwith a constructor-like function:"}),"\n",(0,r.jsx)(n.p,{children:"^code new-upvalue-h (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"It takes the address of the slot where the closed-over variable lives. Here is\r\nthe implementation:"}),"\n",(0,r.jsx)(n.p,{children:"^code new-upvalue"}),"\n",(0,r.jsx)(n.p,{children:"We simply initialize the object and store the pointer. That requires a new\r\nobject type."}),"\n",(0,r.jsx)(n.p,{children:"^code obj-type-upvalue (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And on the back side, a destructor-like function:"}),"\n",(0,r.jsx)(n.p,{children:"^code free-upvalue (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Multiple closures can close over the same variable, so ObjUpvalue does not own\r\nthe variable it references. Thus, the only thing to free is the ObjUpvalue\r\nitself."}),"\n",(0,r.jsx)(n.p,{children:"And, finally, to print:"}),"\n",(0,r.jsx)(n.p,{children:"^code print-upvalue (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Printing isn't useful to end users. Upvalues are objects only so that we can\r\ntake advantage of the VM's memory management. They aren't first-class values\r\nthat a Lox user can directly access in a program. So this code will never\r\nactually execute... but it keeps the compiler from yelling at us about an\r\nunhandled switch case, so here we are."}),"\n",(0,r.jsx)(n.h3,{id:"upvalues-in-closures",children:"Upvalues in closures"}),"\n",(0,r.jsx)(n.p,{children:"When I first introduced upvalues, I said each closure has an array of them.\r\nWe've finally worked our way back to implementing that."}),"\n",(0,r.jsx)(n.p,{children:"^code upvalue-fields (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"count",children:"Different"})," closures may have different numbers of\r\nupvalues, so we need a dynamic array. The upvalues themselves are dynamically\r\nallocated too, so we end up with a double pointer -- a pointer to a dynamically\r\nallocated array of pointers to upvalues. We also store the number of elements in\r\nthe array."]}),"\n",(0,r.jsxs)(n.aside,{name:"count",children:["\n",(0,r.jsx)(n.p,{children:"Storing the upvalue count in the closure is redundant because the ObjFunction\r\nthat the ObjClosure references also keeps that count. As usual, this weird code\r\nis to appease the GC. The collector may need to know an ObjClosure's upvalue\r\narray size after the closure's corresponding ObjFunction has already been freed."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When we create an ObjClosure, we allocate an upvalue array of the proper size,\r\nwhich we determined at compile time and stored in the ObjFunction."}),"\n",(0,r.jsx)(n.p,{children:"^code allocate-upvalue-array (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Before creating the closure object itself, we allocate the array of upvalues and\r\ninitialize them all to ",(0,r.jsx)(n.code,{children:"NULL"}),". This weird ceremony around memory is a careful\r\ndance to please the (forthcoming) garbage collection deities. It ensures the\r\nmemory manager never sees uninitialized memory."]}),"\n",(0,r.jsx)(n.p,{children:"Then we store the array in the new closure, as well as copy the count over from\r\nthe ObjFunction."}),"\n",(0,r.jsx)(n.p,{children:"^code init-upvalue-fields (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"When we free an ObjClosure, we also free the upvalue array."}),"\n",(0,r.jsx)(n.p,{children:"^code free-upvalues (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["ObjClosure does not own the ObjUpvalue objects themselves, but it does own ",(0,r.jsx)(n.em,{children:"the\r\narray"})," containing pointers to those upvalues."]}),"\n",(0,r.jsxs)(n.p,{children:["We fill the upvalue array over in the interpreter when it creates a closure.\r\nThis is where we walk through all of the operands after ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"})," to see what\r\nkind of upvalue each slot captures."]}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-capture-upvalues (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This code is the magic moment when a closure comes to life. We iterate over each\r\nupvalue the closure expects. For each one, we read a pair of operand bytes. If\r\nthe upvalue closes over a local variable in the enclosing function, we let\r\n",(0,r.jsx)(n.code,{children:"captureUpvalue()"})," do the work."]}),"\n",(0,r.jsxs)(n.p,{children:["Otherwise, we capture an upvalue from the surrounding function. An ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"}),"\r\ninstruction is emitted at the end of a function declaration. At the moment that\r\nwe are executing that declaration, the ",(0,r.jsx)(n.em,{children:"current"})," function is the surrounding\r\none. That means the current function's closure is stored in the CallFrame at the\r\ntop of the callstack. So, to grab an upvalue from the enclosing function, we can\r\nread it right from the ",(0,r.jsx)(n.code,{children:"frame"})," local variable, which caches a reference to that\r\nCallFrame."]}),"\n",(0,r.jsxs)(n.p,{children:["Closing over a local variable is more interesting. Most of the work happens in a\r\nseparate function, but first we calculate the argument to pass to it. We need to\r\ngrab a pointer to the captured local's slot in the surrounding function's stack\r\nwindow. That window begins at ",(0,r.jsx)(n.code,{children:"frame->slots"}),", which points to slot zero. Adding\r\n",(0,r.jsx)(n.code,{children:"index"})," offsets that to the local slot we want to capture. We pass that pointer\r\nhere:"]}),"\n",(0,r.jsx)(n.p,{children:"^code capture-upvalue"}),"\n",(0,r.jsxs)(n.p,{children:["This seems a little silly. All it does is create a new ObjUpvalue that captures\r\nthe given stack slot and returns it. Did we need a separate function for this?\r\nWell, no, not ",(0,r.jsx)(n.em,{children:"yet"}),". But you know we are going to end up sticking more code in\r\nhere."]}),"\n",(0,r.jsxs)(n.p,{children:["First, let's wrap up what we're working on. Back in the interpreter code for\r\nhandling ",(0,r.jsx)(n.code,{children:"OP_CLOSURE"}),", we eventually finish iterating through the upvalue\r\narray and initialize each one. When that completes, we have a new closure with\r\nan array full of upvalues pointing to variables."]}),"\n",(0,r.jsx)(n.p,{children:"With that in hand, we can implement the instructions that work with those\r\nupvalues."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-get-upvalue (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The operand is the index into the current function's upvalue array. So we simply\r\nlook up the corresponding upvalue and dereference its location pointer to read\r\nthe value in that slot. Setting a variable is similar."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-set-upvalue (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We ",(0,r.jsx)(n.span,{name:"assign",children:"take"})," the value on top of the stack and store it\r\ninto the slot pointed to by the chosen upvalue. Just as with the instructions\r\nfor local variables, it's important that these instructions are fast. User\r\nprograms are constantly reading and writing variables, so if that's slow,\r\neverything is slow. And, as usual, the way we make them fast is by keeping them\r\nsimple. These two new instructions are pretty good: no control flow, no complex\r\narithmetic, just a couple of pointer indirections and a ",(0,r.jsx)(n.code,{children:"push()"}),"."]}),"\n",(0,r.jsxs)(n.aside,{name:"assign",children:["\n",(0,r.jsxs)(n.p,{children:["The set instruction doesn't ",(0,r.jsx)(n.em,{children:"pop"})," the value from the stack because, remember,\r\nassignment is an expression in Lox. So the result of the assignment -- the\r\nassigned value -- needs to remain on the stack for the surrounding expression."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This is a milestone. As long as all of the variables remain on the stack, we\r\nhave working closures. Try this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun outer() {\r\n  var x = "outside";\r\n  fun inner() {\r\n    print x;\r\n  }\r\n  inner();\r\n}\r\nouter();\n'})}),"\n",(0,r.jsx)(n.p,{children:'Run this, and it correctly prints "outside".'}),"\n",(0,r.jsx)(n.h2,{id:"closed-upvalues",children:"Closed Upvalues"}),"\n",(0,r.jsxs)(n.p,{children:["Of course, a key feature of closures is that they hold on to the variable as\r\nlong as needed, even after the function that declares the variable has returned.\r\nHere's another example that ",(0,r.jsx)(n.em,{children:"should"})," work:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun outer() {\r\n  var x = "outside";\r\n  fun inner() {\r\n    print x;\r\n  }\r\n\r\n  return inner;\r\n}\r\n\r\nvar closure = outer();\r\nclosure();\n'})}),"\n",(0,r.jsx)(n.p,{children:"But if you run it right now... who knows what it does? At runtime, it will end\r\nup reading from a stack slot that no longer contains the closed-over variable.\r\nLike I've mentioned a few times, the crux of the issue is that variables in\r\nclosures don't have stack semantics. That means we've got to hoist them off the\r\nstack when the function where they were declared returns. This final section of\r\nthe chapter does that."}),"\n",(0,r.jsx)(n.h3,{id:"values-and-variables",children:"Values and variables"}),"\n",(0,r.jsxs)(n.p,{children:["Before we get to writing code, I want to dig into an important semantic point.\r\nDoes a closure close over a ",(0,r.jsx)(n.em,{children:"value"})," or a ",(0,r.jsx)(n.em,{children:"variable?"})," This isn't purely an ",(0,r.jsx)(n.span,{name:"academic",children:"academic"})," question. I'm not just splitting hairs.\r\nConsider:"]}),"\n",(0,r.jsxs)(n.aside,{name:"academic",children:["\n",(0,r.jsxs)(n.p,{children:["If Lox didn't allow assignment, it ",(0,r.jsx)(n.em,{children:"would"})," be an academic question."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var globalSet;\r\nvar globalGet;\r\n\r\nfun main() {\r\n  var a = "initial";\r\n\r\n  fun set() { a = "updated"; }\r\n  fun get() { print a; }\r\n\r\n  globalSet = set;\r\n  globalGet = get;\r\n}\r\n\r\nmain();\r\nglobalSet();\r\nglobalGet();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The outer ",(0,r.jsx)(n.code,{children:"main()"})," function creates two closures and stores them in ",(0,r.jsx)(n.span,{name:"global",children:"global"})," variables so that they outlive the execution of\r\n",(0,r.jsx)(n.code,{children:"main()"})," itself. Both of those closures capture the same variable. The first\r\nclosure assigns a new value to it and the second closure reads the variable."]}),"\n",(0,r.jsxs)(n.aside,{name:"global",children:["\n",(0,r.jsx)(n.p,{children:"The fact that I'm using a couple of global variables isn't significant. I needed\r\nsome way to return two values from a function, and without any kind of\r\ncollection type in Lox, my options were limited."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["What does the call to ",(0,r.jsx)(n.code,{children:"globalGet()"})," print? If closures capture ",(0,r.jsx)(n.em,{children:"values"})," then\r\neach closure gets its own copy of ",(0,r.jsx)(n.code,{children:"a"})," with the value that ",(0,r.jsx)(n.code,{children:"a"})," had at the point\r\nin time that the closure's function declaration executed. The call to\r\n",(0,r.jsx)(n.code,{children:"globalSet()"})," will modify ",(0,r.jsx)(n.code,{children:"set()"}),"'s copy of ",(0,r.jsx)(n.code,{children:"a"}),", but ",(0,r.jsx)(n.code,{children:"get()"}),"'s copy will be\r\nunaffected. Thus, the call to ",(0,r.jsx)(n.code,{children:"globalGet()"}),' will print "initial".']}),"\n",(0,r.jsxs)(n.p,{children:["If closures close over variables, then ",(0,r.jsx)(n.code,{children:"get()"})," and ",(0,r.jsx)(n.code,{children:"set()"})," will both capture --\r\nreference -- the ",(0,r.jsx)(n.em,{children:"same mutable variable"}),". When ",(0,r.jsx)(n.code,{children:"set()"})," changes ",(0,r.jsx)(n.code,{children:"a"}),", it changes\r\nthe same ",(0,r.jsx)(n.code,{children:"a"})," that ",(0,r.jsx)(n.code,{children:"get()"})," reads from. There is only one ",(0,r.jsx)(n.code,{children:"a"}),". That, in turn,\r\nimplies the call to ",(0,r.jsx)(n.code,{children:"globalGet()"}),' will print "updated".']}),"\n",(0,r.jsxs)(n.p,{children:["Which is it? The answer for Lox and most other languages I know with closures is\r\nthe latter. Closures capture variables. You can think of them as capturing ",(0,r.jsx)(n.em,{children:"the\r\nplace the value lives"}),". This is important to keep in mind as we deal with\r\nclosed-over variables that are no longer on the stack. When a variable moves to\r\nthe heap, we need to ensure that all closures capturing that variable retain a\r\nreference to its ",(0,r.jsx)(n.em,{children:"one"})," new location. That way, when the variable is mutated, all\r\nclosures see the change."]}),"\n",(0,r.jsx)(n.h3,{id:"closing-upvalues",children:"Closing upvalues"}),"\n",(0,r.jsx)(n.p,{children:"We know that local variables always start out on the stack. This is faster, and\r\nlets our single-pass compiler emit code before it discovers the variable has\r\nbeen captured. We also know that closed-over variables need to move to the heap\r\nif the closure outlives the function where the captured variable is declared."}),"\n",(0,r.jsxs)(n.p,{children:["Following Lua, we'll use ",(0,r.jsx)(n.strong,{children:"open upvalue"})," to refer to an upvalue that points to\r\na local variable still on the stack. When a variable moves to the heap, we are\r\n",(0,r.jsx)(n.em,{children:"closing"})," the upvalue and the result is, naturally, a ",(0,r.jsx)(n.strong,{children:"closed upvalue"}),". The\r\ntwo questions we need to answer are:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Where on the heap does the closed-over variable go?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"When do we close the upvalue?"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The answer to the first question is easy. We already have a convenient object on\r\nthe heap that represents a reference to a variable -- ObjUpvalue itself. The\r\nclosed-over variable will move into a new field right inside the ObjUpvalue\r\nstruct. That way we don't need to do any additional heap allocation to close an\r\nupvalue."}),"\n",(0,r.jsxs)(n.p,{children:["The second question is straightforward too. As long as the variable is on the\r\nstack, there may be code that refers to it there, and that code must work\r\ncorrectly. So the logical time to hoist the variable to the heap is as late as\r\npossible. If we move the local variable right when it goes out of scope, we are\r\ncertain that no code after that point will try to access it from the stack.\r\n",(0,r.jsx)(n.span,{name:"after",children:"After"})," the variable is out of scope, the compiler will\r\nhave reported an error if any code tried to use it."]}),"\n",(0,r.jsxs)(n.aside,{name:"after",children:["\n",(0,r.jsxs)(n.p,{children:['By "after" here, I mean in the lexical or textual sense -- code past the ',(0,r.jsx)(n.code,{children:"}"}),"\r\nfor the block containing the declaration of the closed-over variable."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The compiler already emits an ",(0,r.jsx)(n.code,{children:"OP_POP"})," instruction when a local variable goes\r\nout of scope. If a variable is captured by a closure, we will instead emit a\r\ndifferent instruction to hoist that variable out of the stack and into its\r\ncorresponding upvalue. To do that, the compiler needs to know which ",(0,r.jsx)(n.span,{name:"param",children:"locals"})," are closed over."]}),"\n",(0,r.jsxs)(n.aside,{name:"param",children:["\n",(0,r.jsx)(n.p,{children:"The compiler doesn't pop parameters and locals declared immediately inside the\r\nbody of a function. We'll handle those too, in the runtime."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:['The compiler already maintains an array of Upvalue structs for each local\r\nvariable in the function to track exactly that state. That array is good for\r\nanswering "Which variables does this closure use?" But it\'s poorly suited for\r\nanswering, "Does ',(0,r.jsx)(n.em,{children:"any"}),' function capture this local variable?" In particular,\r\nonce the Compiler for some closure has finished, the Compiler for the enclosing\r\nfunction whose variable has been captured no longer has access to any of the\r\nupvalue state.']}),"\n",(0,r.jsx)(n.p,{children:"In other words, the compiler maintains pointers from upvalues to the locals they\r\ncapture, but not in the other direction. So we first need to add some extra\r\ntracking inside the existing Local struct so that we can tell if a given local\r\nis captured by a closure."}),"\n",(0,r.jsx)(n.p,{children:"^code is-captured-field (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This field is ",(0,r.jsx)(n.code,{children:"true"})," if the local is captured by any later nested function\r\ndeclaration. Initially, all locals are not captured."]}),"\n",(0,r.jsx)(n.p,{children:"^code init-is-captured (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"zero",children:"Likewise"}),', the special "slot zero local" that the\r\ncompiler implicitly declares is not captured.']}),"\n",(0,r.jsxs)(n.aside,{name:"zero",children:["\n",(0,r.jsxs)(n.p,{children:["Later in the book, it ",(0,r.jsx)(n.em,{children:"will"})," become possible for a user to capture this\r\nvariable. Just building some anticipation here."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code init-zero-local-is-captured (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"When resolving an identifier, if we end up creating an upvalue for a local\r\nvariable, we mark it as captured."}),"\n",(0,r.jsx)(n.p,{children:"^code mark-local-captured (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Now, at the end of a block scope when the compiler emits code to free the stack\r\nslots for the locals, we can tell which ones need to get hoisted onto the heap.\r\nWe'll use a new instruction for that."}),"\n",(0,r.jsx)(n.p,{children:"^code end-scope (3 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"The instruction requires no operand. We know that the variable will always be\r\nright on top of the stack at the point that this instruction executes. We\r\ndeclare the instruction."}),"\n",(0,r.jsx)(n.p,{children:"^code close-upvalue-op (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And add trivial disassembler support for it:"}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-close-upvalue (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Excellent. Now the generated bytecode tells the runtime exactly when each\r\ncaptured local variable must move to the heap. Better, it does so only for the\r\nlocals that ",(0,r.jsx)(n.em,{children:"are"})," used by a closure and need this special treatment. This aligns\r\nwith our general performance goal that we want users to pay only for\r\nfunctionality that they use. Variables that aren't used by closures live and die\r\nentirely on the stack just as they did before."]}),"\n",(0,r.jsx)(n.h3,{id:"tracking-open-upvalues",children:"Tracking open upvalues"}),"\n",(0,r.jsxs)(n.p,{children:["Let's move over to the runtime side. Before we can interpret ",(0,r.jsx)(n.code,{children:"OP_CLOSE_UPVALUE"}),"\r\ninstructions, we have an issue to resolve. Earlier, when I talked about whether\r\nclosures capture variables or values, I said it was important that if multiple\r\nclosures access the same variable that they end up with a reference to the\r\nexact same storage location in memory. That way if one closure writes to the\r\nvariable, the other closure sees the change."]}),"\n",(0,r.jsxs)(n.p,{children:["Right now, if two closures capture the same ",(0,r.jsx)(n.span,{name:"indirect",children:"local"}),"\r\nvariable, the VM creates a separate Upvalue for each one. The necessary sharing\r\nis missing. When we move the variable off the stack, if we move it into only one\r\nof the upvalues, the other upvalue will have an orphaned value."]}),"\n",(0,r.jsxs)(n.aside,{name:"indirect",children:["\n",(0,r.jsxs)(n.p,{children:["The VM ",(0,r.jsx)(n.em,{children:"does"})," share upvalues if one closure captures an ",(0,r.jsx)(n.em,{children:"upvalue"})," from a\r\nsurrounding function. The nested case works correctly. But if two ",(0,r.jsx)(n.em,{children:"sibling"}),"\r\nclosures capture the same local variable, they each create a separate\r\nObjUpvalue."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"To fix that, whenever the VM needs an upvalue that captures a particular local\r\nvariable slot, we will first search for an existing upvalue pointing to that\r\nslot. If found, we reuse that. The challenge is that all of the previously\r\ncreated upvalues are squirreled away inside the upvalue arrays of the various\r\nclosures. Those closures could be anywhere in the VM's memory."}),"\n",(0,r.jsxs)(n.p,{children:["The first step is to give the VM its own list of all open upvalues that point to\r\nvariables still on the stack. Searching a list each time the VM needs an upvalue\r\nsounds like it might be slow, but in practice, it's not bad. The number of\r\nvariables on the stack that actually get closed over tends to be small. And\r\nfunction declarations that ",(0,r.jsx)(n.span,{name:"create",children:"create"})," closures are rarely\r\non performance critical execution paths in the user's program."]}),"\n",(0,r.jsxs)(n.aside,{name:"create",children:["\n",(0,r.jsxs)(n.p,{children:["Closures are frequently ",(0,r.jsx)(n.em,{children:"invoked"})," inside hot loops. Think about the closures\r\npassed to typical higher-order functions on collections like ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Map_(higher-order_function)",children:(0,r.jsx)(n.code,{children:"map()"})})," and\r\n",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Filter_(higher-order_function)",children:(0,r.jsx)(n.code,{children:"filter()"})}),". That should be fast. But the function declaration that\r\n",(0,r.jsx)(n.em,{children:"creates"})," the closure happens only once and is usually outside of the loop."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Even better, we can order the list of open upvalues by the stack slot index they\r\npoint to. The common case is that a slot has ",(0,r.jsx)(n.em,{children:"not"})," already been captured --\r\nsharing variables between closures is uncommon -- and closures tend to capture\r\nlocals near the top of the stack. If we store the open upvalue array in stack\r\nslot order, as soon as we step past the slot where the local we're capturing\r\nlives, we know it won't be found. When that local is near the top of the stack,\r\nwe can exit the loop pretty early."]}),"\n",(0,r.jsx)(n.p,{children:"Maintaining a sorted list requires inserting elements in the middle efficiently.\r\nThat suggests using a linked list instead of a dynamic array. Since we defined\r\nthe ObjUpvalue struct ourselves, the easiest implementation is an intrusive list\r\nthat puts the next pointer right inside the ObjUpvalue struct itself."}),"\n",(0,r.jsx)(n.p,{children:"^code next-field (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["When we allocate an upvalue, it is not attached to any list yet so the link is\r\n",(0,r.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code init-next (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The VM owns the list, so the head pointer goes right inside the main VM struct."}),"\n",(0,r.jsx)(n.p,{children:"^code open-upvalues-field (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The list starts out empty."}),"\n",(0,r.jsx)(n.p,{children:"^code init-open-upvalues (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Starting with the first upvalue pointed to by the VM, each open upvalue points\r\nto the next open upvalue that references a local variable farther down the\r\nstack. This script, for example,"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"{\r\n  var a = 1;\r\n  fun f() {\r\n    print a;\r\n  }\r\n  var b = 2;\r\n  fun g() {\r\n    print b;\r\n  }\r\n  var c = 3;\r\n  fun h() {\r\n    print c;\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"should produce a series of linked upvalues like so:"}),"\n",(0,r.jsx)(n.img,{src:"image/closures/linked-list.png",alt:"Three upvalues in a linked list."}),"\n",(0,r.jsx)(n.p,{children:"Whenever we close over a local variable, before creating a new upvalue, we look\r\nfor an existing one in the list."}),"\n",(0,r.jsx)(n.p,{children:"^code look-for-existing-upvalue (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We start at the ",(0,r.jsx)(n.span,{name:"head",children:"head"})," of the list, which is the upvalue\r\nclosest to the top of the stack. We walk through the list, using a little\r\npointer comparison to iterate past every upvalue pointing to slots above the one\r\nwe're looking for. While we do that, we keep track of the preceding upvalue on\r\nthe list. We'll need to update that node's ",(0,r.jsx)(n.code,{children:"next"})," pointer if we end up inserting\r\na node after it."]}),"\n",(0,r.jsxs)(n.aside,{name:"head",children:["\n",(0,r.jsx)(n.p,{children:"It's a singly linked list. It's not like we have any other choice than to start\r\nat the head and go forward from there."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"There are three reasons we can exit the loop:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["The local slot we stopped at ",(0,r.jsx)(n.em,{children:"is"})," the slot we're looking for."]})," We found\r\nan existing upvalue capturing the variable, so we reuse that upvalue."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"We ran out of upvalues to search."})," When ",(0,r.jsx)(n.code,{children:"upvalue"})," is ",(0,r.jsx)(n.code,{children:"NULL"}),", it means\r\nevery open upvalue in the list points to locals above the slot we're looking\r\nfor, or (more likely) the upvalue list is empty. Either way, we didn't find\r\nan upvalue for our slot."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["We found an upvalue whose local slot is ",(0,r.jsx)(n.em,{children:"below"})," the one we're looking\r\nfor."]})," Since the list is sorted, that means we've gone past the slot we are\r\nclosing over, and thus there must not be an existing upvalue for it."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In the first case, we're done and we've returned. Otherwise, we create a new\r\nupvalue for our local slot and insert it into the list at the right location."}),"\n",(0,r.jsx)(n.p,{children:"^code insert-upvalue-in-list (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The current incarnation of this function already creates the upvalue, so we only\r\nneed to add code to insert the upvalue into the list. We exited the list\r\ntraversal by either going past the end of the list, or by stopping on the first\r\nupvalue whose stack slot is below the one we're looking for. In either case,\r\nthat means we need to insert the new upvalue ",(0,r.jsx)(n.em,{children:"before"})," the object pointed at by\r\n",(0,r.jsx)(n.code,{children:"upvalue"})," (which may be ",(0,r.jsx)(n.code,{children:"NULL"})," if we hit the end of the list)."]}),"\n",(0,r.jsxs)(n.p,{children:["As you may have learned in Data Structures 101, to insert a node into a linked\r\nlist, you set the ",(0,r.jsx)(n.code,{children:"next"})," pointer of the previous node to point to your new one.\r\nWe have been conveniently keeping track of that preceding node as we walked the\r\nlist. We also need to handle the ",(0,r.jsx)(n.span,{name:"double",children:"special"}),' case where\r\nwe are inserting a new upvalue at the head of the list, in which case the "next"\r\npointer is the VM\'s head pointer.']}),"\n",(0,r.jsxs)(n.aside,{name:"double",children:["\n",(0,r.jsxs)(n.p,{children:["There is a shorter implementation that handles updating either the head pointer\r\nor the previous upvalue's ",(0,r.jsx)(n.code,{children:"next"})," pointer uniformly by using a pointer to a\r\npointer, but that kind of code confuses almost everyone who hasn't reached some\r\nZen master level of pointer expertise. I went with the basic ",(0,r.jsx)(n.code,{children:"if"})," statement\r\napproach."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"With this updated function, the VM now ensures that there is only ever a single\r\nObjUpvalue for any given local slot. If two closures capture the same variable,\r\nthey will get the same upvalue. We're ready to move those upvalues off the\r\nstack now."}),"\n",(0,r.jsx)(n.h3,{id:"closing-upvalues-at-runtime",children:"Closing upvalues at runtime"}),"\n",(0,r.jsxs)(n.p,{children:["The compiler helpfully emits an ",(0,r.jsx)(n.code,{children:"OP_CLOSE_UPVALUE"})," instruction to tell the VM\r\nexactly when a local variable should be hoisted onto the heap. Executing that\r\ninstruction is the interpreter's responsibility."]}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-close-upvalue (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["When we reach the instruction, the variable we are hoisting is right on top of\r\nthe stack. We call a helper function, passing the address of that stack slot.\r\nThat function is responsible for closing the upvalue and moving the local from\r\nthe stack to the heap. After that, the VM is free to discard the stack slot,\r\nwhich it does by calling ",(0,r.jsx)(n.code,{children:"pop()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The fun stuff happens here:"}),"\n",(0,r.jsx)(n.p,{children:"^code close-upvalues"}),"\n",(0,r.jsx)(n.p,{children:'This function takes a pointer to a stack slot. It closes every open upvalue it\r\ncan find that points to that slot or any slot above it on the stack. Right now,\r\nwe pass a pointer only to the top slot on the stack, so the "or above it" part\r\ndoesn\'t come into play, but it will soon.'}),"\n",(0,r.jsx)(n.p,{children:"To do this, we walk the VM's list of open upvalues, again from top to bottom. If\r\nan upvalue's location points into the range of slots we're closing, we close the\r\nupvalue. Otherwise, once we reach an upvalue outside of the range, we know the\r\nrest will be too, so we stop iterating."}),"\n",(0,r.jsxs)(n.p,{children:["The way an upvalue gets closed is pretty ",(0,r.jsx)(n.span,{name:"cool",children:"cool"}),". First,\r\nwe copy the variable's value into the ",(0,r.jsx)(n.code,{children:"closed"})," field in the ObjUpvalue. That's\r\nwhere closed-over variables live on the heap. The ",(0,r.jsx)(n.code,{children:"OP_GET_UPVALUE"})," and\r\n",(0,r.jsx)(n.code,{children:"OP_SET_UPVALUE"})," instructions need to look for the variable there after it's\r\nbeen moved. We could add some conditional logic in the interpreter code for\r\nthose instructions to check some flag for whether the upvalue is open or closed."]}),"\n",(0,r.jsxs)(n.p,{children:["But there is already a level of indirection in play -- those instructions\r\ndereference the ",(0,r.jsx)(n.code,{children:"location"})," pointer to get to the variable's value. When the\r\nvariable moves from the stack to the ",(0,r.jsx)(n.code,{children:"closed"})," field, we simply update that\r\n",(0,r.jsx)(n.code,{children:"location"})," to the address of the ObjUpvalue's ",(0,r.jsx)(n.em,{children:"own"})," ",(0,r.jsx)(n.code,{children:"closed"})," field."]}),"\n",(0,r.jsxs)(n.aside,{name:"cool",children:["\n",(0,r.jsx)(n.p,{children:"I'm not praising myself here. This is all the Lua dev team's innovation."}),"\n"]}),"\n",(0,r.jsx)(n.img,{src:"image/closures/closing.png",alt:"Moving a value from the stack to the upvalue's 'closed' field and then pointing the 'value' field to it."}),"\n",(0,r.jsxs)(n.p,{children:["We don't need to change how ",(0,r.jsx)(n.code,{children:"OP_GET_UPVALUE"})," and ",(0,r.jsx)(n.code,{children:"OP_SET_UPVALUE"})," are\r\ninterpreted at all. That keeps them simple, which in turn keeps them fast. We do\r\nneed to add the new field to ObjUpvalue, though."]}),"\n",(0,r.jsx)(n.p,{children:"^code closed-field (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And we should zero it out when we create an ObjUpvalue so there's no\r\nuninitialized memory floating around."}),"\n",(0,r.jsx)(n.p,{children:"^code init-closed (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Whenever the compiler reaches the end of a block, it discards all local\r\nvariables in that block and emits an ",(0,r.jsx)(n.code,{children:"OP_CLOSE_UPVALUE"})," for each local variable\r\nthat was closed over. The compiler ",(0,r.jsx)(n.span,{name:"close",children:"does"})," ",(0,r.jsx)(n.em,{children:"not"})," emit any\r\ninstructions at the end of the outermost block scope that defines a function\r\nbody. That scope contains the function's parameters and any locals declared\r\nimmediately inside the function. Those need to get closed too."]}),"\n",(0,r.jsxs)(n.aside,{name:"close",children:["\n",(0,r.jsxs)(n.p,{children:["There's nothing ",(0,r.jsx)(n.em,{children:"preventing"})," us from closing the outermost function scope in the\r\ncompiler and emitting ",(0,r.jsx)(n.code,{children:"OP_POP"})," and ",(0,r.jsx)(n.code,{children:"OP_CLOSE_UPVALUE"})," instructions. Doing so is\r\njust unnecessary because the runtime discards all of the stack slots used by the\r\nfunction implicitly when it pops the call frame."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This is the reason ",(0,r.jsx)(n.code,{children:"closeUpvalues()"})," accepts a pointer to a stack slot. When a\r\nfunction returns, we call that same helper and pass in the first stack slot\r\nowned by the function."]}),"\n",(0,r.jsx)(n.p,{children:"^code return-close-upvalues (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"By passing the first slot in the function's stack window, we close every\r\nremaining open upvalue owned by the returning function. And with that, we now\r\nhave a fully functioning closure implementation. Closed-over variables live as\r\nlong as they are needed by the functions that capture them."}),"\n",(0,r.jsx)(n.p,{children:"This was a lot of work! In jlox, closures fell out naturally from our\r\nenvironment representation. In clox, we had to add a lot of code -- new bytecode\r\ninstructions, more data structures in the compiler, and new runtime objects. The\r\nVM very much treats variables in closures as different from other variables."}),"\n",(0,r.jsxs)(n.p,{children:['There is a rationale for that. In terms of implementation complexity, jlox gave\r\nus closures "for free". But in terms of ',(0,r.jsx)(n.em,{children:"performance"}),", jlox's closures are\r\nanything but. By allocating ",(0,r.jsx)(n.em,{children:"all"})," environments on the heap, jlox pays a\r\nsignificant performance price for ",(0,r.jsx)(n.em,{children:"all"})," local variables, even the majority which\r\nare never captured by closures."]}),"\n",(0,r.jsx)(n.p,{children:"With clox, we have a more complex system, but that allows us to tailor the\r\nimplementation to fit the two use patterns we observe for local variables. For\r\nmost variables which do have stack semantics, we allocate them entirely on the\r\nstack which is simple and fast. Then, for the few local variables where that\r\ndoesn't work, we have a second slower path we can opt in to as needed."}),"\n",(0,r.jsxs)(n.p,{children:["Fortunately, users don't perceive the complexity. From their perspective, local\r\nvariables in Lox are simple and uniform. The ",(0,r.jsx)(n.em,{children:"language itself"})," is as simple as\r\njlox's implementation. But under the hood, clox is watching what the user does\r\nand optimizing for their specific uses. As your language implementations grow in\r\nsophistication, you'll find yourself doing this more. A large fraction of\r\n\"optimization\" is about adding special case code that detects certain uses and\r\nprovides a custom-built, faster path for code that fits that pattern."]}),"\n",(0,r.jsxs)(n.p,{children:["We have lexical scoping fully working in clox now, which is a major milestone.\r\nAnd, now that we have functions and variables with complex lifetimes, we also\r\nhave a ",(0,r.jsx)(n.em,{children:"lot"})," of objects floating around in clox's heap, with a web of pointers\r\nstringing them together. The ",(0,r.jsx)(n.a,{href:"garbage-collection.html",children:"next step"})," is figuring out how to manage that\r\nmemory so that we can free some of those objects when they're no longer needed."]}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Wrapping every ObjFunction in an ObjClosure introduces a level of\r\nindirection that has a performance cost. That cost isn't necessary for\r\nfunctions that do not close over any variables, but it does let the runtime\r\ntreat all calls uniformly."}),"\n",(0,r.jsx)(n.p,{children:"Change clox to only wrap functions in ObjClosures that need upvalues. How\r\ndoes the code complexity and performance compare to always wrapping\r\nfunctions? Take care to benchmark programs that do and do not use closures.\r\nHow should you weight the importance of each benchmark? If one gets slower\r\nand one faster, how do you decide what trade-off to make to choose an\r\nimplementation strategy?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Read the design note below. I'll wait. Now, how do you think Lox ",(0,r.jsx)(n.em,{children:"should"}),"\r\nbehave? Change the implementation to create a new variable for each loop\r\niteration."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.a,{href:"http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent",children:"famous koan"}),' teaches us that "objects are a poor man\'s closure"\r\n(and vice versa). Our VM doesn\'t support objects yet, but now that we have\r\nclosures we can approximate them. Using closures, write a Lox program that\r\nmodels two-dimensional vector "objects". It should:']}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:['Define a "constructor" function to create a new vector with the given\r\n',(0,r.jsx)(n.em,{children:"x"})," and ",(0,r.jsx)(n.em,{children:"y"})," coordinates."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:['Provide "methods" to access the ',(0,r.jsx)(n.em,{children:"x"})," and ",(0,r.jsx)(n.em,{children:"y"})," coordinates of values\r\nreturned from that constructor."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'Define an addition "method" that adds two vectors and produces a third.'}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.div,{className:"design-note",children:["\n",(0,r.jsx)(n.h2,{id:"design-note-closing-over-the-loop-variable",children:"Design Note: Closing Over the Loop Variable"}),"\n",(0,r.jsxs)(n.p,{children:["Closures capture variables. When two closures capture the same variable, they\r\nshare a reference to the same underlying storage location. This fact is visible\r\nwhen new values are assigned to the variable. Obviously, if two closures capture\r\n",(0,r.jsx)(n.em,{children:"different"})," variables, there is no sharing."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var globalOne;\r\nvar globalTwo;\r\n\r\nfun main() {\r\n  {\r\n    var a = "one";\r\n    fun one() {\r\n      print a;\r\n    }\r\n    globalOne = one;\r\n  }\r\n\r\n  {\r\n    var a = "two";\r\n    fun two() {\r\n      print a;\r\n    }\r\n    globalTwo = two;\r\n  }\r\n}\r\n\r\nmain();\r\nglobalOne();\r\nglobalTwo();\n'})}),"\n",(0,r.jsxs)(n.p,{children:['This prints "one" then "two". In this example, it\'s pretty clear that the two\r\n',(0,r.jsx)(n.code,{children:"a"})," variables are different. But it's not always so obvious. Consider:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"var globalOne;\r\nvar globalTwo;\r\n\r\nfun main() {\r\n  for (var a = 1; a <= 2; a = a + 1) {\r\n    fun closure() {\r\n      print a;\r\n    }\r\n    if (globalOne == nil) {\r\n      globalOne = closure;\r\n    } else {\r\n      globalTwo = closure;\r\n    }\r\n  }\r\n}\r\n\r\nmain();\r\nglobalOne();\r\nglobalTwo();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The code is convoluted because Lox has no collection types. The important part\r\nis that the ",(0,r.jsx)(n.code,{children:"main()"})," function does two iterations of a ",(0,r.jsx)(n.code,{children:"for"})," loop. Each time\r\nthrough the loop, it creates a closure that captures the loop variable. It\r\nstores the first closure in ",(0,r.jsx)(n.code,{children:"globalOne"})," and the second in ",(0,r.jsx)(n.code,{children:"globalTwo"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["There are definitely two different closures. Do they close over two different\r\nvariables? Is there only one ",(0,r.jsx)(n.code,{children:"a"})," for the entire duration of the loop, or does\r\neach iteration get its own distinct ",(0,r.jsx)(n.code,{children:"a"})," variable?"]}),"\n",(0,r.jsx)(n.p,{children:"The script here is strange and contrived, but this does show up in real code\r\nin languages that aren't as minimal as clox. Here's a JavaScript example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var closures = [];\r\nfor (var i = 1; i <= 2; i++) {\r\n  closures.push(function () { console.log(i); });\r\n}\r\n\r\nclosures[0]();\r\nclosures[1]();\n"})}),"\n",(0,r.jsxs)(n.p,{children:['Does this print "1" then "2", or does it print ',(0,r.jsx)(n.span,{name:"three",children:'"3"'}),'\r\ntwice? You may be surprised to hear that it prints "3" twice. In this JavaScript\r\nprogram, there is only a single ',(0,r.jsx)(n.code,{children:"i"})," variable whose lifetime includes all\r\niterations of the loop, including the final exit."]}),"\n",(0,r.jsxs)(n.aside,{name:"three",children:["\n",(0,r.jsxs)(n.p,{children:["You're wondering how ",(0,r.jsx)(n.em,{children:"three"})," enters the picture? After the second iteration,\r\n",(0,r.jsx)(n.code,{children:"i++"})," is executed, which increments ",(0,r.jsx)(n.code,{children:"i"})," to three. That's what causes ",(0,r.jsx)(n.code,{children:"i <= 2"})," to\r\nevaluate to false and end the loop. If ",(0,r.jsx)(n.code,{children:"i"})," never reached three, the loop would\r\nrun forever."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If you're familiar with JavaScript, you probably know that variables declared\r\nusing ",(0,r.jsx)(n.code,{children:"var"})," are implicitly ",(0,r.jsx)(n.em,{children:"hoisted"})," to the surrounding function or top-level\r\nscope. It's as if you really wrote this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var closures = [];\r\nvar i;\r\nfor (i = 1; i <= 2; i++) {\r\n  closures.push(function () { console.log(i); });\r\n}\r\n\r\nclosures[0]();\r\nclosures[1]();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["At that point, it's clearer that there is only a single ",(0,r.jsx)(n.code,{children:"i"}),". Now consider if\r\nyou change the program to use the newer ",(0,r.jsx)(n.code,{children:"let"})," keyword:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var closures = [];\r\nfor (let i = 1; i <= 2; i++) {\r\n  closures.push(function () { console.log(i); });\r\n}\r\n\r\nclosures[0]();\r\nclosures[1]();\n"})}),"\n",(0,r.jsxs)(n.p,{children:['Does this new program behave the same? Nope. In this case, it prints "1" then\r\n"2". Each closure gets its own ',(0,r.jsx)(n.code,{children:"i"}),". That's sort of strange when you think about\r\nit. The increment clause is ",(0,r.jsx)(n.code,{children:"i++"}),". That looks very much like it is assigning to\r\nand mutating an existing variable, not creating a new one."]}),"\n",(0,r.jsx)(n.p,{children:"Let's try some other languages. Here's Python:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"closures = []\r\nfor i in range(1, 3):\r\n  closures.append(lambda: print(i))\r\n\r\nclosures[0]()\r\nclosures[1]()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Python doesn't really have block scope. Variables are implicitly declared and\r\nare automatically scoped to the surrounding function. Kind of like hoisting in\r\nJS, now that I think about it. So both closures capture the same variable.\r\nUnlike C, though, we don't exit the loop by incrementing ",(0,r.jsx)(n.code,{children:"i"})," ",(0,r.jsx)(n.em,{children:"past"}),' the last\r\nvalue, so this prints "2" twice.']}),"\n",(0,r.jsx)(n.p,{children:"What about Ruby? Ruby has two typical ways to iterate numerically. Here's the\r\nclassic imperative style:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"closures = []\r\nfor i in 1..2 do\r\n  closures << lambda { puts i }\r\nend\r\n\r\nclosures[0].call\r\nclosures[1].call\n"})}),"\n",(0,r.jsxs)(n.p,{children:['This, like Python, prints "2" twice. But the more idiomatic Ruby style is using\r\na higher-order ',(0,r.jsx)(n.code,{children:"each()"})," method on range objects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"closures = []\r\n(1..2).each do |i|\r\n  closures << lambda { puts i }\r\nend\r\n\r\nclosures[0].call\r\nclosures[1].call\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you're not familiar with Ruby, the ",(0,r.jsx)(n.code,{children:"do |i| ... end"})," part is basically a\r\nclosure that gets created and passed to the ",(0,r.jsx)(n.code,{children:"each()"})," method. The ",(0,r.jsx)(n.code,{children:"|i|"})," is the\r\nparameter signature for the closure. The ",(0,r.jsx)(n.code,{children:"each()"})," method invokes that closure\r\ntwice, passing in 1 for ",(0,r.jsx)(n.code,{children:"i"})," the first time and 2 the second time."]}),"\n",(0,r.jsx)(n.p,{children:'In this case, the "loop variable" is really a function parameter. And, since\r\neach iteration of the loop is a separate invocation of the function, those are\r\ndefinitely separate variables for each call. So this prints "1" then "2".'}),"\n",(0,r.jsxs)(n.p,{children:["If a language has a higher-level iterator-based looping structure like ",(0,r.jsx)(n.code,{children:"foreach"}),'\r\nin C#, Java\'s "enhanced for", ',(0,r.jsx)(n.code,{children:"for-of"})," in JavaScript, ",(0,r.jsx)(n.code,{children:"for-in"})," in Dart, etc.,\r\nthen I think it's natural to the reader to have each iteration create a new\r\nvariable. The code ",(0,r.jsx)(n.em,{children:"looks"})," like a new variable because the loop header looks\r\nlike a variable declaration. And there's no increment expression that looks like\r\nit's mutating that variable to advance to the next step."]}),"\n",(0,r.jsxs)(n.p,{children:["If you dig around StackOverflow and other places, you find evidence that this is\r\nwhat users expect, because they are very surprised when they ",(0,r.jsx)(n.em,{children:"don't"})," get it. In\r\nparticular, C# originally did ",(0,r.jsx)(n.em,{children:"not"})," create a new loop variable for each\r\niteration of a ",(0,r.jsx)(n.code,{children:"foreach"})," loop. This was such a frequent source of user confusion\r\nthat they took the very rare step of shipping a breaking change to the language.\r\nIn C# 5, each iteration creates a fresh variable."]}),"\n",(0,r.jsxs)(n.p,{children:["Old C-style ",(0,r.jsx)(n.code,{children:"for"})," loops are harder. The increment clause really does look like\r\nmutation. That implies there is a single variable that's getting updated each\r\nstep. But it's almost never ",(0,r.jsx)(n.em,{children:"useful"})," for each iteration to share a loop\r\nvariable. The only time you can even detect this is when closures capture it.\r\nAnd it's rarely helpful to have a closure that references a variable whose value\r\nis whatever value caused you to exit the loop."]}),"\n",(0,r.jsxs)(n.p,{children:["The pragmatically useful answer is probably to do what JavaScript does with\r\n",(0,r.jsx)(n.code,{children:"let"})," in ",(0,r.jsx)(n.code,{children:"for"})," loops. Make it look like mutation but actually create a new\r\nvariable each time, because that's what users want. It is kind of weird when you\r\nthink about it, though."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const a={},s=r.createContext(a);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);