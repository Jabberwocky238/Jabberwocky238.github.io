"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[8984],{8126:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=n(4848),a=n(8453);const s={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/appendix-i",title:"appendix-i",description:"Here is a complete grammar for Lox. The chapters that introduce each part of the",source:"@site/docs/Craftinginterpreters/not-translated-yet/appendix-i.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/appendix-i",permalink:"/docs/Craftinginterpreters/not-translated-yet/appendix-i",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/appendix-i.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"acknowledgements",permalink:"/docs/Craftinginterpreters/not-translated-yet/acknowledgements"},next:{title:"appendix-ii",permalink:"/docs/Craftinginterpreters/not-translated-yet/appendix-ii"}},l={},c=[{value:"Syntax Grammar",id:"syntax-grammar",level:2},{value:"Declarations",id:"declarations",level:3},{value:"Statements",id:"statements",level:3},{value:"Expressions",id:"expressions",level:3},{value:"Utility rules",id:"utility-rules",level:3},{value:"Lexical Grammar",id:"lexical-grammar",level:2}];function d(e){const r={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"Here is a complete grammar for Lox. The chapters that introduce each part of the\r\nlanguage include the grammar rules there, but this collects them all into one\r\nplace."}),"\n",(0,t.jsx)(r.h2,{id:"syntax-grammar",children:"Syntax Grammar"}),"\n",(0,t.jsx)(r.p,{children:"The syntactic grammar is used to parse the linear sequence of tokens into the\r\nnested syntax tree structure. It starts with the first rule that matches an\r\nentire Lox program (or a single REPL entry)."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ebnf",children:"program        \u2192 declaration* EOF ;\n"})}),"\n",(0,t.jsx)(r.h3,{id:"declarations",children:"Declarations"}),"\n",(0,t.jsx)(r.p,{children:"A program is a series of declarations, which are the statements that bind new\r\nidentifiers or any of the other statement types."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ebnf",children:'declaration    \u2192 classDecl\r\n               | funDecl\r\n               | varDecl\r\n               | statement ;\r\n\r\nclassDecl      \u2192 "class" IDENTIFIER ( "<" IDENTIFIER )?\r\n                 "{" function* "}" ;\r\nfunDecl        \u2192 "fun" function ;\r\nvarDecl        \u2192 "var" IDENTIFIER ( "=" expression )? ";" ;\n'})}),"\n",(0,t.jsx)(r.h3,{id:"statements",children:"Statements"}),"\n",(0,t.jsx)(r.p,{children:"The remaining statement rules produce side effects, but do not introduce\r\nbindings."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ebnf",children:'statement      \u2192 exprStmt\r\n               | forStmt\r\n               | ifStmt\r\n               | printStmt\r\n               | returnStmt\r\n               | whileStmt\r\n               | block ;\r\n\r\nexprStmt       \u2192 expression ";" ;\r\nforStmt        \u2192 "for" "(" ( varDecl | exprStmt | ";" )\r\n                           expression? ";"\r\n                           expression? ")" statement ;\r\nifStmt         \u2192 "if" "(" expression ")" statement\r\n                 ( "else" statement )? ;\r\nprintStmt      \u2192 "print" expression ";" ;\r\nreturnStmt     \u2192 "return" expression? ";" ;\r\nwhileStmt      \u2192 "while" "(" expression ")" statement ;\r\nblock          \u2192 "{" declaration* "}" ;\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Note that ",(0,t.jsx)(r.code,{children:"block"})," is a statement rule, but is also used as a nonterminal in a\r\ncouple of other rules for things like function bodies."]}),"\n",(0,t.jsx)(r.h3,{id:"expressions",children:"Expressions"}),"\n",(0,t.jsx)(r.p,{children:"Expressions produce values. Lox has a number of unary and binary operators with\r\ndifferent levels of precedence. Some grammars for languages do not directly\r\nencode the precedence relationships and specify that elsewhere. Here, we use a\r\nseparate rule for each precedence level to make it explicit."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ebnf",children:'expression     \u2192 assignment ;\r\n\r\nassignment     \u2192 ( call "." )? IDENTIFIER "=" assignment\r\n               | logic_or ;\r\n\r\nlogic_or       \u2192 logic_and ( "or" logic_and )* ;\r\nlogic_and      \u2192 equality ( "and" equality )* ;\r\nequality       \u2192 comparison ( ( "!=" | "==" ) comparison )* ;\r\ncomparison     \u2192 term ( ( ">" | ">=" | "<" | "<=" ) term )* ;\r\nterm           \u2192 factor ( ( "-" | "+" ) factor )* ;\r\nfactor         \u2192 unary ( ( "/" | "*" ) unary )* ;\r\n\r\nunary          \u2192 ( "!" | "-" ) unary | call ;\r\ncall           \u2192 primary ( "(" arguments? ")" | "." IDENTIFIER )* ;\r\nprimary        \u2192 "true" | "false" | "nil" | "this"\r\n               | NUMBER | STRING | IDENTIFIER | "(" expression ")"\r\n               | "super" "." IDENTIFIER ;\n'})}),"\n",(0,t.jsx)(r.h3,{id:"utility-rules",children:"Utility rules"}),"\n",(0,t.jsx)(r.p,{children:"In order to keep the above rules a little cleaner, some of the grammar is\r\nsplit out into a few reused helper rules."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ebnf",children:'function       \u2192 IDENTIFIER "(" parameters? ")" block ;\r\nparameters     \u2192 IDENTIFIER ( "," IDENTIFIER )* ;\r\narguments      \u2192 expression ( "," expression )* ;\n'})}),"\n",(0,t.jsx)(r.h2,{id:"lexical-grammar",children:"Lexical Grammar"}),"\n",(0,t.jsxs)(r.p,{children:["The lexical grammar is used by the scanner to group characters into tokens.\r\nWhere the syntax is ",(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Context-free_grammar",children:"context free"}),", the lexical grammar is ",(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Regular_grammar",children:"regular"})," -- note\r\nthat there are no recursive rules."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ebnf",children:'NUMBER         \u2192 DIGIT+ ( "." DIGIT+ )? ;\r\nSTRING         \u2192 "\\"" <any char except "\\"">* "\\"" ;\r\nIDENTIFIER     \u2192 ALPHA ( ALPHA | DIGIT )* ;\r\nALPHA          \u2192 "a" ... "z" | "A" ... "Z" | "_" ;\r\nDIGIT          \u2192 "0" ... "9" ;\n'})})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var t=n(6540);const a={},s=t.createContext(a);function i(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);