"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[6272],{2620:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var t=s(4848),r=s(8453);const a={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/superclasses",title:"superclasses",description:"You can choose your friends but you sho' can't choose your family, an' they're",source:"@site/docs/Craftinginterpreters/not-translated-yet/superclasses.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/superclasses",permalink:"/docs/Craftinginterpreters/not-translated-yet/superclasses",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/superclasses.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"strings",permalink:"/docs/Craftinginterpreters/not-translated-yet/strings"},next:{title:"the-lox-language",permalink:"/docs/Craftinginterpreters/not-translated-yet/the-lox-language"}},l={},h=[{value:"Inheriting Methods",id:"inheriting-methods",level:2},{value:"Executing inheritance",id:"executing-inheritance",level:3},{value:"Invalid superclasses",id:"invalid-superclasses",level:3},{value:"Storing Superclasses",id:"storing-superclasses",level:2},{value:"A superclass local variable",id:"a-superclass-local-variable",level:3},{value:"Super Calls",id:"super-calls",level:2},{value:"Executing super accesses",id:"executing-super-accesses",level:3},{value:"Faster super calls",id:"faster-super-calls",level:3},{value:"A Complete Virtual Machine",id:"a-complete-virtual-machine",level:2},{value:"Challenges",id:"challenges",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"You can choose your friends but you sho' can't choose your family, an' they're\r\nstill kin to you no matter whether you acknowledge \u2019em or not, and it\r\nmakes you look right silly when you don't."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.cite,{children:["Harper Lee, ",(0,t.jsx)(n.em,{children:"To Kill a Mockingbird"})]})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This is the very last chapter where we add new functionality to our VM. We've\r\npacked almost the entire Lox language in there already. All that remains is\r\ninheriting methods and calling superclass methods. We have ",(0,t.jsx)(n.a,{href:"optimization.html",children:"another\r\nchapter"})," after this one, but it introduces no new behavior. It\r\n",(0,t.jsx)(n.span,{name:"faster",children:"only"})," makes existing stuff faster. Make it to the end\r\nof this one, and you'll have a complete Lox implementation."]}),"\n",(0,t.jsxs)(n.aside,{name:"faster",children:["\n",(0,t.jsxs)(n.p,{children:['That "only" should not imply that making stuff faster isn\'t important! After\r\nall, the whole purpose of our entire second virtual machine is better\r\nperformance over jlox. You could argue that ',(0,t.jsx)(n.em,{children:"all"}),' of the past fifteen chapters\r\nare "optimization".']}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Some of the material in this chapter will remind you of jlox. The way we resolve\r\nsuper calls is pretty much the same, though viewed through clox's more complex\r\nmechanism for storing state on the stack. But we have an entirely different,\r\nmuch faster, way of handling inherited method calls this time around."}),"\n",(0,t.jsx)(n.h2,{id:"inheriting-methods",children:"Inheriting Methods"}),"\n",(0,t.jsx)(n.p,{children:"We'll kick things off with method inheritance since it's the simpler piece. To\r\nrefresh your memory, Lox inheritance syntax looks like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:'class Doughnut {\r\n  cook() {\r\n    print "Dunk in the fryer.";\r\n  }\r\n}\r\n\r\nclass Cruller < Doughnut {\r\n  finish() {\r\n    print "Glaze with icing.";\r\n  }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here, the Cruller class inherits from Doughnut and thus, instances of Cruller\r\ninherit the ",(0,t.jsx)(n.code,{children:"cook()"})," method. I don't know why I'm belaboring this. You know how\r\ninheritance works. Let's start compiling the new syntax."]}),"\n",(0,t.jsx)(n.p,{children:"^code compile-superclass (2 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["After we compile the class name, if the next token is a ",(0,t.jsx)(n.code,{children:"<"}),", then we found a\r\nsuperclass clause. We consume the superclass's identifier token, then call\r\n",(0,t.jsx)(n.code,{children:"variable()"}),". That function takes the previously consumed token, treats it as a\r\nvariable reference, and emits code to load the variable's value. In other words,\r\nit looks up the superclass by name and pushes it onto the stack."]}),"\n",(0,t.jsxs)(n.p,{children:["After that, we call ",(0,t.jsx)(n.code,{children:"namedVariable()"})," to load the subclass doing the inheriting\r\nonto the stack, followed by an ",(0,t.jsx)(n.code,{children:"OP_INHERIT"})," instruction. That instruction\r\nwires up the superclass to the new subclass. In the last chapter, we defined an\r\n",(0,t.jsx)(n.code,{children:"OP_METHOD"})," instruction to mutate an existing class object by adding a method to\r\nits method table. This is similar -- the ",(0,t.jsx)(n.code,{children:"OP_INHERIT"})," instruction takes an\r\nexisting class and applies the effect of inheritance to it."]}),"\n",(0,t.jsx)(n.p,{children:"In the previous example, when the compiler works through this bit of syntax:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:"class Cruller < Doughnut {\n"})}),"\n",(0,t.jsx)(n.p,{children:"The result is this bytecode:"}),"\n",(0,t.jsx)(n.img,{src:"image/superclasses/inherit-stack.png",alt:"The series of bytecode instructions for a Cruller class inheriting from Doughnut."}),"\n",(0,t.jsxs)(n.p,{children:["Before we implement the new ",(0,t.jsx)(n.code,{children:"OP_INHERIT"})," instruction, we have an edge case to\r\ndetect."]}),"\n",(0,t.jsx)(n.p,{children:"^code inherit-self (1 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.span,{name:"cycle",children:"A"})," class cannot be its own superclass. Unless you have\r\naccess to a deranged nuclear physicist and a very heavily modified DeLorean, you\r\ncannot inherit from yourself."]}),"\n",(0,t.jsxs)(n.aside,{name:"cycle",children:["\n",(0,t.jsxs)(n.p,{children:["Interestingly, with the way we implement method inheritance, I don't think\r\nallowing cycles would actually cause any problems in clox. It wouldn't do\r\nanything ",(0,t.jsx)(n.em,{children:"useful"}),", but I don't think it would cause a crash or infinite loop."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"executing-inheritance",children:"Executing inheritance"}),"\n",(0,t.jsx)(n.p,{children:"Now onto the new instruction."}),"\n",(0,t.jsx)(n.p,{children:"^code inherit-op (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"There are no operands to worry about. The two values we need -- superclass and\r\nsubclass -- are both found on the stack. That means disassembling is easy."}),"\n",(0,t.jsx)(n.p,{children:"^code disassemble-inherit (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"The interpreter is where the action happens."}),"\n",(0,t.jsx)(n.p,{children:"^code interpret-inherit (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"From the top of the stack down, we have the subclass then the superclass. We\r\ngrab both of those and then do the inherit-y bit. This is where clox takes a\r\ndifferent path than jlox. In our first interpreter, each subclass stored a\r\nreference to its superclass. On method access, if we didn't find the method in\r\nthe subclass's method table, we recursed through the inheritance chain looking\r\nat each ancestor's method table until we found it."}),"\n",(0,t.jsxs)(n.p,{children:["For example, calling ",(0,t.jsx)(n.code,{children:"cook()"})," on an instance of Cruller sends jlox on this\r\njourney:"]}),"\n",(0,t.jsx)(n.img,{src:"image/superclasses/jlox-resolve.png",alt:"Resolving a call to cook() in an instance of Cruller means walking the superclass chain."}),"\n",(0,t.jsxs)(n.p,{children:["That's a lot of work to perform during method ",(0,t.jsx)(n.em,{children:"invocation"})," time. It's slow, and\r\nworse, the farther an inherited method is up the ancestor chain, the slower it\r\ngets. Not a great performance story."]}),"\n",(0,t.jsxs)(n.p,{children:["The new approach is much faster. When the subclass is declared, we copy all of\r\nthe inherited class's methods down into the subclass's own method table. Later,\r\nwhen ",(0,t.jsx)(n.em,{children:"calling"})," a method, any method inherited from a superclass will be found\r\nright in the subclass's own method table. There is no extra runtime work needed\r\nfor inheritance at all. By the time the class is declared, the work is done.\r\nThis means inherited method calls are exactly as fast as normal method calls --\r\na ",(0,t.jsx)(n.span,{name:"two",children:"single"})," hash table lookup."]}),"\n",(0,t.jsx)(n.img,{src:"image/superclasses/clox-resolve.png",alt:"Resolving a call to cook() in an instance of Cruller which has the method in its own method table."}),"\n",(0,t.jsxs)(n.aside,{name:"two",children:["\n",(0,t.jsx)(n.p,{children:"Well, two hash table lookups, I guess. Because first we have to make sure a\r\nfield on the instance doesn't shadow the method."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["I've sometimes heard this technique called \"copy-down inheritance\". It's simple\r\nand fast, but, like most optimizations, you get to use it only under certain\r\nconstraints. It works in Lox because Lox classes are ",(0,t.jsx)(n.em,{children:"closed"}),". Once a class\r\ndeclaration is finished executing, the set of methods for that class can never\r\nchange."]}),"\n",(0,t.jsxs)(n.p,{children:["In languages like Ruby, Python, and JavaScript, it's possible to ",(0,t.jsx)(n.span,{name:"monkey",children:"crack"})," open an existing class and jam some new methods into\r\nit or even remove them. That would break our optimization because if those\r\nmodifications happened to a superclass ",(0,t.jsx)(n.em,{children:"after"})," the subclass declaration\r\nexecuted, the subclass would not pick up those changes. That breaks a user's\r\nexpectation that inheritance always reflects the current state of the\r\nsuperclass."]}),"\n",(0,t.jsxs)(n.aside,{name:"monkey",children:["\n",(0,t.jsx)(n.p,{children:"As you can imagine, changing the set of methods a class defines imperatively at\r\nruntime can make it hard to reason about a program. It is a very powerful tool,\r\nbut also a dangerous tool."}),"\n",(0,t.jsxs)(n.p,{children:["Those who find this tool maybe a little ",(0,t.jsx)(n.em,{children:"too"}),' dangerous gave it the unbecoming\r\nname "monkey patching", or the even less decorous "duck punching".']}),"\n",(0,t.jsx)(n.img,{src:"image/superclasses/monkey.png",alt:"A monkey with an eyepatch, naturally."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Fortunately for us (but not for users who like the feature, I guess), Lox\r\ndoesn't let you patch monkeys or punch ducks, so we can safely apply this\r\noptimization."}),"\n",(0,t.jsxs)(n.p,{children:["What about method overrides? Won't copying the superclass's methods into the\r\nsubclass's method table clash with the subclass's own methods? Fortunately, no.\r\nWe emit the ",(0,t.jsx)(n.code,{children:"OP_INHERIT"})," after the ",(0,t.jsx)(n.code,{children:"OP_CLASS"})," instruction that creates the\r\nsubclass but before any method declarations and ",(0,t.jsx)(n.code,{children:"OP_METHOD"})," instructions have\r\nbeen compiled. At the point that we copy the superclass's methods down, the\r\nsubclass's method table is empty. Any methods the subclass overrides will\r\noverwrite those inherited entries in the table."]}),"\n",(0,t.jsx)(n.h3,{id:"invalid-superclasses",children:"Invalid superclasses"}),"\n",(0,t.jsx)(n.p,{children:"Our implementation is simple and fast, which is just the way I like my VM code.\r\nBut it's not robust. Nothing prevents a user from inheriting from an object that\r\nisn't a class at all:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:'var NotClass = "So not a class";\r\nclass OhNo < NotClass {}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Obviously, no self-respecting programmer would write that, but we have to guard\r\nagainst potential Lox users who have no self respect. A simple runtime check\r\nfixes that."}),"\n",(0,t.jsx)(n.p,{children:"^code inherit-non-class (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"If the value we loaded from the identifier in the superclass clause isn't an\r\nObjClass, we report a runtime error to let the user know what we think of them\r\nand their code."}),"\n",(0,t.jsx)(n.h2,{id:"storing-superclasses",children:"Storing Superclasses"}),"\n",(0,t.jsx)(n.p,{children:"Did you notice that when we added method inheritance, we didn't actually add any\r\nreference from a subclass to its superclass? After we copy the inherited methods\r\nover, we forget the superclass entirely. We don't need to keep a handle on the\r\nsuperclass, so we don't."}),"\n",(0,t.jsxs)(n.p,{children:["That won't be sufficient to support super calls. Since a subclass ",(0,t.jsx)(n.span,{name:"may",children:"may"})," override the superclass method, we need to be able to get\r\nour hands on superclass method tables. Before we get to that mechanism, I want\r\nto refresh your memory on how super calls are statically resolved."]}),"\n",(0,t.jsxs)(n.aside,{name:"may",children:["\n",(0,t.jsxs)(n.p,{children:['"May" might not be a strong enough word. Presumably the method ',(0,t.jsx)(n.em,{children:"has"})," been\r\noverridden. Otherwise, why are you bothering to use ",(0,t.jsx)(n.code,{children:"super"})," instead of just\r\ncalling it directly?"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Back in the halcyon days of jlox, I showed you ",(0,t.jsx)(n.a,{href:"inheritance.html#semantics",children:"this tricky example"})," to\r\nexplain the way super calls are dispatched:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:'class A {\r\n  method() {\r\n    print "A method";\r\n  }\r\n}\r\n\r\nclass B < A {\r\n  method() {\r\n    print "B method";\r\n  }\r\n\r\n  test() {\r\n    super.method();\r\n  }\r\n}\r\n\r\nclass C < B {}\r\n\r\nC().test();\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Inside the body of the ",(0,t.jsx)(n.code,{children:"test()"})," method, ",(0,t.jsx)(n.code,{children:"this"})," is an instance of C. If super\r\ncalls were resolved relative to the superclass of the ",(0,t.jsx)(n.em,{children:"receiver"}),", then we would\r\nlook in C's superclass, B. But super calls are resolved relative to the\r\nsuperclass of the ",(0,t.jsx)(n.em,{children:"surrounding class where the super call occurs"}),". In this case,\r\nwe are in B's ",(0,t.jsx)(n.code,{children:"test()"}),' method, so the superclass is A, and the program should\r\nprint "A method".']}),"\n",(0,t.jsx)(n.p,{children:"This means that super calls are not resolved dynamically based on the runtime\r\ninstance. The superclass used to look up the method is a static -- practically\r\nlexical -- property of where the call occurs. When we added inheritance to jlox,\r\nwe took advantage of that static aspect by storing the superclass in the same\r\nEnvironment structure we used for all lexical scopes. Almost as if the\r\ninterpreter saw the above program like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:'class A {\r\n  method() {\r\n    print "A method";\r\n  }\r\n}\r\n\r\nvar Bs_super = A;\r\nclass B < A {\r\n  method() {\r\n    print "B method";\r\n  }\r\n\r\n  test() {\r\n    runtimeSuperCall(Bs_super, "method");\r\n  }\r\n}\r\n\r\nvar Cs_super = B;\r\nclass C < B {}\r\n\r\nC().test();\n'})}),"\n",(0,t.jsx)(n.p,{children:"Each subclass has a hidden variable storing a reference to its superclass.\r\nWhenever we need to perform a super call, we access the superclass from that\r\nvariable and tell the runtime to start looking for methods there."}),"\n",(0,t.jsx)(n.p,{children:"We'll take the same path with clox. The difference is that instead of jlox's\r\nheap-allocated Environment class, we have the bytecode VM's value stack and\r\nupvalue system. The machinery is a little different, but the overall effect is\r\nthe same."}),"\n",(0,t.jsx)(n.h3,{id:"a-superclass-local-variable",children:"A superclass local variable"}),"\n",(0,t.jsx)(n.p,{children:"Our compiler already emits code to load the superclass onto the stack. Instead\r\nof leaving that slot as a temporary, we create a new scope and make it a local\r\nvariable."}),"\n",(0,t.jsx)(n.p,{children:"^code superclass-variable (2 before, 2 after)"}),"\n",(0,t.jsx)(n.p,{children:'Creating a new lexical scope ensures that if we declare two classes in the same\r\nscope, each has a different local slot to store its superclass. Since we always\r\nname this variable "super", if we didn\'t make a scope for each subclass, the\r\nvariables would collide.'}),"\n",(0,t.jsxs)(n.p,{children:['We name the variable "super" for the same reason we use "this" as the name of\r\nthe hidden local variable that ',(0,t.jsx)(n.code,{children:"this"})," expressions resolve to: \"super\" is a\r\nreserved word, which guarantees the compiler's hidden variable won't collide\r\nwith a user-defined one."]}),"\n",(0,t.jsxs)(n.p,{children:["The difference is that when compiling ",(0,t.jsx)(n.code,{children:"this"}),' expressions, we conveniently have a\r\ntoken sitting around whose lexeme is "this". We aren\'t so lucky here. Instead,\r\nwe add a little helper function to create a synthetic token for the given ',(0,t.jsx)(n.span,{name:"constant",children:"constant"})," string."]}),"\n",(0,t.jsx)(n.p,{children:"^code synthetic-token"}),"\n",(0,t.jsxs)(n.aside,{name:"constant",className:"bottom",children:["\n",(0,t.jsx)(n.p,{children:"I say \"constant string\" because tokens don't do any memory management of their\r\nlexeme. If we tried to use a heap-allocated string for this, we'd end up leaking\r\nmemory because it never gets freed. But the memory for C string literals lives\r\nin the executable's constant data section and never needs to be freed, so we're\r\nfine."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Since we opened a local scope for the superclass variable, we need to close it."}),"\n",(0,t.jsx)(n.p,{children:"^code end-superclass-scope (1 before, 2 after)"}),"\n",(0,t.jsxs)(n.p,{children:['We pop the scope and discard the "super" variable after compiling the class body\r\nand its methods. That way, the variable is accessible in all of the methods of\r\nthe subclass. It\'s a somewhat pointless optimization, but we create the scope\r\nonly if there ',(0,t.jsx)(n.em,{children:"is"})," a superclass clause. Thus we need to close the scope only if\r\nthere is one."]}),"\n",(0,t.jsxs)(n.p,{children:["To track that, we could declare a little local variable in ",(0,t.jsx)(n.code,{children:"classDeclaration()"}),".\r\nBut soon, other functions in the compiler will need to know whether the\r\nsurrounding class is a subclass or not. So we may as well give our future selves\r\na hand and store this fact as a field in the ClassCompiler now."]}),"\n",(0,t.jsx)(n.p,{children:"^code has-superclass (2 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"When we first initialize a ClassCompiler, we assume it is not a subclass."}),"\n",(0,t.jsx)(n.p,{children:"^code init-has-superclass (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"Then, if we see a superclass clause, we know we are compiling a subclass."}),"\n",(0,t.jsx)(n.p,{children:"^code set-has-superclass (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:'This machinery gives us a mechanism at runtime to access the superclass object\r\nof the surrounding subclass from within any of the subclass\'s methods -- simply\r\nemit code to load the variable named "super". That variable is a local outside\r\nof the method body, but our existing upvalue support enables the VM to capture\r\nthat local inside the body of the method or even in functions nested inside that\r\nmethod.'}),"\n",(0,t.jsx)(n.h2,{id:"super-calls",children:"Super Calls"}),"\n",(0,t.jsxs)(n.p,{children:["With that runtime support in place, we are ready to implement super calls. As\r\nusual, we go front to back, starting with the new syntax. A super call ",(0,t.jsx)(n.span,{name:"last",children:"begins"}),", naturally enough, with the ",(0,t.jsx)(n.code,{children:"super"})," keyword."]}),"\n",(0,t.jsxs)(n.aside,{name:"last",children:["\n",(0,t.jsx)(n.p,{children:"This is it, friend. The very last entry you'll add to the parsing table."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"^code table-super (1 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["When the expression parser lands on a ",(0,t.jsx)(n.code,{children:"super"})," token, control jumps to a new\r\nparsing function which starts off like so:"]}),"\n",(0,t.jsx)(n.p,{children:"^code super"}),"\n",(0,t.jsxs)(n.p,{children:["This is pretty different from how we compiled ",(0,t.jsx)(n.code,{children:"this"})," expressions. Unlike ",(0,t.jsx)(n.code,{children:"this"}),",\r\na ",(0,t.jsx)(n.code,{children:"super"})," ",(0,t.jsx)(n.span,{name:"token",children:"token"})," is not a standalone expression.\r\nInstead, the dot and method name following it are inseparable parts of the\r\nsyntax. However, the parenthesized argument list is separate. As with normal\r\nmethod access, Lox supports getting a reference to a superclass method as a\r\nclosure without invoking it:"]}),"\n",(0,t.jsxs)(n.aside,{name:"token",children:["\n",(0,t.jsxs)(n.p,{children:["Hypothetical question: If a bare ",(0,t.jsx)(n.code,{children:"super"})," token ",(0,t.jsx)(n.em,{children:"was"})," an expression, what kind of\r\nobject would it evaluate to?"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:'class A {\r\n  method() {\r\n    print "A";\r\n  }\r\n}\r\n\r\nclass B < A {\r\n  method() {\r\n    var closure = super.method;\r\n    closure(); // Prints "A".\r\n  }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In other words, Lox doesn't really have super ",(0,t.jsx)(n.em,{children:"call"})," expressions, it has super\r\n",(0,t.jsx)(n.em,{children:"access"})," expressions, which you can choose to immediately invoke if you want. So\r\nwhen the compiler hits a ",(0,t.jsx)(n.code,{children:"super"})," token, we consume the subsequent ",(0,t.jsx)(n.code,{children:"."})," token and\r\nthen look for a method name. Methods are looked up dynamically, so we use\r\n",(0,t.jsx)(n.code,{children:"identifierConstant()"})," to take the lexeme of the method name token and store it\r\nin the constant table just like we do for property access expressions."]}),"\n",(0,t.jsx)(n.p,{children:"Here is what the compiler does after consuming those tokens:"}),"\n",(0,t.jsx)(n.p,{children:"^code super-get (1 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["In order to access a ",(0,t.jsx)(n.em,{children:"superclass method"})," on ",(0,t.jsx)(n.em,{children:"the current instance"}),", the runtime\r\nneeds both the receiver ",(0,t.jsx)(n.em,{children:"and"})," the superclass of the surrounding method's class.\r\nThe first ",(0,t.jsx)(n.code,{children:"namedVariable()"}),' call generates code to look up the current receiver\r\nstored in the hidden variable "this" and push it onto the stack. The second\r\n',(0,t.jsx)(n.code,{children:"namedVariable()"}),' call emits code to look up the superclass from its "super"\r\nvariable and push that on top.']}),"\n",(0,t.jsxs)(n.p,{children:["Finally, we emit a new ",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"})," instruction with an operand for the\r\nconstant table index of the method name. That's a lot to hold in your head. To\r\nmake it tangible, consider this example program:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:'class Doughnut {\r\n  cook() {\r\n    print "Dunk in the fryer.";\r\n    this.finish("sprinkles");\r\n  }\r\n\r\n  finish(ingredient) {\r\n    print "Finish with " + ingredient;\r\n  }\r\n}\r\n\r\nclass Cruller < Doughnut {\r\n  finish(ingredient) {\r\n    // No sprinkles, always icing.\r\n    super.finish("icing");\r\n  }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The bytecode emitted for the ",(0,t.jsx)(n.code,{children:'super.finish("icing")'})," expression looks and works\r\nlike this:"]}),"\n",(0,t.jsx)(n.img,{src:"image/superclasses/super-instructions.png",alt:"The series of bytecode instructions for calling super.finish()."}),"\n",(0,t.jsx)(n.p,{children:"The first three instructions give the runtime access to the three pieces of\r\ninformation it needs to perform the super access:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The first instruction loads ",(0,t.jsx)(n.strong,{children:"the instance"})," onto the stack."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The second instruction loads ",(0,t.jsx)(n.strong,{children:"the superclass where the method is\r\nresolved"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Then the new ",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"})," instuction encodes ",(0,t.jsx)(n.strong,{children:"the name of the method to\r\naccess"})," as an operand."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The remaining instructions are the normal bytecode for evaluating an argument\r\nlist and calling a function."}),"\n",(0,t.jsxs)(n.p,{children:["We're almost ready to implement the new ",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"})," instruction in the\r\ninterpreter. But before we do, the compiler has some errors it is responsible\r\nfor reporting."]}),"\n",(0,t.jsx)(n.p,{children:"^code super-errors (1 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["A super call is meaningful only inside the body of a method (or in a function\r\nnested inside a method), and only inside the method of a class that has a\r\nsuperclass. We detect both of these cases using the value of ",(0,t.jsx)(n.code,{children:"currentClass"}),". If\r\nthat's ",(0,t.jsx)(n.code,{children:"NULL"})," or points to a class with no superclass, we report those errors."]}),"\n",(0,t.jsx)(n.h3,{id:"executing-super-accesses",children:"Executing super accesses"}),"\n",(0,t.jsxs)(n.p,{children:["Assuming the user didn't put a ",(0,t.jsx)(n.code,{children:"super"})," expression where it's not allowed, their\r\ncode passes from the compiler over to the runtime. We've got ourselves a new\r\ninstruction."]}),"\n",(0,t.jsx)(n.p,{children:"^code get-super-op (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"We disassemble it like other opcodes that take a constant table index operand."}),"\n",(0,t.jsx)(n.p,{children:"^code disassemble-get-super (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"You might anticipate something harder, but interpreting the new instruction is\r\nsimilar to executing a normal property access."}),"\n",(0,t.jsx)(n.p,{children:"^code interpret-get-super (1 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["As with properties, we read the method name from the\r\nconstant table. Then we pass that to ",(0,t.jsx)(n.code,{children:"bindMethod()"})," which looks up the method in\r\nthe given class's method table and creates an ObjBoundMethod to bundle the\r\nresulting closure to the current instance."]}),"\n",(0,t.jsxs)(n.p,{children:["The key ",(0,t.jsx)(n.span,{name:"field",children:"difference"})," is ",(0,t.jsx)(n.em,{children:"which"})," class we pass to\r\n",(0,t.jsx)(n.code,{children:"bindMethod()"}),". With a normal property access, we use the ObjInstances's own\r\nclass, which gives us the dynamic dispatch we want. For a super call, we don't\r\nuse the instance's class. Instead, we use the statically resolved superclass of\r\nthe containing class, which the compiler has conveniently ensured is sitting on\r\ntop of the stack waiting for us."]}),"\n",(0,t.jsxs)(n.p,{children:["We pop that superclass and pass it to ",(0,t.jsx)(n.code,{children:"bindMethod()"}),", which correctly skips over\r\nany overriding methods in any of the subclasses between that superclass and the\r\ninstance's own class. It also correctly includes any methods inherited by the\r\nsuperclass from any of ",(0,t.jsx)(n.em,{children:"its"})," superclasses."]}),"\n",(0,t.jsxs)(n.p,{children:["The rest of the behavior is the same. Popping the superclass leaves the instance\r\nat the top of the stack. When ",(0,t.jsx)(n.code,{children:"bindMethod()"})," succeeds, it pops the instance and\r\npushes the new bound method. Otherwise, it reports a runtime error and returns\r\n",(0,t.jsx)(n.code,{children:"false"}),". In that case, we abort the interpreter."]}),"\n",(0,t.jsxs)(n.aside,{name:"field",children:["\n",(0,t.jsxs)(n.p,{children:["Another difference compared to ",(0,t.jsx)(n.code,{children:"OP_GET_PROPERTY"})," is that we don't try to look\r\nfor a shadowing field first. Fields are not inherited, so ",(0,t.jsx)(n.code,{children:"super"})," expressions\r\nalways resolve to methods."]}),"\n",(0,t.jsxs)(n.p,{children:["If Lox were a prototype-based language that used ",(0,t.jsx)(n.em,{children:"delegation"})," instead of\r\n",(0,t.jsx)(n.em,{children:"inheritance"}),", then instead of one ",(0,t.jsx)(n.em,{children:"class"})," inheriting from another ",(0,t.jsx)(n.em,{children:"class"}),',\r\ninstances would inherit from ("delegate to") other instances. In that case,\r\nfields ',(0,t.jsx)(n.em,{children:"could"})," be inherited, and we would need to check for them here."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"faster-super-calls",children:"Faster super calls"}),"\n",(0,t.jsxs)(n.p,{children:["We have superclass method accesses working now. And since the returned object is\r\nan ObjBoundMethod that you can then invoke, we've got super ",(0,t.jsx)(n.em,{children:"calls"})," working too.\r\nJust like last chapter, we've reached a point where our VM has the complete,\r\ncorrect semantics."]}),"\n",(0,t.jsxs)(n.p,{children:["But, also like last chapter, it's pretty slow. Again, we're heap allocating an\r\nObjBoundMethod for each super call even though most of the time the very next\r\ninstruction is an ",(0,t.jsx)(n.code,{children:"OP_CALL"})," that immediately unpacks that bound method, invokes\r\nit, and then discards it. In fact, this is even more likely to be true for\r\nsuper calls than for regular method calls. At least with method calls there is\r\na chance that the user is actually invoking a function stored in a field. With\r\nsuper calls, you're ",(0,t.jsx)(n.em,{children:"always"})," looking up a method. The only question is whether\r\nyou invoke it immediately or not."]}),"\n",(0,t.jsxs)(n.p,{children:["The compiler can certainly answer that question for itself if it sees a left\r\nparenthesis after the superclass method name, so we'll go ahead and perform the\r\nsame optimization we did for method calls. Take out the two lines of code that\r\nload the superclass and emit ",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"}),", and replace them with this:"]}),"\n",(0,t.jsx)(n.p,{children:"^code super-invoke (1 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["Now before we emit anything, we look for a parenthesized argument list. If we\r\nfind one, we compile that. Then we load the superclass. After that, we emit a\r\nnew ",(0,t.jsx)(n.code,{children:"OP_SUPER_INVOKE"})," instruction. This ",(0,t.jsx)(n.span,{name:"superinstruction",children:"superinstruction"})," combines the behavior of\r\n",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"})," and ",(0,t.jsx)(n.code,{children:"OP_CALL"}),", so it takes two operands: the constant table index\r\nof the method name to look up and the number of arguments to pass to it."]}),"\n",(0,t.jsxs)(n.aside,{name:"superinstruction",children:["\n",(0,t.jsxs)(n.p,{children:["This is a particularly ",(0,t.jsx)(n.em,{children:"super"})," superinstruction, if you get what I'm saying.\r\nI... I'm sorry for this terrible joke."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Otherwise, if we don't find a ",(0,t.jsx)(n.code,{children:"("}),", we continue to compile the expression as a\r\nsuper access like we did before and emit an ",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Drifting down the compilation pipeline, our first stop is a new instruction."}),"\n",(0,t.jsx)(n.p,{children:"^code super-invoke-op (1 before, 1 after)"}),"\n",(0,t.jsx)(n.p,{children:"And just past that, its disassembler support."}),"\n",(0,t.jsx)(n.p,{children:"^code disassemble-super-invoke (1 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["A super invocation instruction has the same set of operands as ",(0,t.jsx)(n.code,{children:"OP_INVOKE"}),", so\r\nwe reuse the same helper to disassemble it. Finally, the pipeline dumps us into\r\nthe interpreter."]}),"\n",(0,t.jsx)(n.p,{children:"^code interpret-super-invoke (2 before, 1 after)"}),"\n",(0,t.jsxs)(n.p,{children:["This handful of code is basically our implementation of ",(0,t.jsx)(n.code,{children:"OP_INVOKE"})," mixed\r\ntogether with a dash of ",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"}),". There are some differences in how the\r\nstack is organized, though. With an unoptimized super call, the superclass is\r\npopped and replaced by the ObjBoundMethod for the resolved function ",(0,t.jsx)(n.em,{children:"before"})," the\r\narguments to the call are executed. This ensures that by the time the ",(0,t.jsx)(n.code,{children:"OP_CALL"}),"\r\nis executed, the bound method is ",(0,t.jsx)(n.em,{children:"under"})," the argument list, where the runtime\r\nexpects it to be for a closure call."]}),"\n",(0,t.jsx)(n.p,{children:"With our optimized instructions, things are shuffled a bit:"}),"\n",(0,t.jsx)(n.img,{src:"image/superclasses/super-invoke.png",className:"wide",alt:"The series of bytecode instructions for calling super.finish() using OP_SUPER_INVOKE."}),"\n",(0,t.jsxs)(n.p,{children:["Now resolving the superclass method is part of the ",(0,t.jsx)(n.em,{children:"invocation"}),", so the\r\narguments need to already be on the stack at the point that we look up the\r\nmethod. This means the superclass object is on top of the arguments."]}),"\n",(0,t.jsxs)(n.p,{children:["Aside from that, the behavior is roughly the same as an ",(0,t.jsx)(n.code,{children:"OP_GET_SUPER"})," followed\r\nby an ",(0,t.jsx)(n.code,{children:"OP_CALL"}),". First, we pull out the method name and argument count operands.\r\nThen we pop the superclass off the top of the stack so that we can look up the\r\nmethod in its method table. This conveniently leaves the stack set up just right\r\nfor a method call."]}),"\n",(0,t.jsxs)(n.p,{children:["We pass the superclass, method name, and argument count to our existing\r\n",(0,t.jsx)(n.code,{children:"invokeFromClass()"})," function. That function looks up the given method on the\r\ngiven class and attempts to create a call to it with the given arity. If a\r\nmethod could not be found, it returns ",(0,t.jsx)(n.code,{children:"false"}),", and we bail out of the\r\ninterpreter. Otherwise, ",(0,t.jsx)(n.code,{children:"invokeFromClass()"})," pushes a new CallFrame onto the call\r\nstack for the method's closure. That invalidates the interpreter's cached\r\nCallFrame pointer, so we refresh ",(0,t.jsx)(n.code,{children:"frame"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"a-complete-virtual-machine",children:"A Complete Virtual Machine"}),"\n",(0,t.jsx)(n.p,{children:"Take a look back at what we've created. By my count, we wrote around 2,500 lines\r\nof fairly clean, straightforward C. That little program contains a complete\r\nimplementation of the -- quite high-level! -- Lox language, with a whole\r\nprecedence table full of expression types and a suite of control flow\r\nstatements. We implemented variables, functions, closures, classes, fields,\r\nmethods, and inheritance."}),"\n",(0,t.jsx)(n.p,{children:"Even more impressive, our implementation is portable to any platform with a C\r\ncompiler, and is fast enough for real-world production use. We have a\r\nsingle-pass bytecode compiler, a tight virtual machine interpreter for our\r\ninternal instruction set, compact object representations, a stack for storing\r\nvariables without heap allocation, and a precise garbage collector."}),"\n",(0,t.jsx)(n.p,{children:"If you go out and start poking around in the implementations of Lua, Python, or\r\nRuby, you will be surprised by how much of it now looks familiar to you. You\r\nhave seriously leveled up your knowledge of how programming languages work,\r\nwhich in turn gives you a deeper understanding of programming itself. It's like\r\nyou used to be a race car driver, and now you can pop the hood and repair the\r\nengine too."}),"\n",(0,t.jsxs)(n.p,{children:["You can stop here if you like. The two implementations of Lox you have are\r\ncomplete and full featured. You built the car and can drive it wherever you want\r\nnow. But if you are looking to have more fun tuning and tweaking for even\r\ngreater performance out on the track, there is one more chapter. We don't add\r\nany new capabilities, but we roll in a couple of classic optimizations to\r\nsqueeze even more perf out. If that sounds fun, ",(0,t.jsx)(n.a,{href:"optimization.html",children:"keep reading"}),"..."]}),"\n",(0,t.jsxs)(n.div,{className:"challenges",children:["\n",(0,t.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"A tenet of object-oriented programming is that a class should ensure new\r\nobjects are in a valid state. In Lox, that means defining an initializer\r\nthat populates the instance's fields. Inheritance complicates invariants\r\nbecause the instance must be in a valid state according to all of the\r\nclasses in the object's inheritance chain."}),"\n",(0,t.jsxs)(n.p,{children:["The easy part is remembering to call ",(0,t.jsx)(n.code,{children:"super.init()"})," in each subclass's\r\n",(0,t.jsx)(n.code,{children:"init()"})," method. The harder part is fields. There is nothing preventing two\r\nclasses in the inheritance chain from accidentally claiming the same field\r\nname. When this happens, they will step on each other's fields and possibly\r\nleave you with an instance in a broken state."]}),"\n",(0,t.jsx)(n.p,{children:"If Lox was your language, how would you address this, if at all? If you\r\nwould change the language, implement your change."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Our copy-down inheritance optimization is valid only because Lox does not\r\npermit you to modify a class's methods after its declaration. This means we\r\ndon't have to worry about the copied methods in the subclass getting out of\r\nsync with later changes to the superclass."}),"\n",(0,t.jsxs)(n.p,{children:["Other languages, like Ruby, ",(0,t.jsx)(n.em,{children:"do"})," allow classes to be modified after the\r\nfact. How do implementations of languages like that support class\r\nmodification while keeping method resolution efficient?"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["In the ",(0,t.jsx)(n.a,{href:"inheritance.html",children:"jlox chapter on inheritance"}),", we had a challenge to\r\nimplement the BETA language's approach to method overriding. Solve the\r\nchallenge again, but this time in clox. Here's the description of the\r\nprevious challenge:"]}),"\n",(0,t.jsxs)(n.p,{children:["In Lox, as in most other object-oriented languages, when looking up a\r\nmethod, we start at the bottom of the class hierarchy and work our way up --\r\na subclass's method is preferred over a superclass's. In order to get to the\r\nsuperclass method from within an overriding method, you use ",(0,t.jsx)(n.code,{children:"super"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The language ",(0,t.jsx)(n.a,{href:"https://beta.cs.au.dk/",children:"BETA"})," takes the ",(0,t.jsx)(n.a,{href:"http://journal.stuffwithstuff.com/2012/12/19/the-impoliteness-of-overriding-methods/",children:"opposite approach"}),". When you call a\r\nmethod, it starts at the ",(0,t.jsx)(n.em,{children:"top"})," of the class hierarchy and works ",(0,t.jsx)(n.em,{children:"down"}),". A\r\nsuperclass method wins over a subclass method. In order to get to the\r\nsubclass method, the superclass method can call ",(0,t.jsx)(n.code,{children:"inner"}),", which is sort of\r\nlike the inverse of ",(0,t.jsx)(n.code,{children:"super"}),". It chains to the next method down the\r\nhierarchy."]}),"\n",(0,t.jsxs)(n.p,{children:["The superclass method controls when and where the subclass is allowed to\r\nrefine its behavior. If the superclass method doesn't call ",(0,t.jsx)(n.code,{children:"inner"})," at all,\r\nthen the subclass has no way of overriding or modifying the superclass's\r\nbehavior."]}),"\n",(0,t.jsxs)(n.p,{children:["Take out Lox's current overriding and ",(0,t.jsx)(n.code,{children:"super"})," behavior, and replace it with\r\nBETA's semantics. In short:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["When calling a method on a class, the method ",(0,t.jsx)(n.em,{children:"highest"})," on the\r\nclass's inheritance chain takes precedence."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Inside the body of a method, a call to ",(0,t.jsx)(n.code,{children:"inner"})," looks for a method with\r\nthe same name in the nearest subclass along the inheritance chain\r\nbetween the class containing the ",(0,t.jsx)(n.code,{children:"inner"})," and the class of ",(0,t.jsx)(n.code,{children:"this"}),". If\r\nthere is no matching method, the ",(0,t.jsx)(n.code,{children:"inner"})," call does nothing."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lox",children:'class Doughnut {\r\n  cook() {\r\n    print "Fry until golden brown.";\r\n    inner();\r\n    print "Place in a nice box.";\r\n  }\r\n}\r\n\r\nclass BostonCream < Doughnut {\r\n  cook() {\r\n    print "Pipe full of custard and coat with chocolate.";\r\n  }\r\n}\r\n\r\nBostonCream().cook();\n'})}),"\n",(0,t.jsx)(n.p,{children:"This should print:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Fry until golden brown.\r\nPipe full of custard and coat with chocolate.\r\nPlace in a nice box.\n"})}),"\n",(0,t.jsx)(n.p,{children:"Since clox is about not just implementing Lox, but doing so with good\r\nperformance, this time around try to solve the challenge with an eye towards\r\nefficiency."}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);