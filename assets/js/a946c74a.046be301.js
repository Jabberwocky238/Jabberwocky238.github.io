"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[4768],{9075:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>h});var r=t(4848),s=t(8453);const o={},a=void 0,i={id:"Craftinginterpreters/not-translated-yet/types-of-values",title:"types-of-values",description:"When you are a Bear of Very Little Brain, and you Think of Things, you find",source:"@site/docs/Craftinginterpreters/not-translated-yet/types-of-values.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/types-of-values",permalink:"/docs/Craftinginterpreters/not-translated-yet/types-of-values",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/types-of-values.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"the-lox-language",permalink:"/docs/Craftinginterpreters/not-translated-yet/the-lox-language"}},l={},h=[{value:"Tagged Unions",id:"tagged-unions",level:2},{value:"Lox Values and C Values",id:"lox-values-and-c-values",level:2},{value:"Dynamically Typed Numbers",id:"dynamically-typed-numbers",level:2},{value:"Unary negation and runtime errors",id:"unary-negation-and-runtime-errors",level:3},{value:"Binary arithmetic operators",id:"binary-arithmetic-operators",level:3},{value:"Two New Types",id:"two-new-types",level:2},{value:"Logical not and falsiness",id:"logical-not-and-falsiness",level:3},{value:"Equality and comparison operators",id:"equality-and-comparison-operators",level:3},{value:"Challenges",id:"challenges",level:2}];function d(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"When you are a Bear of Very Little Brain, and you Think of Things, you find\r\nsometimes that a Thing which seemed very Thingish inside you is quite\r\ndifferent when it gets out into the open and has other people looking at it."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["A. A. Milne, ",(0,r.jsx)(n.em,{children:"Winnie-the-Pooh"})]})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The past few chapters were huge, packed full of complex techniques and pages of\r\ncode. In this chapter, there's only one new concept to learn and a scattering of\r\nstraightforward code. You've earned a respite."}),"\n",(0,r.jsxs)(n.p,{children:["Lox is ",(0,r.jsx)(n.span,{name:"unityped",children:"dynamically"})," typed. A single variable can\r\nhold a Boolean, number, or string at different points in time. At least, that's\r\nthe idea. Right now, in clox, all values are numbers. By the end of the chapter,\r\nit will also support Booleans and ",(0,r.jsx)(n.code,{children:"nil"}),". While those aren't super interesting,\r\nthey force us to figure out how our value representation can dynamically handle\r\ndifferent types."]}),"\n",(0,r.jsxs)(n.aside,{name:"unityped",children:["\n",(0,r.jsxs)(n.p,{children:["There is a third category next to statically typed and dynamically typed:\r\n",(0,r.jsx)(n.strong,{children:"unityped"}),". In that paradigm, all variables have a single type, usually a\r\nmachine register integer. Unityped languages aren't common today, but some\r\nForths and BCPL, the language that inspired C, worked like this."]}),"\n",(0,r.jsx)(n.p,{children:"As of this moment, clox is unityped."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tagged-unions",children:"Tagged Unions"}),"\n",(0,r.jsxs)(n.p,{children:["The nice thing about working in C is that we can build our data structures from\r\nthe raw bits up. The bad thing is that we ",(0,r.jsx)(n.em,{children:"have"})," to do that. C doesn't give you\r\nmuch for free at compile time and even less at runtime. As far as C is\r\nconcerned, the universe is an undifferentiated array of bytes. It's up to us to\r\ndecide how many of those bytes to use and what they mean."]}),"\n",(0,r.jsx)(n.p,{children:"In order to choose a value representation, we need to answer two key questions:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"How do we represent the type of a value?"})," If you try to, say, multiply a\r\nnumber by ",(0,r.jsx)(n.code,{children:"true"}),", we need to detect that error at runtime and report it. In\r\norder to do that, we need to be able to tell what a value's type is."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"How do we store the value itself?"})," We need to not only be able to tell\r\nthat three is a number, but that it's different from the number four. I\r\nknow, seems obvious, right? But we're operating at a level where it's good\r\nto spell these things out."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Since we're not just designing this language but building it ourselves, when\r\nanswering these two questions we also have to keep in mind the implementer's\r\neternal quest: to do it ",(0,r.jsx)(n.em,{children:"efficiently"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Language hackers over the years have come up with a variety of clever ways to\r\npack the above information into as few bits as possible. For now, we'll start\r\nwith the simplest, classic solution: a ",(0,r.jsx)(n.strong,{children:"tagged union"}),'. A value contains two\r\nparts: a type "tag", and a payload for the actual value. To store the value\'s\r\ntype, we define an enum for each kind of value the VM supports.']}),"\n",(0,r.jsx)(n.p,{children:"^code value-type (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.aside,{name:"user-types",children:["\n",(0,r.jsxs)(n.p,{children:["The cases here cover each kind of value that has ",(0,r.jsx)(n.em,{children:"built-in support in the VM"}),'.\r\nWhen we get to adding classes to the language, each class the user defines\r\ndoesn\'t need its own entry in this enum. As far as the VM is concerned, every\r\ninstance of a class is the same type: "instance".']}),"\n",(0,r.jsx)(n.p,{children:"In other words, this is the VM's notion of \"type\", not the user's."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For now, we have only a couple of cases, but this will grow as we add strings,\r\nfunctions, and classes to clox. In addition to the type, we also need to store\r\nthe data for the value -- the ",(0,r.jsx)(n.code,{children:"double"})," for a number, ",(0,r.jsx)(n.code,{children:"true"})," or ",(0,r.jsx)(n.code,{children:"false"})," for a\r\nBoolean. We could define a struct with fields for each possible type."]}),"\n",(0,r.jsx)(n.img,{src:"image/types-of-values/struct.png",alt:"A struct with two fields laid next to each other in memory."}),"\n",(0,r.jsxs)(n.p,{children:["But this is a waste of memory. A value can't simultaneously be both a number and\r\na Boolean. So at any point in time, only one of those fields will be used. C\r\nlets you optimize this by defining a ",(0,r.jsx)(n.span,{name:"sum",children:"union"}),". A union\r\nlooks like a struct except that all of its fields overlap in memory."]}),"\n",(0,r.jsxs)(n.aside,{name:"sum",children:["\n",(0,r.jsx)(n.p,{children:"If you're familiar with a language in the ML family, structs and unions in C\r\nroughly mirror the difference between product and sum types, between tuples\r\nand algebraic data types."}),"\n"]}),"\n",(0,r.jsx)(n.img,{src:"image/types-of-values/union.png",alt:"A union with two fields overlapping in memory."}),"\n",(0,r.jsxs)(n.p,{children:["The size of a union is the size of its largest field. Since the fields all reuse\r\nthe same bits, you have to be very careful when working with them. If you store\r\ndata using one field and then access it using ",(0,r.jsx)(n.span,{name:"reinterpret",children:"another"}),", you will reinterpret what the underlying bits\r\nmean."]}),"\n",(0,r.jsxs)(n.aside,{name:"reinterpret",children:["\n",(0,r.jsx)(n.p,{children:"Using a union to interpret bits as different types is the quintessence of C. It\r\nopens up a number of clever optimizations and lets you slice and dice each byte\r\nof memory in ways that memory-safe languages disallow. But it is also wildly\r\nunsafe and will happily saw your fingers off if you don't watch out."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'As the name "tagged union" implies, our new value representation combines these\r\ntwo parts into a single struct.'}),"\n",(0,r.jsx)(n.p,{children:"^code value (2 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"There's a field for the type tag, and then a second field containing the union\r\nof all of the underlying values. On a 64-bit machine with a typical C compiler,\r\nthe layout looks like this:"}),"\n",(0,r.jsxs)(n.aside,{name:"as",children:["\n",(0,r.jsx)(n.p,{children:'A smart language hacker gave me the idea to use "as" for the name of the union\r\nfield because it reads nicely, almost like a cast, when you pull the various\r\nvalues out.'}),"\n"]}),"\n",(0,r.jsx)(n.img,{src:"image/types-of-values/value.png",alt:"The full value struct, with the type and as fields next to each other in memory."}),"\n",(0,r.jsxs)(n.p,{children:["The four-byte type tag comes first, then the union. Most architectures prefer\r\nvalues be aligned to their size. Since the union field contains an eight-byte\r\ndouble, the compiler adds four bytes of ",(0,r.jsx)(n.span,{name:"pad",children:"padding"})," after\r\nthe type field to keep that double on the nearest eight-byte boundary. That\r\nmeans we're effectively spending eight bytes on the type tag, which only needs\r\nto represent a number between zero and three. We could stuff the enum in a\r\nsmaller size, but all that would do is increase the padding."]}),"\n",(0,r.jsxs)(n.aside,{name:"pad",children:["\n",(0,r.jsxs)(n.p,{children:["We could move the tag field ",(0,r.jsx)(n.em,{children:"after"})," the union, but that doesn't help much\r\neither. Whenever we create an array of Values -- which is where most of our\r\nmemory usage for Values will be -- the C compiler will insert that same padding\r\n",(0,r.jsx)(n.em,{children:"between"})," each Value to keep the doubles aligned."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["So our Values are 16 bytes, which seems a little large. We'll improve it\r\n",(0,r.jsx)(n.a,{href:"optimization.html",children:"later"}),". In the meantime, they're still small enough to store on\r\nthe C stack and pass around by value. Lox's semantics allow that because the\r\nonly types we support so far are ",(0,r.jsx)(n.strong,{children:"immutable"}),". If we pass a copy of a Value\r\ncontaining the number three to some function, we don't need to worry about the\r\ncaller seeing modifications to the value. You can't \"modify\" three. It's three\r\nforever."]}),"\n",(0,r.jsx)(n.h2,{id:"lox-values-and-c-values",children:"Lox Values and C Values"}),"\n",(0,r.jsxs)(n.p,{children:["That's our new value representation, but we aren't done. Right now, the rest of\r\nclox assumes Value is an alias for ",(0,r.jsx)(n.code,{children:"double"}),". We have code that does a straight C\r\ncast from one to the other. That code is all broken now. So sad."]}),"\n",(0,r.jsxs)(n.p,{children:["With our new representation, a Value can ",(0,r.jsx)(n.em,{children:"contain"})," a double, but it's not\r\n",(0,r.jsx)(n.em,{children:"equivalent"})," to it. There is a mandatory conversion step to get from one to the\r\nother. We need to go through the code and insert those conversions to get clox\r\nworking again."]}),"\n",(0,r.jsx)(n.p,{children:"We'll implement these conversions as a handful of macros, one for each type and\r\noperation. First, to promote a native C value to a clox Value:"}),"\n",(0,r.jsx)(n.p,{children:"^code value-macros (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Each one of these takes a C value of the appropriate type and produces a Value\r\nthat has the correct type tag and contains the underlying value. This hoists\r\nstatically typed values up into clox's dynamically typed universe. In order to\r\n",(0,r.jsx)(n.em,{children:"do"})," anything with a Value, though, we need to unpack it and get the C value\r\nback out."]}),"\n",(0,r.jsx)(n.p,{children:"^code as-macros (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.aside,{name:"as-null",children:["\n",(0,r.jsxs)(n.p,{children:["There's no ",(0,r.jsx)(n.code,{children:"AS_NIL"})," macro because there is only one ",(0,r.jsx)(n.code,{children:"nil"})," value, so a Value with\r\ntype ",(0,r.jsx)(n.code,{children:"VAL_NIL"})," doesn't carry any extra data."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"as-null",children:"These"}),' macros go in the opposite direction. Given a\r\nValue of the right type, they unwrap it and return the corresponding raw C\r\nvalue. The "right type" part is important! These macros directly access the\r\nunion fields. If we were to do something like:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"Value value = BOOL_VAL(true);\r\ndouble number = AS_NUMBER(value);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then we may open a smoldering portal to the Shadow Realm. It's not safe to use\r\nany of the ",(0,r.jsx)(n.code,{children:"AS_"})," macros unless we know the Value contains the appropriate type.\r\nTo that end, we define a last few macros to check a Value's type."]}),"\n",(0,r.jsx)(n.p,{children:"^code is-macros (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"universe",children:"These"})," macros return ",(0,r.jsx)(n.code,{children:"true"})," if the Value has that\r\ntype. Any time we call one of the ",(0,r.jsx)(n.code,{children:"AS_"})," macros, we need to guard it behind a\r\ncall to one of these first. With these eight macros, we can now safely shuttle\r\ndata between Lox's dynamic world and C's static one."]}),"\n",(0,r.jsxs)(n.aside,{name:"universe",children:["\n",(0,r.jsx)(n.img,{src:"image/types-of-values/universe.png",alt:"The earthly C firmament with the Lox heavens above."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"_VAL"})," macros lift a C value into the heavens. The ",(0,r.jsx)(n.code,{children:"AS_"})," macros bring it\r\nback down."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"dynamically-typed-numbers",children:"Dynamically Typed Numbers"}),"\n",(0,r.jsx)(n.p,{children:"We've got our value representation and the tools to convert to and from it. All\r\nthat's left to get clox running again is to grind through the code and fix every\r\nplace where data moves across that boundary. This is one of those sections of\r\nthe book that isn't exactly mind-blowing, but I promised I'd show you every\r\nsingle line of code, so here we are."}),"\n",(0,r.jsx)(n.p,{children:"The first values we create are the constants generated when we compile number\r\nliterals. After we convert the lexeme to a C double, we simply wrap it in a\r\nValue before storing it in the constant table."}),"\n",(0,r.jsx)(n.p,{children:"^code const-number-val (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Over in the runtime, we have a function to print values."}),"\n",(0,r.jsx)(n.p,{children:"^code print-number-value (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Right before we send the Value to ",(0,r.jsx)(n.code,{children:"printf()"}),", we unwrap it and extract the\r\ndouble value. We'll revisit this function shortly to add the other types, but\r\nlet's get our existing code working first."]}),"\n",(0,r.jsx)(n.h3,{id:"unary-negation-and-runtime-errors",children:"Unary negation and runtime errors"}),"\n",(0,r.jsx)(n.p,{children:"The next simplest operation is unary negation. It pops a value off the stack,\r\nnegates it, and pushes the result. Now that we have other types of values, we\r\ncan't assume the operand is a number anymore. The user could just as well do:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"print -false; // Uh...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We need to handle that gracefully, which means it's time for ",(0,r.jsx)(n.em,{children:"runtime errors"}),".\r\nBefore performing an operation that requires a certain type, we need to make\r\nsure the Value ",(0,r.jsx)(n.em,{children:"is"})," that type."]}),"\n",(0,r.jsx)(n.p,{children:"For unary negation, the check looks like this:"}),"\n",(0,r.jsx)(n.p,{children:"^code op-negate (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["First, we check to see if the Value on top of the stack is a number. If it's\r\nnot, we report the runtime error and ",(0,r.jsx)(n.span,{name:"halt",children:"stop"})," the\r\ninterpreter. Otherwise, we keep going. Only after this validation do we unwrap\r\nthe operand, negate it, wrap the result and push it."]}),"\n",(0,r.jsxs)(n.aside,{name:"halt",children:["\n",(0,r.jsxs)(n.p,{children:["Lox's approach to error-handling is rather... ",(0,r.jsx)(n.em,{children:"spare"}),". All errors are fatal and\r\nimmediately halt the interpreter. There's no way for user code to recover from\r\nan error. If Lox were a real language, this is one of the first things I would\r\nremedy."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"To access the Value, we use a new little function."}),"\n",(0,r.jsx)(n.p,{children:"^code peek"}),"\n",(0,r.jsxs)(n.p,{children:["It returns a Value from the stack but doesn't ",(0,r.jsx)(n.span,{name:"peek",children:"pop"})," it.\r\nThe ",(0,r.jsx)(n.code,{children:"distance"})," argument is how far down from the top of the stack to look: zero\r\nis the top, one is one slot down, etc."]}),"\n",(0,r.jsxs)(n.aside,{name:"peek",children:["\n",(0,r.jsx)(n.p,{children:"Why not just pop the operand and then validate it? We could do that. In later\r\nchapters, it will be important to leave operands on the stack to ensure the\r\ngarbage collector can find them if a collection is triggered in the middle of\r\nthe operation. I do the same thing here mostly out of habit."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We report the runtime error using a new function that we'll get a lot of mileage\r\nout of over the remainder of the book."}),"\n",(0,r.jsx)(n.p,{children:"^code runtime-error"}),"\n",(0,r.jsxs)(n.p,{children:["You've certainly ",(0,r.jsx)(n.em,{children:"called"})," variadic functions -- ones that take a varying number\r\nof arguments -- in C before: ",(0,r.jsx)(n.code,{children:"printf()"})," is one. But you may not have ",(0,r.jsx)(n.em,{children:"defined"}),"\r\nyour own. This book isn't a C ",(0,r.jsx)(n.span,{name:"tutorial",children:"tutorial"}),", so I'll\r\nskim over it here, but basically the ",(0,r.jsx)(n.code,{children:"..."})," and ",(0,r.jsx)(n.code,{children:"va_list"})," stuff let us pass an\r\narbitrary number of arguments to ",(0,r.jsx)(n.code,{children:"runtimeError()"}),". It forwards those on to\r\n",(0,r.jsx)(n.code,{children:"vfprintf()"}),", which is the flavor of ",(0,r.jsx)(n.code,{children:"printf()"})," that takes an explicit\r\n",(0,r.jsx)(n.code,{children:"va_list"}),"."]}),"\n",(0,r.jsxs)(n.aside,{name:"tutorial",children:["\n",(0,r.jsxs)(n.p,{children:["If you are looking for a C tutorial, I love ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.a,{href:"https://www.cs.princeton.edu/~bwk/cbook.html",children:"The C Programming Language"})}),',\r\nusually called "K&R" in honor of its authors. It\'s not entirely up to date, but\r\nthe quality of the writing more than makes up for it.']}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Callers can pass a format string to ",(0,r.jsx)(n.code,{children:"runtimeError()"})," followed by a number of\r\narguments, just like they can when calling ",(0,r.jsx)(n.code,{children:"printf()"})," directly. ",(0,r.jsx)(n.code,{children:"runtimeError()"}),"\r\nthen formats and prints those arguments. We won't take advantage of that in this\r\nchapter, but later chapters will produce formatted runtime error messages that\r\ncontain other data."]}),"\n",(0,r.jsxs)(n.p,{children:["After we show the hopefully helpful error message, we tell the user which ",(0,r.jsx)(n.span,{name:"stack",children:"line"})," of their code was being executed when the error\r\noccurred. Since we left the tokens behind in the compiler, we look up the line\r\nin the debug information compiled into the chunk. If our compiler did its job\r\nright, that corresponds to the line of source code that the bytecode was\r\ncompiled from."]}),"\n",(0,r.jsxs)(n.p,{children:["We look into the chunk's debug line array using the current bytecode instruction\r\nindex ",(0,r.jsx)(n.em,{children:"minus one"}),". That's because the interpreter advances past each instruction\r\nbefore executing it. So, at the point that we call ",(0,r.jsx)(n.code,{children:"runtimeError()"}),", the failed\r\ninstruction is the previous one."]}),"\n",(0,r.jsxs)(n.aside,{name:"stack",children:["\n",(0,r.jsx)(n.p,{children:"Just showing the immediate line where the error occurred doesn't provide much\r\ncontext. Better would be a full stack trace. But we don't even have functions to\r\ncall yet, so there is no call stack to trace."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In order to use ",(0,r.jsx)(n.code,{children:"va_list"})," and the macros for working with it, we need to bring\r\nin a standard header."]}),"\n",(0,r.jsx)(n.p,{children:"^code include-stdarg (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"With this, our VM can not only do the right thing when we negate numbers (like\r\nit used to before we broke it), but it also gracefully handles erroneous\r\nattempts to negate other types (which we don't have yet, but still)."}),"\n",(0,r.jsx)(n.h3,{id:"binary-arithmetic-operators",children:"Binary arithmetic operators"}),"\n",(0,r.jsxs)(n.p,{children:["We have our runtime error machinery in place now, so fixing the binary operators\r\nis easier even though they're more complex. We support four binary operators\r\ntoday: ",(0,r.jsx)(n.code,{children:"+"}),", ",(0,r.jsx)(n.code,{children:"-"}),", ",(0,r.jsx)(n.code,{children:"*"}),", and ",(0,r.jsx)(n.code,{children:"/"}),". The only difference between them is which\r\nunderlying C operator they use. To minimize redundant code between the four\r\noperators, we wrapped up the commonality in a big preprocessor macro that takes\r\nthe operator token as a parameter."]}),"\n",(0,r.jsxs)(n.p,{children:["That macro seemed like overkill a ",(0,r.jsx)(n.a,{href:"a-virtual-machine.html#binary-operators",children:"few chapters ago"}),", but we get the benefit\r\nfrom it today. It lets us add the necessary type checking and conversions in one\r\nplace."]}),"\n",(0,r.jsx)(n.p,{children:"^code binary-op (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"Yeah, I realize that's a monster of a macro. It's not what I'd normally consider\r\ngood C practice, but let's roll with it. The changes are similar to what we did\r\nfor unary negate. First, we check that the two operands are both numbers. If\r\neither isn't, we report a runtime error and yank the ejection seat lever."}),"\n",(0,r.jsxs)(n.p,{children:["If the operands are fine, we pop them both and unwrap them. Then we apply the\r\ngiven operator, wrap the result, and push it back on the stack. Note that we\r\ndon't wrap the result by directly using ",(0,r.jsx)(n.code,{children:"NUMBER_VAL()"}),". Instead, the wrapper to\r\nuse is passed in as a macro ",(0,r.jsx)(n.span,{name:"macro",children:"parameter"}),". For our\r\nexisting arithmetic operators, the result is a number, so we pass in the\r\n",(0,r.jsx)(n.code,{children:"NUMBER_VAL"})," macro."]}),"\n",(0,r.jsxs)(n.aside,{name:"macro",children:["\n",(0,r.jsx)(n.p,{children:"Did you know you can pass macros as parameters to macros? Now you do!"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code op-arithmetic (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Soon, I'll show you why we made the wrapping macro an argument."}),"\n",(0,r.jsx)(n.h2,{id:"two-new-types",children:"Two New Types"}),"\n",(0,r.jsx)(n.p,{children:"All of our existing clox code is back in working order. Finally, it's time to\r\nadd some new types. We've got a running numeric calculator that now does a\r\nnumber of pointless paranoid runtime type checks. We can represent other types\r\ninternally, but there's no way for a user's program to ever create a Value of\r\none of those types."}),"\n",(0,r.jsxs)(n.p,{children:["Not until now, that is. We'll start by adding compiler support for the three new\r\nliterals: ",(0,r.jsx)(n.code,{children:"true"}),", ",(0,r.jsx)(n.code,{children:"false"}),", and ",(0,r.jsx)(n.code,{children:"nil"}),". They're all pretty simple, so we'll do all\r\nthree in a single batch."]}),"\n",(0,r.jsxs)(n.p,{children:["With number literals, we had to deal with the fact that there are billions of\r\npossible numeric values. We attended to that by storing the literal's value in\r\nthe chunk's constant table and emitting a bytecode instruction that simply\r\nloaded that constant. We could do the same thing for the new types. We'd store,\r\nsay, ",(0,r.jsx)(n.code,{children:"true"}),", in the constant table, and use an ",(0,r.jsx)(n.code,{children:"OP_CONSTANT"})," to read it out."]}),"\n",(0,r.jsxs)(n.p,{children:["But given that there are literally (heh) only three possible values we need to\r\nworry about with these new types, it's gratuitous -- and ",(0,r.jsx)(n.span,{name:"small",children:"slow!"})," -- to waste a two-byte instruction and a constant\r\ntable entry on them. Instead, we'll define three dedicated instructions to push\r\neach of these literals on the stack."]}),"\n",(0,r.jsxs)(n.aside,{name:"small",className:"bottom",children:["\n",(0,r.jsx)(n.p,{children:"I'm not kidding about dedicated operations for certain constant values being\r\nfaster. A bytecode VM spends much of its execution time reading and decoding\r\ninstructions. The fewer, simpler instructions you need for a given piece of\r\nbehavior, the faster it goes. Short instructions dedicated to common operations\r\nare a classic optimization."}),"\n",(0,r.jsx)(n.p,{children:"For example, the Java bytecode instruction set has dedicated instructions for\r\nloading 0.0, 1.0, 2.0, and the integer values from -1 through 5. (This ends up\r\nbeing a vestigial optimization given that most mature JVMs now JIT-compile the\r\nbytecode to machine code before execution anyway.)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code literal-ops (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Our scanner already treats ",(0,r.jsx)(n.code,{children:"true"}),", ",(0,r.jsx)(n.code,{children:"false"}),", and ",(0,r.jsx)(n.code,{children:"nil"})," as keywords, so we can\r\nskip right to the parser. With our table-based Pratt parser, we just need to\r\nslot parser functions into the rows associated with those keyword token types.\r\nWe'll use the same function in all three slots. Here:"]}),"\n",(0,r.jsx)(n.p,{children:"^code table-false (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Here:"}),"\n",(0,r.jsx)(n.p,{children:"^code table-true (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And here:"}),"\n",(0,r.jsx)(n.p,{children:"^code table-nil (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["When the parser encounters ",(0,r.jsx)(n.code,{children:"false"}),", ",(0,r.jsx)(n.code,{children:"nil"}),", or ",(0,r.jsx)(n.code,{children:"true"}),", in prefix position, it\r\ncalls this new parser function:"]}),"\n",(0,r.jsx)(n.p,{children:"^code parse-literal"}),"\n",(0,r.jsxs)(n.p,{children:["Since ",(0,r.jsx)(n.code,{children:"parsePrecedence()"})," has already consumed the keyword token, all we need to\r\ndo is output the proper instruction. We ",(0,r.jsx)(n.span,{name:"switch",children:"figure"})," that\r\nout based on the type of token we parsed. Our front end can now compile Boolean\r\nand nil literals to bytecode. Moving down the execution pipeline, we reach the\r\ninterpreter."]}),"\n",(0,r.jsxs)(n.aside,{name:"switch",children:["\n",(0,r.jsx)(n.p,{children:"We could have used separate parser functions for each literal and saved\r\nourselves a switch but that felt needlessly verbose to me. I think it's mostly a\r\nmatter of taste."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-literals (5 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"This is pretty self-explanatory. Each instruction summons the appropriate value\r\nand pushes it onto the stack. We shouldn't forget our disassembler either."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-literals (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"With this in place, we can run this Earth-shattering program:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Except that when the interpreter tries to print the result, it blows up. We need\r\nto extend ",(0,r.jsx)(n.code,{children:"printValue()"})," to handle the new types too:"]}),"\n",(0,r.jsx)(n.p,{children:"^code print-value (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["There we go! Now we have some new types. They just aren't very useful yet. Aside\r\nfrom the literals, you can't really ",(0,r.jsx)(n.em,{children:"do"})," anything with them. It will be a while\r\nbefore ",(0,r.jsx)(n.code,{children:"nil"})," comes into play, but we can start putting Booleans to work in the\r\nlogical operators."]}),"\n",(0,r.jsx)(n.h3,{id:"logical-not-and-falsiness",children:"Logical not and falsiness"}),"\n",(0,r.jsx)(n.p,{children:"The simplest logical operator is our old exclamatory friend unary not."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'print !true; // "false"\n'})}),"\n",(0,r.jsx)(n.p,{children:"This new operation gets a new instruction."}),"\n",(0,r.jsx)(n.p,{children:"^code not-op (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We can reuse the ",(0,r.jsx)(n.code,{children:"unary()"})," parser function we wrote for unary negation to\r\ncompile a not expression. We just need to slot it into the parsing table."]}),"\n",(0,r.jsx)(n.p,{children:"^code table-not (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Because I knew we were going to do this, the ",(0,r.jsx)(n.code,{children:"unary()"})," function already has a\r\nswitch on the token type to figure out which bytecode instruction to output. We\r\nmerely add another case."]}),"\n",(0,r.jsx)(n.p,{children:"^code compile-not (1 before, 3 after)"}),"\n",(0,r.jsx)(n.p,{children:"That's it for the front end. Let's head over to the VM and conjure this\r\ninstruction into life."}),"\n",(0,r.jsx)(n.p,{children:"^code op-not (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Like our previous unary operator, it pops the one operand, performs the\r\noperation, and pushes the result. And, as we did there, we have to worry about\r\ndynamic typing. Taking the logical not of ",(0,r.jsx)(n.code,{children:"true"})," is easy, but there's nothing\r\npreventing an unruly programmer from writing something like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"print !nil;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For unary minus, we made it an error to negate anything that isn't a ",(0,r.jsx)(n.span,{name:"negate",children:"number"}),". But Lox, like most scripting languages, is more\r\npermissive when it comes to ",(0,r.jsx)(n.code,{children:"!"}),' and other contexts where a Boolean is expected.\r\nThe rule for how other types are handled is called "falsiness", and we implement\r\nit here:']}),"\n",(0,r.jsxs)(n.aside,{name:"negate",children:["\n",(0,r.jsxs)(n.p,{children:["Now I can't help but try to figure out what it would mean to negate other types\r\nof values. ",(0,r.jsx)(n.code,{children:"nil"})," is probably its own negation, sort of like a weird pseudo-zero.\r\nNegating a string could, uh, reverse it?"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code is-falsey"}),"\n",(0,r.jsxs)(n.p,{children:["Lox follows Ruby in that ",(0,r.jsx)(n.code,{children:"nil"})," and ",(0,r.jsx)(n.code,{children:"false"})," are falsey and every other value\r\nbehaves like ",(0,r.jsx)(n.code,{children:"true"}),". We've got a new instruction we can generate, so we also\r\nneed to be able to ",(0,r.jsx)(n.em,{children:"un"}),"generate it in the disassembler."]}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-not (2 before, 1 after)"}),"\n",(0,r.jsx)(n.h3,{id:"equality-and-comparison-operators",children:"Equality and comparison operators"}),"\n",(0,r.jsxs)(n.p,{children:["That wasn't too bad. Let's keep the momentum going and knock out the equality\r\nand comparison operators too: ",(0,r.jsx)(n.code,{children:"=="}),", ",(0,r.jsx)(n.code,{children:"!="}),", ",(0,r.jsx)(n.code,{children:"<"}),", ",(0,r.jsx)(n.code,{children:">"}),", ",(0,r.jsx)(n.code,{children:"<="}),", and ",(0,r.jsx)(n.code,{children:">="}),". That covers\r\nall of the operators that return Boolean results except the logical operators\r\n",(0,r.jsx)(n.code,{children:"and"})," and ",(0,r.jsx)(n.code,{children:"or"}),". Since those need to short-circuit (basically do a little\r\ncontrol flow) we aren't ready for them yet."]}),"\n",(0,r.jsx)(n.p,{children:"Here are the new instructions for those operators:"}),"\n",(0,r.jsx)(n.p,{children:"^code comparison-ops (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Wait, only three? What about ",(0,r.jsx)(n.code,{children:"!="}),", ",(0,r.jsx)(n.code,{children:"<="}),", and ",(0,r.jsx)(n.code,{children:">="}),"? We could create instructions\r\nfor those too. Honestly, the VM would execute faster if we did, so we ",(0,r.jsx)(n.em,{children:"should"}),"\r\ndo that if the goal is performance."]}),"\n",(0,r.jsx)(n.p,{children:"But my main goal is to teach you about bytecode compilers. I want you to start\r\ninternalizing the idea that the bytecode instructions don't need to closely\r\nfollow the user's source code. The VM has total freedom to use whatever\r\ninstruction set and code sequences it wants as long as they have the right\r\nuser-visible behavior."}),"\n",(0,r.jsxs)(n.p,{children:["The expression ",(0,r.jsx)(n.code,{children:"a != b"})," has the same semantics as ",(0,r.jsx)(n.code,{children:"!(a == b)"}),", so the compiler\r\nis free to compile the former as if it were the latter. Instead of a dedicated\r\n",(0,r.jsx)(n.code,{children:"OP_NOT_EQUAL"})," instruction, it can output an ",(0,r.jsx)(n.code,{children:"OP_EQUAL"})," followed by an ",(0,r.jsx)(n.code,{children:"OP_NOT"}),".\r\nLikewise, ",(0,r.jsx)(n.code,{children:"a <= b"})," is the ",(0,r.jsx)(n.span,{name:"same",children:"same"})," as ",(0,r.jsx)(n.code,{children:"!(a > b)"})," and ",(0,r.jsx)(n.code,{children:"a >= b"})," is ",(0,r.jsx)(n.code,{children:"!(a < b)"}),". Thus, we only need three new instructions."]}),"\n",(0,r.jsxs)(n.aside,{name:"same",className:"bottom",children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Is"})," ",(0,r.jsx)(n.code,{children:"a <= b"})," always the same as ",(0,r.jsx)(n.code,{children:"!(a > b)"}),"? According to ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/IEEE_754",children:"IEEE 754"}),", all\r\ncomparison operators return false when an operand is NaN. That means ",(0,r.jsx)(n.code,{children:"NaN <= 1"}),"\r\nis false and ",(0,r.jsx)(n.code,{children:"NaN > 1"})," is also false. But our desugaring assumes the latter is\r\nalways the negation of the former."]}),"\n",(0,r.jsx)(n.p,{children:"For the book, we won't get hung up on this, but these kinds of details will\r\nmatter in your real language implementations."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Over in the parser, though, we do have six new operators to slot into the parse\r\ntable. We use the same ",(0,r.jsx)(n.code,{children:"binary()"})," parser function from before. Here's the row\r\nfor ",(0,r.jsx)(n.code,{children:"!="}),":"]}),"\n",(0,r.jsx)(n.p,{children:"^code table-equal (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The remaining five operators are a little farther down in the table."}),"\n",(0,r.jsx)(n.p,{children:"^code table-comparisons (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Inside ",(0,r.jsx)(n.code,{children:"binary()"})," we already have a switch to generate the right bytecode for\r\neach token type. We add cases for the six new operators."]}),"\n",(0,r.jsx)(n.p,{children:"^code comparison-operators (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"=="}),", ",(0,r.jsx)(n.code,{children:"<"}),", and ",(0,r.jsx)(n.code,{children:">"})," operators output a single instruction. The others output\r\na pair of instructions, one to evalute the inverse operation, and then an\r\n",(0,r.jsx)(n.code,{children:"OP_NOT"})," to flip the result. Six operators for the price of three instructions!"]}),"\n",(0,r.jsx)(n.p,{children:"That means over in the VM, our job is simpler. Equality is the most general\r\noperation."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-equal (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["You can evaluate ",(0,r.jsx)(n.code,{children:"=="})," on any pair of objects, even objects of different types.\r\nThere's enough complexity that it makes sense to shunt that logic over to a\r\nseparate function. That function always returns a C ",(0,r.jsx)(n.code,{children:"bool"}),", so we can safely\r\nwrap the result in a ",(0,r.jsx)(n.code,{children:"BOOL_VAL"}),'. The function relates to Values, so it lives\r\nover in the "value" module.']}),"\n",(0,r.jsx)(n.p,{children:"^code values-equal-h (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And here's the implementation:"}),"\n",(0,r.jsx)(n.p,{children:"^code values-equal"}),"\n",(0,r.jsxs)(n.p,{children:["First, we check the types. If the Values have ",(0,r.jsx)(n.span,{name:"equal",children:"different"})," types, they are definitely not equal. Otherwise,\r\nwe unwrap the two Values and compare them directly."]}),"\n",(0,r.jsxs)(n.aside,{name:"equal",children:["\n",(0,r.jsxs)(n.p,{children:['Some languages have "implicit conversions" where values of different types may\r\nbe considered equal if one can be converted to the other\'s type. For example,\r\nthe number 0 is equivalent to the string "0" in JavaScript. This looseness was a\r\nlarge enough source of pain that JS added a separate "strict equality" operator,\r\n',(0,r.jsx)(n.code,{children:"==="}),"."]}),"\n",(0,r.jsx)(n.p,{children:'PHP considers the strings "1" and "01" to be equivalent because both can be\r\nconverted to equivalent numbers, though the ultimate reason is because PHP was\r\ndesigned by a Lovecraftian eldritch god to destroy the mind.'}),"\n",(0,r.jsx)(n.p,{children:"Most dynamically typed languages that have separate integer and floating-point\r\nnumber types consider values of different number types equal if the numeric\r\nvalues are the same (so, say, 1.0 is equal to 1), though even that seemingly\r\ninnocuous convenience can bite the unwary."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For each value type, we have a separate case that handles comparing the value\r\nitself. Given how similar the cases are, you might wonder why we can't simply\r\n",(0,r.jsx)(n.code,{children:"memcmp()"})," the two Value structs and be done with it. The problem is that\r\nbecause of padding and different-sized union fields, a Value contains unused\r\nbits. C gives no guarantee about what is in those, so it's possible that two\r\nequal Values actually differ in memory that isn't used."]}),"\n",(0,r.jsx)(n.img,{src:"image/types-of-values/memcmp.png",alt:"The memory respresentations of two equal values that differ in unused bytes."}),"\n",(0,r.jsx)(n.p,{children:"(You wouldn't believe how much pain I went through before learning this fact.)"}),"\n",(0,r.jsx)(n.p,{children:"Anyway, as we add more types to clox, this function will grow new cases. For\r\nnow, these three are sufficient. The other comparison operators are easier since\r\nthey work only on numbers."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-comparison (3 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We already extended the ",(0,r.jsx)(n.code,{children:"BINARY_OP"})," macro to handle operators that return\r\nnon-numeric types. Now we get to use that. We pass in ",(0,r.jsx)(n.code,{children:"BOOL_VAL"})," since the\r\nresult value type is Boolean. Otherwise, it's no different from plus or minus."]}),"\n",(0,r.jsx)(n.p,{children:"As always, the coda to today's aria is disassembling the new instructions."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-comparison (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"With that, our numeric calculator has become something closer to a general\r\nexpression evaluator. Fire up clox and type in:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"!(5 - 4 > 3 * 2 == !nil)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["OK, I'll admit that's maybe not the most ",(0,r.jsx)(n.em,{children:"useful"})," expression, but we're making\r\nprogress. We have one missing built-in type with its own literal form: strings.\r\nThose are much more complex because strings can vary in size. That tiny\r\ndifference turns out to have implications so large that we give strings ",(0,r.jsx)(n.a,{href:"strings.html",children:"their\r\nvery own chapter"}),"."]}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"We could reduce our binary operators even further than we did here. Which\r\nother instructions can you eliminate, and how would the compiler cope with\r\ntheir absence?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Conversely, we can improve the speed of our bytecode VM by adding more\r\nspecific instructions that correspond to higher-level operations. What\r\ninstructions would you define to speed up the kind of user code we added\r\nsupport for in this chapter?"}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(6540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);