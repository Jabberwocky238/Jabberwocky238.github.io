"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[9983],{7645:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var r=s(4848),t=s(8453);const a={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/inheritance",title:"inheritance",description:"Once we were blobs in the sea, and then fishes, and then lizards and rats and",source:"@site/docs/Craftinginterpreters/not-translated-yet/inheritance.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/inheritance",permalink:"/docs/Craftinginterpreters/not-translated-yet/inheritance",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/inheritance.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"hash-tables",permalink:"/docs/Craftinginterpreters/not-translated-yet/hash-tables"},next:{title:"jumping-back-and-forth",permalink:"/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth"}},l={},h=[{value:"Superclasses and Subclasses",id:"superclasses-and-subclasses",level:2},{value:"Inheriting Methods",id:"inheriting-methods",level:2},{value:"Calling Superclass Methods",id:"calling-superclass-methods",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Semantics",id:"semantics",level:3},{value:"Invalid uses of super",id:"invalid-uses-of-super",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Challenges",id:"challenges",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Once we were blobs in the sea, and then fishes, and then lizards and rats and\r\nthen monkeys, and hundreds of things in between. This hand was once a fin,\r\nthis hand once had claws! In my human mouth I have the pointy teeth of a wolf\r\nand the chisel teeth of a rabbit and the grinding teeth of a cow! Our blood is\r\nas salty as the sea we used to live in! When we're frightened, the hair on our\r\nskin stands up, just like it did when we had fur. We are history! Everything\r\nwe've ever been on the way to becoming us, we still are."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["Terry Pratchett, ",(0,r.jsx)(n.em,{children:"A Hat Full of Sky"})]})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Can you believe it? We've reached the last chapter of ",(0,r.jsx)(n.a,{href:"a-tree-walk-interpreter.html",children:"Part II"}),". We're almost\r\ndone with our first Lox interpreter. The ",(0,r.jsx)(n.a,{href:"classes.html",children:"previous chapter"})," was a big ball of\r\nintertwined object-orientation features. I couldn't separate those from each\r\nother, but I did manage to untangle one piece. In this chapter, we'll finish\r\noff Lox's class support by adding inheritance."]}),"\n",(0,r.jsxs)(n.p,{children:["Inheritance appears in object-oriented languages all the way back to the ",(0,r.jsx)(n.span,{name:"inherited",children:"first"})," one, ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Simula",children:"Simula"}),". Early on, Kristen Nygaard and\r\nOle-Johan Dahl noticed commonalities across classes in the simulation programs\r\nthey wrote. Inheritance gave them a way to reuse the code for those similar\r\nparts."]}),"\n",(0,r.jsxs)(n.aside,{name:"inherited",children:["\n",(0,r.jsxs)(n.p,{children:["You could say all those other languages ",(0,r.jsx)(n.em,{children:"inherited"})," it from Simula. Hey-ooo!\r\nI'll, uh, see myself out."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"superclasses-and-subclasses",children:"Superclasses and Subclasses"}),"\n",(0,r.jsxs)(n.p,{children:['Given that the concept is "inheritance", you would hope they would pick a\r\nconsistent metaphor and call them "parent" and "child" classes, but that would\r\nbe too easy. Way back when, C. A. R. Hoare coined the term "',(0,r.jsx)(n.span,{name:"subclass",children:"subclass"}),'" to refer to a record type that refines another\r\ntype. Simula borrowed that term to refer to a ',(0,r.jsx)(n.em,{children:"class"}),' that inherits from\r\nanother. I don\'t think it was until Smalltalk came along that someone flipped\r\nthe Latin prefix to get "superclass" to refer to the other side of the\r\nrelationship. From C++, you also hear "base" and "derived" classes. I\'ll mostly\r\nstick with "superclass" and "subclass".']}),"\n",(0,r.jsxs)(n.aside,{name:"subclass",children:["\n",(0,r.jsx)(n.p,{children:'"Super-" and "sub-" mean "above" and "below" in Latin, respectively. Picture an\r\ninheritance tree like a family tree with the root at the top -- subclasses are\r\nbelow their superclasses on the diagram. More generally, "sub-" refers to things\r\nthat refine or are contained by some more general concept. In zoology, a\r\nsubclass is a finer categorization of a larger class of living things.'}),"\n",(0,r.jsx)(n.p,{children:'In set theory, a subset is contained by a larger superset which has all of the\r\nelements of the subset and possibly more. Set theory and programming languages\r\nmeet each other in type theory. There, you have "supertypes" and "subtypes".'}),"\n",(0,r.jsx)(n.p,{children:"In statically typed object-oriented languages, a subclass is also often a\r\nsubtype of its superclass. Say we have a Doughnut superclass and a BostonCream\r\nsubclass. Every BostonCream is also an instance of Doughnut, but there may be\r\ndoughnut objects that are not BostonCreams (like Crullers)."}),"\n",(0,r.jsx)(n.p,{children:"Think of a type as the set of all values of that type. The set of all Doughnut\r\ninstances contains the set of all BostonCream instances since every BostonCream\r\nis also a Doughnut. So BostonCream is a subclass, and a subtype, and its\r\ninstances are a subset. It all lines up."}),"\n",(0,r.jsx)(n.img,{src:"image/inheritance/doughnuts.png",alt:"Boston cream <: doughnut."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Our first step towards supporting inheritance in Lox is a way to specify a\r\nsuperclass when declaring a class. There's a lot of variety in syntax for this.\r\nC++ and C# place a ",(0,r.jsx)(n.code,{children:":"})," after the subclass's name, followed by the superclass\r\nname. Java uses ",(0,r.jsx)(n.code,{children:"extends"})," instead of the colon. Python puts the superclass(es)\r\nin parentheses after the class name. Simula puts the superclass's name ",(0,r.jsx)(n.em,{children:"before"}),"\r\nthe ",(0,r.jsx)(n.code,{children:"class"})," keyword."]}),"\n",(0,r.jsxs)(n.p,{children:["This late in the game, I'd rather not add a new reserved word or token to the\r\nlexer. We don't have ",(0,r.jsx)(n.code,{children:"extends"})," or even ",(0,r.jsx)(n.code,{children:":"}),", so we'll follow Ruby and use a\r\nless-than sign (",(0,r.jsx)(n.code,{children:"<"}),")."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"class Doughnut {\r\n  // General doughnut stuff...\r\n}\r\n\r\nclass BostonCream < Doughnut {\r\n  // Boston Cream-specific stuff...\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To work this into the grammar, we add a new optional clause in our existing\r\n",(0,r.jsx)(n.code,{children:"classDecl"})," rule."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:'classDecl      \u2192 "class" IDENTIFIER ( "<" IDENTIFIER )?\r\n                 "{" function* "}" ;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["After the class name, you can have a ",(0,r.jsx)(n.code,{children:"<"})," followed by the superclass's name. The\r\nsuperclass clause is optional because you don't ",(0,r.jsx)(n.em,{children:"have"}),' to have a superclass.\r\nUnlike some other object-oriented languages like Java, Lox has no root "Object"\r\nclass that everything inherits from, so when you omit the superclass clause, the\r\nclass has ',(0,r.jsx)(n.em,{children:"no"})," superclass, not even an implicit one."]}),"\n",(0,r.jsx)(n.p,{children:"We want to capture this new syntax in the class declaration's AST node."}),"\n",(0,r.jsx)(n.p,{children:"^code superclass-ast (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"You might be surprised that we store the superclass name as an Expr.Variable,\r\nnot a Token. The grammar restricts the superclass clause to a single identifier,\r\nbut at runtime, that identifier is evaluated as a variable access. Wrapping the\r\nname in an Expr.Variable early on in the parser gives us an object that the\r\nresolver can hang the resolution information off of."}),"\n",(0,r.jsx)(n.p,{children:"The new parser code follows the grammar directly."}),"\n",(0,r.jsx)(n.p,{children:"^code parse-superclass (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Once we've (possibly) parsed a superclass declaration, we store it in the AST."}),"\n",(0,r.jsx)(n.p,{children:"^code construct-class-ast (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["If we didn't parse a superclass clause, the superclass expression will be\r\n",(0,r.jsx)(n.code,{children:"null"}),". We'll have to make sure the later passes check for that. The first of\r\nthose is the resolver."]}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-superclass (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"The class declaration AST node has a new subexpression, so we traverse into and\r\nresolve that. Since classes are usually declared at the top level, the\r\nsuperclass name will most likely be a global variable, so this doesn't usually\r\ndo anything useful. However, Lox allows class declarations even inside blocks,\r\nso it's possible the superclass name refers to a local variable. In that case,\r\nwe need to make sure it's resolved."}),"\n",(0,r.jsx)(n.p,{children:"Because even well-intentioned programmers sometimes write weird code, there's a\r\nsilly edge case we need to worry about while we're in here. Take a look at this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"class Oops < Oops {}\n"})}),"\n",(0,r.jsx)(n.p,{children:"There's no way this will do anything useful, and if we let the runtime try to\r\nrun this, it will break the expectation the interpreter has about there not\r\nbeing cycles in the inheritance chain. The safest thing is to detect this case\r\nstatically and report it as an error."}),"\n",(0,r.jsx)(n.p,{children:"^code inherit-self (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Assuming the code resolves without error, the AST travels to the interpreter."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-superclass (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"If the class has a superclass expression, we evaluate it. Since that could\r\npotentially evaluate to some other kind of object, we have to check at runtime\r\nthat the thing we want to be the superclass is actually a class. Bad things\r\nwould happen if we allowed code like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var NotAClass = "I am totally not a class";\r\n\r\nclass Subclass < NotAClass {} // ?!\n'})}),"\n",(0,r.jsx)(n.p,{children:"Assuming that check passes, we continue on. Executing a class declaration turns\r\nthe syntactic representation of a class -- its AST node -- into its runtime\r\nrepresentation, a LoxClass object. We need to plumb the superclass through to\r\nthat too. We pass the superclass to the constructor."}),"\n",(0,r.jsx)(n.p,{children:"^code interpreter-construct-class (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The constructor stores it in a field."}),"\n",(0,r.jsx)(n.p,{children:"^code lox-class-constructor (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Which we declare here:"}),"\n",(0,r.jsx)(n.p,{children:"^code lox-class-superclass-field (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["With that, we can define classes that are subclasses of other classes. Now, what\r\ndoes having a superclass actually ",(0,r.jsx)(n.em,{children:"do?"})]}),"\n",(0,r.jsx)(n.h2,{id:"inheriting-methods",children:"Inheriting Methods"}),"\n",(0,r.jsxs)(n.p,{children:["Inheriting from another class means that everything that's ",(0,r.jsx)(n.span,{name:"liskov",children:"true"})," of the superclass should be true, more or less, of the\r\nsubclass. In statically typed languages, that carries a lot of implications. The\r\nsub",(0,r.jsx)(n.em,{children:"class"})," must also be a sub",(0,r.jsx)(n.em,{children:"type"}),", and the memory layout is controlled so that\r\nyou can pass an instance of a subclass to a function expecting a superclass and\r\nit can still access the inherited fields correctly."]}),"\n",(0,r.jsxs)(n.aside,{name:"liskov",children:["\n",(0,r.jsxs)(n.p,{children:["A fancier name for this hand-wavey guideline is the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle",children:(0,r.jsx)(n.em,{children:"Liskov substitution\r\nprinciple"})}),". Barbara Liskov introduced it in a keynote during the\r\nformative period of object-oriented programming."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Lox is a dynamically typed language, so our requirements are much simpler.\r\nBasically, it means that if you can call some method on an instance of the\r\nsuperclass, you should be able to call that method when given an instance of the\r\nsubclass. In other words, methods are inherited from the superclass."}),"\n",(0,r.jsx)(n.p,{children:"This lines up with one of the goals of inheritance -- to give users a way to\r\nreuse code across classes. Implementing this in our interpreter is\r\nastonishingly easy."}),"\n",(0,r.jsx)(n.p,{children:"^code find-method-recurse-superclass (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That's literally all there is to it. When we are looking up a method on an\r\ninstance, if we don't find it on the instance's class, we recurse up through the\r\nsuperclass chain and look there. Give it a try:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'class Doughnut {\r\n  cook() {\r\n    print "Fry until golden brown.";\r\n  }\r\n}\r\n\r\nclass BostonCream < Doughnut {}\r\n\r\nBostonCream().cook();\n'})}),"\n",(0,r.jsx)(n.p,{children:"There we go, half of our inheritance features are complete with only three lines\r\nof Java code."}),"\n",(0,r.jsx)(n.h2,{id:"calling-superclass-methods",children:"Calling Superclass Methods"}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.code,{children:"findMethod()"})," we look for a method on the current class ",(0,r.jsx)(n.em,{children:"before"})," walking up\r\nthe superclass chain. If a method with the same name exists in both the subclass\r\nand the superclass, the subclass one takes precedence or ",(0,r.jsx)(n.strong,{children:"overrides"})," the\r\nsuperclass method. Sort of like how variables in inner scopes shadow outer ones."]}),"\n",(0,r.jsxs)(n.p,{children:["That's great if the subclass wants to ",(0,r.jsx)(n.em,{children:"replace"})," some superclass behavior\r\ncompletely. But, in practice, subclasses often want to ",(0,r.jsx)(n.em,{children:"refine"})," the superclass's\r\nbehavior. They want to do a little work specific to the subclass, but also\r\nexecute the original superclass behavior too."]}),"\n",(0,r.jsxs)(n.p,{children:['However, since the subclass has overridden the method, there\'s no way to refer\r\nto the original one. If the subclass method tries to call it by name, it will\r\njust recursively hit its own override. We need a way to say "Call this method,\r\nbut look for it directly on my superclass and ignore my override". Java uses\r\n',(0,r.jsx)(n.code,{children:"super"})," for this, and we'll use that same syntax in Lox. Here is an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'class Doughnut {\r\n  cook() {\r\n    print "Fry until golden brown.";\r\n  }\r\n}\r\n\r\nclass BostonCream < Doughnut {\r\n  cook() {\r\n    super.cook();\r\n    print "Pipe full of custard and coat with chocolate.";\r\n  }\r\n}\r\n\r\nBostonCream().cook();\n'})}),"\n",(0,r.jsx)(n.p,{children:"If you run this, it should print:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Fry until golden brown.\r\nPipe full of custard and coat with chocolate.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We have a new expression form. The ",(0,r.jsx)(n.code,{children:"super"})," keyword, followed by a dot and an\r\nidentifier, looks for a method with that name. Unlike calls on ",(0,r.jsx)(n.code,{children:"this"}),", the search\r\nstarts at the superclass."]}),"\n",(0,r.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsxs)(n.p,{children:["With ",(0,r.jsx)(n.code,{children:"this"}),", the keyword works sort of like a magic variable, and the expression\r\nis that one lone token. But with ",(0,r.jsx)(n.code,{children:"super"}),", the subsequent ",(0,r.jsx)(n.code,{children:"."})," and property name\r\nare inseparable parts of the ",(0,r.jsx)(n.code,{children:"super"})," expression. You can't have a bare ",(0,r.jsx)(n.code,{children:"super"}),"\r\ntoken all by itself."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"print super; // Syntax error.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So the new clause we add to the ",(0,r.jsx)(n.code,{children:"primary"})," rule in our grammar includes the\r\nproperty access as well."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:'primary        \u2192 "true" | "false" | "nil" | "this"\r\n               | NUMBER | STRING | IDENTIFIER | "(" expression ")"\r\n               | "super" "." IDENTIFIER ;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Typically, a ",(0,r.jsx)(n.code,{children:"super"})," expression is used for a method call, but, as with regular\r\nmethods, the argument list is ",(0,r.jsx)(n.em,{children:"not"})," part of the expression. Instead, a super\r\n",(0,r.jsx)(n.em,{children:"call"})," is a super ",(0,r.jsx)(n.em,{children:"access"})," followed by a function call. Like other method calls,\r\nyou can get a handle to a superclass method and invoke it separately."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"var method = super.cook;\r\nmethod();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So the ",(0,r.jsx)(n.code,{children:"super"})," expression itself contains only the token for the ",(0,r.jsx)(n.code,{children:"super"})," keyword\r\nand the name of the method being looked up. The corresponding ",(0,r.jsx)(n.span,{name:"super-ast",children:"syntax tree node"})," is thus:"]}),"\n",(0,r.jsx)(n.p,{children:"^code super-expr (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.aside,{name:"super-ast",children:["\n",(0,r.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,r.jsx)(n.a,{href:"appendix-ii.html#super-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Following the grammar, the new parsing code goes inside our existing ",(0,r.jsx)(n.code,{children:"primary()"}),"\r\nmethod."]}),"\n",(0,r.jsx)(n.p,{children:"^code parse-super (2 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["A leading ",(0,r.jsx)(n.code,{children:"super"})," keyword tells us we've hit a ",(0,r.jsx)(n.code,{children:"super"})," expression. After that we\r\nconsume the expected ",(0,r.jsx)(n.code,{children:"."})," and method name."]}),"\n",(0,r.jsx)(n.h3,{id:"semantics",children:"Semantics"}),"\n",(0,r.jsxs)(n.p,{children:["Earlier, I said a ",(0,r.jsx)(n.code,{children:"super"}),' expression starts the method lookup from "the\r\nsuperclass", but ',(0,r.jsx)(n.em,{children:"which"})," superclass? The na\xefve answer is the superclass of\r\n",(0,r.jsx)(n.code,{children:"this"}),", the object the surrounding method was called on. That coincidentally\r\nproduces the right behavior in a lot of cases, but that's not actually correct.\r\nGaze upon:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'class A {\r\n  method() {\r\n    print "A method";\r\n  }\r\n}\r\n\r\nclass B < A {\r\n  method() {\r\n    print "B method";\r\n  }\r\n\r\n  test() {\r\n    super.method();\r\n  }\r\n}\r\n\r\nclass C < B {}\r\n\r\nC().test();\n'})}),"\n",(0,r.jsxs)(n.p,{children:['Translate this program to Java, C#, or C++ and it will print "A method", which\r\nis what we want Lox to do too. When this program runs, inside the body of\r\n',(0,r.jsx)(n.code,{children:"test()"}),", ",(0,r.jsx)(n.code,{children:"this"})," is an instance of C. The superclass of C is B, but that is\r\n",(0,r.jsx)(n.em,{children:"not"})," where the lookup should start. If it did, we would hit B's ",(0,r.jsx)(n.code,{children:"method()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, lookup should start on the superclass of ",(0,r.jsxs)(n.em,{children:["the class containing the\r\n",(0,r.jsx)(n.code,{children:"super"})," expression"]}),". In this case, since ",(0,r.jsx)(n.code,{children:"test()"})," is defined inside B, the\r\n",(0,r.jsx)(n.code,{children:"super"})," expression inside it should start the lookup on ",(0,r.jsx)(n.em,{children:"B"}),"\u2019s superclass\r\n-- A."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.span,{name:"flow"})}),"\n",(0,r.jsx)(n.img,{src:"image/inheritance/classes.png",alt:"The call chain flowing through the classes."}),"\n",(0,r.jsxs)(n.aside,{name:"flow",children:["\n",(0,r.jsx)(n.p,{children:"The execution flow looks something like this:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We call ",(0,r.jsx)(n.code,{children:"test()"})," on an instance of C."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["That enters the ",(0,r.jsx)(n.code,{children:"test()"})," method inherited from B. That calls\r\n",(0,r.jsx)(n.code,{children:"super.method()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The superclass of B is A, so that chains to ",(0,r.jsx)(n.code,{children:"method()"}),' on A, and the program\r\nprints "A method".']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Thus, in order to evaluate a ",(0,r.jsx)(n.code,{children:"super"})," expression, we need access to the\r\nsuperclass of the class definition surrounding the call. Alack and alas, at the\r\npoint in the interpreter where we are executing a ",(0,r.jsx)(n.code,{children:"super"})," expression, we don't\r\nhave that easily available."]}),"\n",(0,r.jsxs)(n.p,{children:["We ",(0,r.jsx)(n.em,{children:"could"})," add a field to LoxFunction to store a reference to the LoxClass that\r\nowns that method. The interpreter would keep a reference to the\r\ncurrently executing LoxFunction so that we could look it up later when we hit a\r\n",(0,r.jsx)(n.code,{children:"super"})," expression. From there, we'd get the LoxClass of the method, then its\r\nsuperclass."]}),"\n",(0,r.jsxs)(n.p,{children:["That's a lot of plumbing. In the ",(0,r.jsx)(n.a,{href:"classes.html",children:"last chapter"}),", we had a similar problem when\r\nwe needed to add support for ",(0,r.jsx)(n.code,{children:"this"}),". In that case, we used our existing\r\nenvironment and closure mechanism to store a reference to the current object.\r\nCould we do something similar for storing the superclass",(0,r.jsx)(n.span,{name:"rhetorical",children:"?"})," Well, I probably wouldn't be talking about it if the\r\nanswer was no, so... yes."]}),"\n",(0,r.jsxs)(n.aside,{name:"rhetorical",children:["\n",(0,r.jsx)(n.p,{children:"Does anyone even like rhetorical questions?"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["One important difference is that we bound ",(0,r.jsx)(n.code,{children:"this"})," when the method was ",(0,r.jsx)(n.em,{children:"accessed"}),".\r\nThe same method can be called on different instances and each needs its own\r\n",(0,r.jsx)(n.code,{children:"this"}),". With ",(0,r.jsx)(n.code,{children:"super"})," expressions, the superclass is a fixed property of the\r\n",(0,r.jsx)(n.em,{children:"class declaration itself"}),". Every time you evaluate some ",(0,r.jsx)(n.code,{children:"super"})," expression, the\r\nsuperclass is always the same."]}),"\n",(0,r.jsxs)(n.p,{children:["That means we can create the environment for the superclass once, when the class\r\ndefinition is executed. Immediately before we define the methods, we make a new\r\nenvironment to bind the class's superclass to the name ",(0,r.jsx)(n.code,{children:"super"}),"."]}),"\n",(0,r.jsx)(n.img,{src:"image/inheritance/superclass.png",alt:"The superclass environment."}),"\n",(0,r.jsxs)(n.p,{children:["When we create the LoxFunction runtime representation for each method, that is\r\nthe environment they will capture in their closure. Later, when a method is\r\ninvoked and ",(0,r.jsx)(n.code,{children:"this"})," is bound, the superclass environment becomes the parent for\r\nthe method's environment, like so:"]}),"\n",(0,r.jsx)(n.img,{src:"image/inheritance/environments.png",alt:"The environment chain including the superclass environment."}),"\n",(0,r.jsx)(n.p,{children:"That's a lot of machinery, but we'll get through it a step at a time. Before we\r\ncan get to creating the environment at runtime, we need to handle the\r\ncorresponding scope chain in the resolver."}),"\n",(0,r.jsx)(n.p,{children:"^code begin-super-scope (2 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"If the class declaration has a superclass, then we create a new scope\r\nsurrounding all of its methods. In that scope, we define the name \"super\". Once\r\nwe're done resolving the class's methods, we discard that scope."}),"\n",(0,r.jsx)(n.p,{children:"^code end-super-scope (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["It's a minor optimization, but we only create the superclass environment if the\r\nclass actually ",(0,r.jsx)(n.em,{children:"has"})," a superclass. There's no point creating it when there isn't\r\na superclass since there'd be no superclass to store in it anyway."]}),"\n",(0,r.jsxs)(n.p,{children:['With "super" defined in a scope chain, we are able to resolve the ',(0,r.jsx)(n.code,{children:"super"}),"\r\nexpression itself."]}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-super-expr"}),"\n",(0,r.jsxs)(n.p,{children:["We resolve the ",(0,r.jsx)(n.code,{children:"super"})," token exactly as if it were a variable. The resolution\r\nstores the number of hops along the environment chain that the interpreter needs\r\nto walk to find the environment where the superclass is stored."]}),"\n",(0,r.jsx)(n.p,{children:"This code is mirrored in the interpreter. When we evaluate a subclass\r\ndefinition, we create a new environment."}),"\n",(0,r.jsx)(n.p,{children:"^code begin-superclass-environment (6 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:'Inside that environment, we store a reference to the superclass -- the actual\r\nLoxClass object for the superclass which we have now that we are in the runtime.\r\nThen we create the LoxFunctions for each method. Those will capture the current\r\nenvironment -- the one where we just bound "super" -- as their closure, holding\r\non to the superclass like we need. Once that\'s done, we pop the environment.'}),"\n",(0,r.jsx)(n.p,{children:"^code end-superclass-environment (2 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We're ready to interpret ",(0,r.jsx)(n.code,{children:"super"})," expressions themselves. There are a few moving\r\nparts, so we'll build this method up in pieces."]}),"\n",(0,r.jsx)(n.p,{children:"^code interpreter-visit-super"}),"\n",(0,r.jsx)(n.p,{children:"First, the work we've been leading up to. We look up the surrounding class's\r\nsuperclass by looking up \"super\" in the proper environment."}),"\n",(0,r.jsxs)(n.p,{children:["When we access a method, we also need to bind ",(0,r.jsx)(n.code,{children:"this"})," to the object the method is\r\naccessed from. In an expression like ",(0,r.jsx)(n.code,{children:"doughnut.cook"}),", the object is whatever we\r\nget from evaluating ",(0,r.jsx)(n.code,{children:"doughnut"}),". In a ",(0,r.jsx)(n.code,{children:"super"})," expression like ",(0,r.jsx)(n.code,{children:"super.cook"}),", the\r\ncurrent object is implicitly the ",(0,r.jsx)(n.em,{children:"same"})," current object that we're using. In\r\nother words, ",(0,r.jsx)(n.code,{children:"this"}),". Even though we are looking up the ",(0,r.jsx)(n.em,{children:"method"})," on the\r\nsuperclass, the ",(0,r.jsx)(n.em,{children:"instance"})," is still ",(0,r.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Unfortunately, inside the ",(0,r.jsx)(n.code,{children:"super"})," expression, we don't have a convenient node\r\nfor the resolver to hang the number of hops to ",(0,r.jsx)(n.code,{children:"this"}),' on. Fortunately, we do\r\ncontrol the layout of the environment chains. The environment where "this" is\r\nbound is always right inside the environment where we store "super".']}),"\n",(0,r.jsx)(n.p,{children:"^code super-find-this (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:['Offsetting the distance by one looks up "this" in that inner environment. I\r\nadmit this isn\'t the most ',(0,r.jsx)(n.span,{name:"elegant",children:"elegant"})," code, but it\r\nworks."]}),"\n",(0,r.jsxs)(n.aside,{name:"elegant",children:["\n",(0,r.jsx)(n.p,{children:'Writing a book that includes every single line of code for a program means I\r\ncan\'t hide the hacks by leaving them as an "exercise for the reader".'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Now we're ready to look up and bind the method, starting at the superclass."}),"\n",(0,r.jsx)(n.p,{children:"^code super-find-method (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This is almost exactly like the code for looking up a method of a get\r\nexpression, except that we call ",(0,r.jsx)(n.code,{children:"findMethod()"})," on the superclass instead of on\r\nthe class of the current object."]}),"\n",(0,r.jsxs)(n.p,{children:["That's basically it. Except, of course, that we might ",(0,r.jsx)(n.em,{children:"fail"})," to find the method.\r\nSo we check for that too."]}),"\n",(0,r.jsx)(n.p,{children:"^code super-no-method (2 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"There you have it! Take that BostonCream example earlier and give it a try.\r\nAssuming you and I did everything right, it should fry it first, then stuff it\r\nwith cream."}),"\n",(0,r.jsx)(n.h3,{id:"invalid-uses-of-super",children:"Invalid uses of super"}),"\n",(0,r.jsx)(n.p,{children:"As with previous language features, our implementation does the right thing when\r\nthe user writes correct code, but we haven't bulletproofed the intepreter\r\nagainst bad code. In particular, consider:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'class Eclair {\r\n  cook() {\r\n    super.cook();\r\n    print "Pipe full of cr\xe8me p\xe2tissi\xe8re.";\r\n  }\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This class has a ",(0,r.jsx)(n.code,{children:"super"})," expression, but no superclass. At runtime, the code for\r\nevaluating ",(0,r.jsx)(n.code,{children:"super"}),' expressions assumes that "super" was successfully resolved\r\nand will be found in the environment. That\'s going to fail here because there is\r\nno surrounding environment for the superclass since there is no superclass. The\r\nJVM will throw an exception and bring our interpreter to its knees.']}),"\n",(0,r.jsx)(n.p,{children:"Heck, there are even simpler broken uses of super:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"super.notEvenInAClass();\n"})}),"\n",(0,r.jsxs)(n.p,{children:['We could handle errors like these at runtime by checking to see if the lookup\r\nof "super" succeeded. But we can tell statically -- just by looking at the\r\nsource code -- that Eclair has no superclass and thus no ',(0,r.jsx)(n.code,{children:"super"})," expression will\r\nwork inside it. Likewise, in the second example, we know that the ",(0,r.jsx)(n.code,{children:"super"}),"\r\nexpression is not even inside a method body."]}),"\n",(0,r.jsxs)(n.p,{children:["Even though Lox is dynamically typed, that doesn't mean we want to defer\r\n",(0,r.jsx)(n.em,{children:"everything"})," to runtime. If the user made a mistake, we'd like to help them find\r\nit sooner rather than later. So we'll report these errors statically, in the\r\nresolver."]}),"\n",(0,r.jsx)(n.p,{children:"First, we add a new case to the enum we use to keep track of what kind of class\r\nis surrounding the current code being visited."}),"\n",(0,r.jsx)(n.p,{children:"^code class-type-subclass (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We'll use that to distinguish when we're inside a class that has a superclass\r\nversus one that doesn't. When we resolve a class declaration, we set that if the\r\nclass is a subclass."}),"\n",(0,r.jsx)(n.p,{children:"^code set-current-subclass (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Then, when we resolve a ",(0,r.jsx)(n.code,{children:"super"})," expression, we check to see that we are\r\ncurrently inside a scope where that's allowed."]}),"\n",(0,r.jsx)(n.p,{children:"^code invalid-super (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"If not -- oopsie! -- the user made a mistake."}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:["We made it! That final bit of error handling is the last chunk of code needed to\r\ncomplete our Java implementation of Lox. This is a real ",(0,r.jsx)(n.span,{name:"superhero",children:"accomplishment"})," and one you should be proud of. In the\r\npast dozen chapters and a thousand or so lines of code, we have learned and\r\nimplemented..."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"scanning.html",children:"tokens and lexing"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"representing-code.html",children:"abstract syntax trees"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"parsing-expressions.html",children:"recursive descent parsing"}),","]}),"\n",(0,r.jsx)(n.li,{children:"prefix and infix expressions,"}),"\n",(0,r.jsx)(n.li,{children:"runtime representation of objects,"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"evaluating-expressions.html",children:"interpreting code using the Visitor pattern"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"statements-and-state.html",children:"lexical scope"}),","]}),"\n",(0,r.jsx)(n.li,{children:"environment chains for storing variables,"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"control-flow.html",children:"control flow"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"functions.html",children:"functions with parameters"}),","]}),"\n",(0,r.jsx)(n.li,{children:"closures,"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"resolving-and-binding.html",children:"static variable resolution and error detection"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"classes.html",children:"classes"}),","]}),"\n",(0,r.jsx)(n.li,{children:"constructors,"}),"\n",(0,r.jsx)(n.li,{children:"fields,"}),"\n",(0,r.jsx)(n.li,{children:"methods, and finally,"}),"\n",(0,r.jsx)(n.li,{children:"inheritance."}),"\n"]}),"\n",(0,r.jsxs)(n.aside,{name:"superhero",children:["\n",(0,r.jsx)(n.img,{src:"image/inheritance/superhero.png",alt:"You, being your bad self."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We did all of that from scratch, with no external dependencies or magic tools.\r\nJust you and I, our respective text editors, a couple of collection classes in\r\nthe Java standard library, and the JVM runtime."}),"\n",(0,r.jsxs)(n.p,{children:["This marks the end of Part II, but not the end of the book. Take a break. Maybe\r\nwrite a few fun Lox programs and run them in your interpreter. (You may want to\r\nadd a few more native methods for things like reading user input.) When you're\r\nrefreshed and ready, we'll embark on our ",(0,r.jsx)(n.a,{href:"a-bytecode-virtual-machine.html",children:"next adventure"}),"."]}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Lox supports only ",(0,r.jsx)(n.em,{children:"single inheritance"})," -- a class may have a single\r\nsuperclass and that's the only way to reuse methods across classes. Other\r\nlanguages have explored a variety of ways to more freely reuse and share\r\ncapabilities across classes: mixins, traits, multiple inheritance, virtual\r\ninheritance, extension methods, etc."]}),"\n",(0,r.jsx)(n.p,{children:"If you were to add some feature along these lines to Lox, which would you\r\npick and why? If you're feeling courageous (and you should be at this\r\npoint), go ahead and add it."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["In Lox, as in most other object-oriented languages, when looking up a\r\nmethod, we start at the bottom of the class hierarchy and work our way up --\r\na subclass's method is preferred over a superclass's. In order to get to the\r\nsuperclass method from within an overriding method, you use ",(0,r.jsx)(n.code,{children:"super"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The language ",(0,r.jsx)(n.a,{href:"https://beta.cs.au.dk/",children:"BETA"})," takes the ",(0,r.jsx)(n.a,{href:"http://journal.stuffwithstuff.com/2012/12/19/the-impoliteness-of-overriding-methods/",children:"opposite approach"}),". When you call a\r\nmethod, it starts at the ",(0,r.jsx)(n.em,{children:"top"})," of the class hierarchy and works ",(0,r.jsx)(n.em,{children:"down"}),". A\r\nsuperclass method wins over a subclass method. In order to get to the\r\nsubclass method, the superclass method can call ",(0,r.jsx)(n.code,{children:"inner"}),", which is sort of\r\nlike the inverse of ",(0,r.jsx)(n.code,{children:"super"}),". It chains to the next method down the\r\nhierarchy."]}),"\n",(0,r.jsxs)(n.p,{children:["The superclass method controls when and where the subclass is allowed to\r\nrefine its behavior. If the superclass method doesn't call ",(0,r.jsx)(n.code,{children:"inner"})," at all,\r\nthen the subclass has no way of overriding or modifying the superclass's\r\nbehavior."]}),"\n",(0,r.jsxs)(n.p,{children:["Take out Lox's current overriding and ",(0,r.jsx)(n.code,{children:"super"})," behavior and replace it with\r\nBETA's semantics. In short:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["When calling a method on a class, prefer the method ",(0,r.jsx)(n.em,{children:"highest"})," on the\r\nclass's inheritance chain."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Inside the body of a method, a call to ",(0,r.jsx)(n.code,{children:"inner"})," looks for a method with\r\nthe same name in the nearest subclass along the inheritance chain\r\nbetween the class containing the ",(0,r.jsx)(n.code,{children:"inner"})," and the class of ",(0,r.jsx)(n.code,{children:"this"}),". If\r\nthere is no matching method, the ",(0,r.jsx)(n.code,{children:"inner"})," call does nothing."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'class Doughnut {\r\n  cook() {\r\n    print "Fry until golden brown.";\r\n    inner();\r\n    print "Place in a nice box.";\r\n  }\r\n}\r\n\r\nclass BostonCream < Doughnut {\r\n  cook() {\r\n    print "Pipe full of custard and coat with chocolate.";\r\n  }\r\n}\r\n\r\nBostonCream().cook();\n'})}),"\n",(0,r.jsx)(n.p,{children:"This should print:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Fry until golden brown.\r\nPipe full of custard and coat with chocolate.\r\nPlace in a nice box.\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["In the chapter where I introduced Lox, ",(0,r.jsx)(n.a,{href:"the-lox-language.html#challenges",children:"I challenged you"})," to\r\ncome up with a couple of features you think the language is missing. Now\r\nthat you know how to build an interpreter, implement one of those features."]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var r=s(6540);const t={},a=r.createContext(t);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);