"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[5202],{1882:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var r=t(4848),s=t(8453);const a={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/global-variables",title:"global-variables",description:"If only there could be an invention that bottled up a memory, like scent. And",source:"@site/docs/Craftinginterpreters/not-translated-yet/global-variables.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/global-variables",permalink:"/docs/Craftinginterpreters/not-translated-yet/global-variables",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/global-variables.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"garbage-collection",permalink:"/docs/Craftinginterpreters/not-translated-yet/garbage-collection"},next:{title:"hash-tables",permalink:"/docs/Craftinginterpreters/not-translated-yet/hash-tables"}},l={},h=[{value:"Statements",id:"statements",level:2},{value:"Print statements",id:"print-statements",level:3},{value:"Expression statements",id:"expression-statements",level:3},{value:"Error synchronization",id:"error-synchronization",level:3},{value:"Variable Declarations",id:"variable-declarations",level:2},{value:"Reading Variables",id:"reading-variables",level:2},{value:"Assignment",id:"assignment",level:2},{value:"Challenges",id:"challenges",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"If only there could be an invention that bottled up a memory, like scent. And\r\nit never faded, and it never got stale. And then, when one wanted it, the\r\nbottle could be uncorked, and it would be like living the moment all over\r\nagain."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["Daphne du Maurier, ",(0,r.jsx)(n.em,{children:"Rebecca"})]})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"hash-tables.html",children:"previous chapter"})," was a long exploration of one big, deep,\r\nfundamental computer science data structure. Heavy on theory and concept. There\r\nmay have been some discussion of big-O notation and algorithms. This chapter has\r\nfewer intellectual pretensions. There are no large ideas to learn. Instead, it's\r\na handful of straightforward engineering tasks. Once we've completed them, our\r\nvirtual machine will support variables."]}),"\n",(0,r.jsxs)(n.p,{children:["Actually, it will support only ",(0,r.jsx)(n.em,{children:"global"})," variables. Locals are coming in the\r\n",(0,r.jsx)(n.a,{href:"local-variables.html",children:"next chapter"}),". In jlox, we managed to cram them both into a single chapter\r\nbecause we used the same implementation technique for all variables. We built a\r\nchain of environments, one for each scope, all the way up to the top. That was a\r\nsimple, clean way to learn how to manage state."]}),"\n",(0,r.jsxs)(n.p,{children:["But it's also ",(0,r.jsx)(n.em,{children:"slow"}),". Allocating a new hash table each time you enter a block or\r\ncall a function is not the road to a fast VM. Given how much code is concerned\r\nwith using variables, if variables go slow, everything goes slow. For clox,\r\nwe'll improve that by using a much more efficient strategy for ",(0,r.jsx)(n.span,{name:"different",children:"local"})," variables, but globals aren't as easily optimized."]}),"\n",(0,r.jsxs)(n.aside,{name:"different",children:["\n",(0,r.jsxs)(n.p,{children:["This is a common meta-strategy in sophisticated language implementations. Often,\r\nthe same language feature will have multiple implementation techniques, each\r\ntuned for different use patterns. For example, JavaScript VMs often have a\r\nfaster representation for objects that are used more like instances of classes\r\ncompared to other objects whose set of properties is more freely modified. C and\r\nC++ compilers usually have a variety of ways to compile ",(0,r.jsx)(n.code,{children:"switch"})," statements\r\nbased on the number of cases and how densely packed the case values are."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["A quick refresher on Lox semantics: Global variables in Lox are \"late bound\", or\r\nresolved dynamically. This means you can compile a chunk of code that refers to\r\na global variable before it's defined. As long as the code doesn't ",(0,r.jsx)(n.em,{children:"execute"}),"\r\nbefore the definition happens, everything is fine. In practice, that means you\r\ncan refer to later variables inside the body of functions."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun showVariable() {\r\n  print global;\r\n}\r\n\r\nvar global = "after";\r\nshowVariable();\n'})}),"\n",(0,r.jsx)(n.p,{children:"Code like this might seem odd, but it's handy for defining mutually recursive\r\nfunctions. It also plays nicer with the REPL. You can write a little function in\r\none line, then define the variable it uses in the next."}),"\n",(0,r.jsxs)(n.p,{children:["Local variables work differently. Since a local variable's declaration ",(0,r.jsx)(n.em,{children:"always"}),"\r\noccurs before it is used, the VM can resolve them at compile time, even in a\r\nsimple single-pass compiler. That will let us use a smarter representation for\r\nlocals. But that's for the next chapter. Right now, let's just worry about\r\nglobals."]}),"\n",(0,r.jsx)(n.h2,{id:"statements",children:"Statements"}),"\n",(0,r.jsx)(n.p,{children:'Variables come into being using variable declarations, which means now is also\r\nthe time to add support for statements to our compiler. If you recall, Lox\r\nsplits statements into two categories. "Declarations" are those statements that\r\nbind a new name to a value. The other kinds of statements -- control flow,\r\nprint, etc. -- are just called "statements". We disallow declarations directly\r\ninside control flow statements, like this:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'if (monday) var croissant = "yes"; // Error.\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Allowing it would raise confusing questions around the scope of the variable.\r\nSo, like other languages, we prohibit it syntactically by having a separate\r\ngrammar rule for the subset of statements that ",(0,r.jsx)(n.em,{children:"are"})," allowed inside a control\r\nflow body."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:"statement      \u2192 exprStmt\r\n               | forStmt\r\n               | ifStmt\r\n               | printStmt\r\n               | returnStmt\r\n               | whileStmt\r\n               | block ;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Then we use a separate rule for the top level of a script and inside a block."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:"declaration    \u2192 classDecl\r\n               | funDecl\r\n               | varDecl\r\n               | statement ;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"declaration"})," rule contains the statements that declare names, and also\r\nincludes ",(0,r.jsx)(n.code,{children:"statement"})," so that all statement types are allowed. Since ",(0,r.jsx)(n.code,{children:"block"}),"\r\nitself is in ",(0,r.jsx)(n.code,{children:"statement"}),", you can put declarations ",(0,r.jsx)(n.span,{name:"parens",children:"inside"})," a control flow construct by nesting them inside a\r\nblock."]}),"\n",(0,r.jsxs)(n.aside,{name:"parens",children:["\n",(0,r.jsx)(n.p,{children:'Blocks work sort of like parentheses do for expressions. A block lets you put\r\nthe "lower-precedence" declaration statements in places where only a\r\n"higher-precedence" non-declaring statement is allowed.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In this chapter, we'll cover only a couple of statements and one\r\ndeclaration."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:"statement      \u2192 exprStmt\r\n               | printStmt ;\r\n\r\ndeclaration    \u2192 varDecl\r\n               | statement ;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Up to now, our VM considered a \"program\" to be a single expression since that's\r\nall we could parse and compile. In a full Lox implementation, a program is a\r\nsequence of declarations. We're ready to support that now."}),"\n",(0,r.jsx)(n.p,{children:"^code compile (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We keep compiling declarations until we hit the end of the source file. We\r\ncompile a single declaration using this:"}),"\n",(0,r.jsx)(n.p,{children:"^code declaration"}),"\n",(0,r.jsxs)(n.p,{children:["We'll get to variable declarations later in the chapter, so for now, we simply\r\nforward to ",(0,r.jsx)(n.code,{children:"statement()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code statement"}),"\n",(0,r.jsx)(n.p,{children:"Blocks can contain declarations, and control flow statements can contain other\r\nstatements. That means these two functions will eventually be recursive. We may\r\nas well write out the forward declarations now."}),"\n",(0,r.jsx)(n.p,{children:"^code forward-declarations (1 before, 1 after)"}),"\n",(0,r.jsx)(n.h3,{id:"print-statements",children:"Print statements"}),"\n",(0,r.jsxs)(n.p,{children:["We have two statement types to support in this chapter. Let's start with ",(0,r.jsx)(n.code,{children:"print"}),"\r\nstatements, which begin, naturally enough, with a ",(0,r.jsx)(n.code,{children:"print"})," token. We detect that\r\nusing this helper function:"]}),"\n",(0,r.jsx)(n.p,{children:"^code match"}),"\n",(0,r.jsxs)(n.p,{children:["You may recognize it from jlox. If the current token has the given type, we\r\nconsume the token and return ",(0,r.jsx)(n.code,{children:"true"}),". Otherwise we leave the token alone and\r\nreturn ",(0,r.jsx)(n.code,{children:"false"}),". This ",(0,r.jsx)(n.span,{name:"turtles",children:"helper"})," function is implemented\r\nin terms of this other helper:"]}),"\n",(0,r.jsxs)(n.aside,{name:"turtles",children:["\n",(0,r.jsx)(n.p,{children:"It's helpers all the way down!"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code check"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"check()"})," function returns ",(0,r.jsx)(n.code,{children:"true"})," if the current token has the given type.\r\nIt seems a little ",(0,r.jsx)(n.span,{name:"read",children:"silly"})," to wrap this in a function, but\r\nwe'll use it more later, and I think short verb-named functions like this make\r\nthe parser easier to read."]}),"\n",(0,r.jsxs)(n.aside,{name:"read",children:["\n",(0,r.jsx)(n.p,{children:"This sounds trivial, but handwritten parsers for non-toy languages get pretty\r\nbig. When you have thousands of lines of code, a utility function that turns two\r\nlines into one and makes the result a little more readable easily earns its\r\nkeep."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If we did match the ",(0,r.jsx)(n.code,{children:"print"})," token, then we compile the rest of the statement\r\nhere:"]}),"\n",(0,r.jsx)(n.p,{children:"^code print-statement"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"print"})," statement evaluates an expression and prints the result, so we first\r\nparse and compile that expression. The grammar expects a semicolon after that,\r\nso we consume it. Finally, we emit a new instruction to print the result."]}),"\n",(0,r.jsx)(n.p,{children:"^code op-print (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"At runtime, we execute this instruction like so:"}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-print (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"When the interpreter reaches this instruction, it has already executed the code\r\nfor the expression, leaving the result value on top of the stack. Now we simply\r\npop and print it."}),"\n",(0,r.jsxs)(n.p,{children:["Note that we don't push anything else after that. This is a key difference\r\nbetween expressions and statements in the VM. Every bytecode instruction has a\r\n",(0,r.jsx)(n.span,{name:"effect",children:(0,r.jsx)(n.strong,{children:"stack effect"})})," that describes how the instruction\r\nmodifies the stack. For example, ",(0,r.jsx)(n.code,{children:"OP_ADD"})," pops two values and pushes one,\r\nleaving the stack one element smaller than before."]}),"\n",(0,r.jsxs)(n.aside,{name:"effect",children:["\n",(0,r.jsxs)(n.p,{children:["The stack is one element shorter after an ",(0,r.jsx)(n.code,{children:"OP_ADD"}),", so its effect is -1:"]}),"\n",(0,r.jsx)(n.img,{src:"image/global-variables/stack-effect.png",alt:"The stack effect of an OP_ADD instruction."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You can sum the stack effects of a series of instructions to get their total\r\neffect. When you add the stack effects of the series of instructions compiled\r\nfrom any complete expression, it will total one. Each expression leaves one\r\nresult value on the stack."}),"\n",(0,r.jsx)(n.p,{children:"The bytecode for an entire statement has a total stack effect of zero. Since a\r\nstatement produces no values, it ultimately leaves the stack unchanged, though\r\nit of course uses the stack while it's doing its thing. This is important\r\nbecause when we get to control flow and looping, a program might execute a long\r\nseries of statements. If each statement grew or shrank the stack, it might\r\neventually overflow or underflow."}),"\n",(0,r.jsx)(n.p,{children:"While we're in the interpreter loop, we should delete a bit of code."}),"\n",(0,r.jsx)(n.p,{children:"^code op-return (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["When the VM only compiled and evaluated a single expression, we had some\r\ntemporary code in ",(0,r.jsx)(n.code,{children:"OP_RETURN"})," to output the value. Now that we have statements\r\nand ",(0,r.jsx)(n.code,{children:"print"}),", we don't need that anymore. We're one ",(0,r.jsx)(n.span,{name:"return",children:"step"})," closer to the complete implementation of clox."]}),"\n",(0,r.jsxs)(n.aside,{name:"return",children:["\n",(0,r.jsxs)(n.p,{children:["We're only one step closer, though. We will revisit ",(0,r.jsx)(n.code,{children:"OP_RETURN"})," again when we\r\nadd functions. Right now, it exits the entire interpreter loop."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"As usual, a new instruction needs support in the disassembler."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-print (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["That's our ",(0,r.jsx)(n.code,{children:"print"})," statement. If you want, give it a whirl:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"print 1 + 2;\r\nprint 3 * 4;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Exciting! OK, maybe not thrilling, but we can build scripts that contain as many\r\nstatements as we want now, which feels like progress."}),"\n",(0,r.jsx)(n.h3,{id:"expression-statements",children:"Expression statements"}),"\n",(0,r.jsxs)(n.p,{children:["Wait until you see the next statement. If we ",(0,r.jsx)(n.em,{children:"don't"})," see a ",(0,r.jsx)(n.code,{children:"print"})," keyword, then\r\nwe must be looking at an expression statement."]}),"\n",(0,r.jsx)(n.p,{children:"^code parse-expressions-statement (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"It's parsed like so:"}),"\n",(0,r.jsx)(n.p,{children:"^code expression-statement"}),"\n",(0,r.jsx)(n.p,{children:"An \"expression statement\" is simply an expression followed by a semicolon.\r\nThey're how you write an expression in a context where a statement is expected.\r\nUsually, it's so that you can call a function or evaluate an assignment for its\r\nside effect, like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'brunch = "quiche";\r\neat(brunch);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Semantically, an expression statement evaluates the expression and discards the\r\nresult. The compiler directly encodes that behavior. It compiles the expression,\r\nand then emits an ",(0,r.jsx)(n.code,{children:"OP_POP"})," instruction."]}),"\n",(0,r.jsx)(n.p,{children:"^code pop-op (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"As the name implies, that instruction pops the top value off the stack and\r\nforgets it."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-pop (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We can disassemble it too."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-pop (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Expression statements aren't very useful yet since we can't create any\r\nexpressions that have side effects, but they'll be essential when we\r\n",(0,r.jsx)(n.a,{href:"calls-and-functions.html",children:"add functions later"}),". The ",(0,r.jsx)(n.span,{name:"majority",children:"majority"})," of\r\nstatements in real-world code in languages like C are expression statements."]}),"\n",(0,r.jsxs)(n.aside,{name:"majority",children:["\n",(0,r.jsx)(n.p,{children:'By my count, 80 of the 149 statements, in the version of "compiler.c" that we\r\nhave at the end of this chapter are expression statements.'}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-synchronization",children:"Error synchronization"}),"\n",(0,r.jsxs)(n.p,{children:["While we're getting this initial work done in the compiler, we can tie off a\r\nloose end we left ",(0,r.jsx)(n.a,{href:"compiling-expressions.html#handling-syntax-errors",children:"several chapters back"}),". Like jlox, clox uses panic\r\nmode error recovery to minimize the number of cascaded compile errors that it\r\nreports. The compiler exits panic mode when it reaches a synchronization point.\r\nFor Lox, we chose statement boundaries as that point. Now that we have\r\nstatements, we can implement synchronization."]}),"\n",(0,r.jsx)(n.p,{children:"^code call-synchronize (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"If we hit a compile error while parsing the previous statement, we enter panic\r\nmode. When that happens, after the statement we start synchronizing."}),"\n",(0,r.jsx)(n.p,{children:"^code synchronize"}),"\n",(0,r.jsx)(n.p,{children:"We skip tokens indiscriminately until we reach something that looks like a\r\nstatement boundary. We recognize the boundary by looking for a preceding token\r\nthat can end a statement, like a semicolon. Or we'll look for a subsequent token\r\nthat begins a statement, usually one of the control flow or declaration\r\nkeywords."}),"\n",(0,r.jsx)(n.h2,{id:"variable-declarations",children:"Variable Declarations"}),"\n",(0,r.jsxs)(n.p,{children:["Merely being able to ",(0,r.jsx)(n.em,{children:"print"})," doesn't win your language any prizes at the\r\nprogramming language ",(0,r.jsx)(n.span,{name:"fair",children:"fair"}),", so let's move on to\r\nsomething a little more ambitious and get variables going. There are three\r\noperations we need to support:"]}),"\n",(0,r.jsxs)(n.aside,{name:"fair",children:["\n",(0,r.jsxs)(n.p,{children:['I can\'t help but imagine a "language fair" like some country 4H thing. Rows of\r\nstraw-lined stalls full of baby languages ',(0,r.jsx)(n.em,{children:"moo"}),"ing and ",(0,r.jsx)(n.em,{children:"baa"}),"ing at each other."]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Declaring a new variable using a ",(0,r.jsx)(n.code,{children:"var"})," statement."]}),"\n",(0,r.jsx)(n.li,{children:"Accessing the value of a variable using an identifier expression."}),"\n",(0,r.jsx)(n.li,{children:"Storing a new value in an existing variable using an assignment expression."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We can't do either of the last two until we have some variables, so we start\r\nwith declarations."}),"\n",(0,r.jsx)(n.p,{children:"^code match-var (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The placeholder parsing function we sketched out for the declaration grammar\r\nrule has an actual production now. If we match a ",(0,r.jsx)(n.code,{children:"var"})," token, we jump here:"]}),"\n",(0,r.jsx)(n.p,{children:"^code var-declaration"}),"\n",(0,r.jsxs)(n.p,{children:["The keyword is followed by the variable name. That's compiled by\r\n",(0,r.jsx)(n.code,{children:"parseVariable()"}),", which we'll get to in a second. Then we look for an ",(0,r.jsx)(n.code,{children:"="}),"\r\nfollowed by an initializer expression. If the user doesn't initialize the\r\nvariable, the compiler implicitly initializes it to ",(0,r.jsx)(n.span,{name:"nil",children:(0,r.jsx)(n.code,{children:"nil"})})," by emitting an ",(0,r.jsx)(n.code,{children:"OP_NIL"})," instruction. Either way, we\r\nexpect the statement to be terminated with a semicolon."]}),"\n",(0,r.jsxs)(n.aside,{name:"nil",className:"bottom",children:["\n",(0,r.jsx)(n.p,{children:"Essentially, the compiler desugars a variable declaration like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"var a;\n"})}),"\n",(0,r.jsx)(n.p,{children:"into:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"var a = nil;\n"})}),"\n",(0,r.jsx)(n.p,{children:"The code it generates for the former is identical to what it produces for the\r\nlatter."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"There are two new functions here for working with variables and identifiers.\r\nHere is the first:"}),"\n",(0,r.jsx)(n.p,{children:"^code parse-variable (2 before)"}),"\n",(0,r.jsx)(n.p,{children:"It requires the next token to be an identifier, which it consumes and sends\r\nhere:"}),"\n",(0,r.jsx)(n.p,{children:"^code identifier-constant (2 before)"}),"\n",(0,r.jsx)(n.p,{children:"This function takes the given token and adds its lexeme to the chunk's constant\r\ntable as a string. It then returns the index of that constant in the constant\r\ntable."}),"\n",(0,r.jsxs)(n.p,{children:["Global variables are looked up ",(0,r.jsx)(n.em,{children:"by name"})," at runtime. That means the VM -- the\r\nbytecode interpreter loop -- needs access to the name. A whole string is too big\r\nto stuff into the bytecode stream as an operand. Instead, we store the string in\r\nthe constant table and the instruction then refers to the name by its index in\r\nthe table."]}),"\n",(0,r.jsxs)(n.p,{children:["This function returns that index all the way to ",(0,r.jsx)(n.code,{children:"varDeclaration()"})," which later\r\nhands it over to here:"]}),"\n",(0,r.jsx)(n.p,{children:"^code define-variable"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"helper",children:"This"})," outputs the bytecode instruction that defines\r\nthe new variable and stores its initial value. The index of the variable's name\r\nin the constant table is the instruction's operand. As usual in a stack-based\r\nVM, we emit this instruction last. At runtime, we execute the code for the\r\nvariable's initializer first. That leaves the value on the stack. Then this\r\ninstruction takes that value and stores it away for later."]}),"\n",(0,r.jsxs)(n.aside,{name:"helper",children:["\n",(0,r.jsx)(n.p,{children:"I know some of these functions seem pretty pointless right now. But we'll get\r\nmore mileage out of them as we add more language features for working with\r\nnames. Function and class declarations both declare new variables, and variable\r\nand assignment expressions access them."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Over in the runtime, we begin with this new instruction:"}),"\n",(0,r.jsx)(n.p,{children:"^code define-global-op (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Thanks to our handy-dandy hash table, the implementation isn't too hard."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-define-global (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We get the name of the variable from the constant table. Then we ",(0,r.jsx)(n.span,{name:"pop",children:"take"})," the value from the top of the stack and store it in a\r\nhash table with that name as the key."]}),"\n",(0,r.jsxs)(n.aside,{name:"pop",children:["\n",(0,r.jsxs)(n.p,{children:["Note that we don't ",(0,r.jsx)(n.em,{children:"pop"})," the value until ",(0,r.jsx)(n.em,{children:"after"})," we add it to the hash table.\r\nThat ensures the VM can still find the value if a garbage collection is\r\ntriggered right in the middle of adding it to the hash table. That's a distinct\r\npossibility since the hash table requires dynamic allocation when it resizes."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This code doesn't check to see if the key is already in the table. Lox is pretty\r\nlax with global variables and lets you redefine them without error. That's\r\nuseful in a REPL session, so the VM supports that by simply overwriting the\r\nvalue if the key happens to already be in the hash table."}),"\n",(0,r.jsx)(n.p,{children:"There's another little helper macro:"}),"\n",(0,r.jsx)(n.p,{children:"^code read-string (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["It reads a one-byte operand from the bytecode chunk. It treats that as an index\r\ninto the chunk's constant table and returns the string at that index. It doesn't\r\ncheck that the value ",(0,r.jsx)(n.em,{children:"is"})," a string -- it just indiscriminately casts it. That's\r\nsafe because the compiler never emits an instruction that refers to a non-string\r\nconstant."]}),"\n",(0,r.jsx)(n.p,{children:"Because we care about lexical hygiene, we also undefine this macro at the end of\r\nthe interpret function."}),"\n",(0,r.jsx)(n.p,{children:"^code undef-read-string (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:'I keep saying "the hash table", but we don\'t actually have one yet. We need a\r\nplace to store these globals. Since we want them to persist as long as clox is\r\nrunning, we store them right in the VM.'}),"\n",(0,r.jsx)(n.p,{children:"^code vm-globals (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"As we did with the string table, we need to initialize the hash table to a valid\r\nstate when the VM boots up."}),"\n",(0,r.jsx)(n.p,{children:"^code init-globals (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["And we ",(0,r.jsx)(n.span,{name:"tear",children:"tear"})," it down when we exit."]}),"\n",(0,r.jsxs)(n.aside,{name:"tear",children:["\n",(0,r.jsx)(n.p,{children:"The process will free everything on exit, but it feels undignified to require\r\nthe operating system to clean up our mess."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code free-globals (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"As usual, we want to be able to disassemble the new instruction too."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-define-global (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["And with that, we can define global variables. Not that users can ",(0,r.jsx)(n.em,{children:"tell"})," that\r\nthey've done so, because they can't actually ",(0,r.jsx)(n.em,{children:"use"})," them. So let's fix that next."]}),"\n",(0,r.jsx)(n.h2,{id:"reading-variables",children:"Reading Variables"}),"\n",(0,r.jsx)(n.p,{children:"As in every programming language ever, we access a variable's value using its\r\nname. We hook up identifier tokens to the expression parser here:"}),"\n",(0,r.jsx)(n.p,{children:"^code table-identifier (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That calls this new parser function:"}),"\n",(0,r.jsx)(n.p,{children:"^code variable-without-assign"}),"\n",(0,r.jsx)(n.p,{children:"Like with declarations, there are a couple of tiny helper functions that seem\r\npointless now but will become more useful in later chapters. I promise."}),"\n",(0,r.jsx)(n.p,{children:"^code read-named-variable"}),"\n",(0,r.jsxs)(n.p,{children:["This calls the same ",(0,r.jsx)(n.code,{children:"identifierConstant()"})," function from before to take the\r\ngiven identifier token and add its lexeme to the chunk's constant table as a\r\nstring. All that remains is to emit an instruction that loads the global\r\nvariable with that name. Here's the instruction:"]}),"\n",(0,r.jsx)(n.p,{children:"^code get-global-op (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Over in the interpreter, the implementation mirrors ",(0,r.jsx)(n.code,{children:"OP_DEFINE_GLOBAL"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-get-global (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We pull the constant table index from the instruction's operand and get the\r\nvariable name. Then we use that as a key to look up the variable's value in the\r\nglobals hash table."}),"\n",(0,r.jsx)(n.p,{children:"If the key isn't present in the hash table, it means that global variable has\r\nnever been defined. That's a runtime error in Lox, so we report it and exit the\r\ninterpreter loop if that happens. Otherwise, we take the value and push it\r\nonto the stack."}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-get-global (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"A little bit of disassembling, and we're done. Our interpreter is now able to\r\nrun code like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var beverage = "cafe au lait";\r\nvar breakfast = "beignets with " + beverage;\r\nprint breakfast;\n'})}),"\n",(0,r.jsx)(n.p,{children:"There's only one operation left."}),"\n",(0,r.jsx)(n.h2,{id:"assignment",children:"Assignment"}),"\n",(0,r.jsxs)(n.p,{children:["Throughout this book, I've tried to keep you on a fairly safe and easy path. I\r\ndon't avoid hard ",(0,r.jsx)(n.em,{children:"problems"}),", but I try to not make the ",(0,r.jsx)(n.em,{children:"solutions"})," more complex\r\nthan they need to be. Alas, other design choices in our ",(0,r.jsx)(n.span,{name:"jlox",children:"bytecode"})," compiler make assignment annoying to implement."]}),"\n",(0,r.jsxs)(n.aside,{name:"jlox",children:["\n",(0,r.jsx)(n.p,{children:"If you recall, assignment was pretty easy in jlox."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Our bytecode VM uses a single-pass compiler. It parses and generates bytecode\r\non the fly without any intermediate AST. As soon as it recognizes a piece of\r\nsyntax, it emits code for it. Assignment doesn't naturally fit that. Consider:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'menu.brunch(sunday).beverage = "mimosa";\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this code, the parser doesn't realize ",(0,r.jsx)(n.code,{children:"menu.brunch(sunday).beverage"})," is the\r\ntarget of an assignment and not a normal expression until it reaches ",(0,r.jsx)(n.code,{children:"="}),", many\r\ntokens after the first ",(0,r.jsx)(n.code,{children:"menu"}),". By then, the compiler has already emitted\r\nbytecode for the whole thing."]}),"\n",(0,r.jsx)(n.p,{children:"The problem is not as dire as it might seem, though. Look at how the parser sees that example:"}),"\n",(0,r.jsx)(n.img,{src:"image/global-variables/setter.png",alt:"The 'menu.brunch(sunday).beverage = \"mimosa\"' statement, showing that 'menu.brunch(sunday)' is an expression."}),"\n",(0,r.jsxs)(n.p,{children:["Even though the ",(0,r.jsx)(n.code,{children:".beverage"})," part must not be compiled as a get expression,\r\neverything to the left of the ",(0,r.jsx)(n.code,{children:"."})," is an expression, with the normal expression\r\nsemantics. The ",(0,r.jsx)(n.code,{children:"menu.brunch(sunday)"})," part can be compiled and executed as usual."]}),"\n",(0,r.jsxs)(n.p,{children:["Fortunately for us, the only semantic differences on the left side of an\r\nassignment appear at the very right-most end of the tokens, immediately\r\npreceding the ",(0,r.jsx)(n.code,{children:"="}),". Even though the receiver of a setter may be an arbitrarily\r\nlong expression, the part whose behavior differs from a get expression is only\r\nthe trailing identifier, which is right before the ",(0,r.jsx)(n.code,{children:"="}),". We don't need much\r\nlookahead to realize ",(0,r.jsx)(n.code,{children:"beverage"})," should be compiled as a set expression and not a\r\ngetter."]}),"\n",(0,r.jsxs)(n.p,{children:["Variables are even easier since they are just a single bare identifier before an\r\n",(0,r.jsx)(n.code,{children:"="}),". The idea then is that right ",(0,r.jsx)(n.em,{children:"before"})," compiling an expression that can also\r\nbe used as an assignment target, we look for a subsequent ",(0,r.jsx)(n.code,{children:"="})," token. If we see\r\none, we compile it as an assignment or setter instead of a variable access or\r\ngetter."]}),"\n",(0,r.jsx)(n.p,{children:"We don't have setters to worry about yet, so all we need to handle are variables."}),"\n",(0,r.jsx)(n.p,{children:"^code named-variable (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"In the parse function for identifier expressions, we look for an equals sign\r\nafter the identifier. If we find one, instead of emitting code for a variable\r\naccess, we compile the assigned value and then emit an assignment instruction."}),"\n",(0,r.jsx)(n.p,{children:"That's the last instruction we need to add in this chapter."}),"\n",(0,r.jsx)(n.p,{children:"^code set-global-op (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"As you'd expect, its runtime behavior is similar to defining a new variable."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret-set-global (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The main difference is what happens when the key doesn't already exist in the\r\nglobals hash table. If the variable hasn't been defined yet, it's a runtime\r\nerror to try to assign to it. Lox ",(0,r.jsx)(n.a,{href:"statements-and-state.html#design-note",children:"doesn't do implicit variable\r\ndeclaration"}),"."]}),"\n",(0,r.jsxs)(n.aside,{name:"delete",children:["\n",(0,r.jsxs)(n.p,{children:["The call to ",(0,r.jsx)(n.code,{children:"tableSet()"})," stores the value in the global variable table even if\r\nthe variable wasn't previously defined. That fact is visible in a REPL session,\r\nsince it keeps running even after the runtime error is reported. So we also take\r\ncare to delete that zombie value from the table."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The other difference is that setting a variable doesn't pop the value off the\r\nstack. Remember, assignment is an expression, so it needs to leave that value\r\nthere in case the assignment is nested inside some larger expression."}),"\n",(0,r.jsx)(n.p,{children:"Add a dash of disassembly:"}),"\n",(0,r.jsx)(n.p,{children:"^code disassemble-set-global (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"So we're done, right? Well... not quite. We've made a mistake! Take a gander at:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"a * b = c + d;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["According to Lox's grammar, ",(0,r.jsx)(n.code,{children:"="})," has the lowest precedence, so this should be\r\nparsed roughly like:"]}),"\n",(0,r.jsx)(n.img,{src:"image/global-variables/ast-good.png",alt:"The expected parse, like '(a * b) = (c + d)'."}),"\n",(0,r.jsxs)(n.p,{children:["Obviously, ",(0,r.jsx)(n.code,{children:"a * b"})," isn't a ",(0,r.jsx)(n.span,{name:"do",children:"valid"})," assignment target, so\r\nthis should be a syntax error. But here's what our parser does:"]}),"\n",(0,r.jsxs)(n.aside,{name:"do",children:["\n",(0,r.jsxs)(n.p,{children:["Wouldn't it be wild if ",(0,r.jsx)(n.code,{children:"a * b"})," ",(0,r.jsx)(n.em,{children:"was"})," a valid assignment target, though? You\r\ncould imagine some algebra-like language that tried to divide the assigned value\r\nup in some reasonable way and distribute it to ",(0,r.jsx)(n.code,{children:"a"})," and ",(0,r.jsx)(n.code,{children:"b"}),"... that's probably\r\na terrible idea."]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["First, ",(0,r.jsx)(n.code,{children:"parsePrecedence()"})," parses ",(0,r.jsx)(n.code,{children:"a"})," using the ",(0,r.jsx)(n.code,{children:"variable()"})," prefix parser."]}),"\n",(0,r.jsx)(n.li,{children:"After that, it enters the infix parsing loop."}),"\n",(0,r.jsxs)(n.li,{children:["It reaches the ",(0,r.jsx)(n.code,{children:"*"})," and calls ",(0,r.jsx)(n.code,{children:"binary()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["That recursively calls ",(0,r.jsx)(n.code,{children:"parsePrecedence()"})," to parse the right-hand operand."]}),"\n",(0,r.jsxs)(n.li,{children:["That calls ",(0,r.jsx)(n.code,{children:"variable()"})," again for parsing ",(0,r.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Inside that call to ",(0,r.jsx)(n.code,{children:"variable()"}),", it looks for a trailing ",(0,r.jsx)(n.code,{children:"="}),". It sees one\r\nand thus parses the rest of the line as an assignment."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In other words, the parser sees the above code like:"}),"\n",(0,r.jsx)(n.img,{src:"image/global-variables/ast-bad.png",alt:"The actual parse, like 'a * (b = c + d)'."}),"\n",(0,r.jsxs)(n.p,{children:["We've messed up the precedence handling because ",(0,r.jsx)(n.code,{children:"variable()"})," doesn't take into\r\naccount the precedence of the surrounding expression that contains the variable.\r\nIf the variable happens to be the right-hand side of an infix operator, or the\r\noperand of a unary operator, then that containing expression is too high\r\nprecedence to permit the ",(0,r.jsx)(n.code,{children:"="}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["To fix this, ",(0,r.jsx)(n.code,{children:"variable()"})," should look for and consume the ",(0,r.jsx)(n.code,{children:"="})," only if it's in\r\nthe context of a low-precedence expression. The code that knows the current\r\nprecedence is, logically enough, ",(0,r.jsx)(n.code,{children:"parsePrecedence()"}),". The ",(0,r.jsx)(n.code,{children:"variable()"})," function\r\ndoesn't need to know the actual level. It just cares that the precedence is low\r\nenough to allow assignment, so we pass that fact in as a Boolean."]}),"\n",(0,r.jsx)(n.p,{children:"^code prefix-rule (4 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"Since assignment is the lowest-precedence expression, the only time we allow an\r\nassignment is when parsing an assignment expression or top-level expression like\r\nin an expression statement. That flag makes its way to the parser function here:"}),"\n",(0,r.jsx)(n.p,{children:"^code variable"}),"\n",(0,r.jsx)(n.p,{children:"Which passes it through a new parameter:"}),"\n",(0,r.jsx)(n.p,{children:"^code named-variable-signature (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And then finally uses it here:"}),"\n",(0,r.jsx)(n.p,{children:"^code named-variable-can-assign (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["That's a lot of plumbing to get literally one bit of data to the right place in\r\nthe compiler, but arrived it has. If the variable is nested inside some\r\nexpression with higher precedence, ",(0,r.jsx)(n.code,{children:"canAssign"})," will be ",(0,r.jsx)(n.code,{children:"false"})," and this will\r\nignore the ",(0,r.jsx)(n.code,{children:"="})," even if there is one there. Then ",(0,r.jsx)(n.code,{children:"namedVariable()"})," returns, and\r\nexecution eventually makes its way back to ",(0,r.jsx)(n.code,{children:"parsePrecedence()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Then what? What does the compiler do with our broken example from before? Right\r\nnow, ",(0,r.jsx)(n.code,{children:"variable()"})," won't consume the ",(0,r.jsx)(n.code,{children:"="}),", so that will be the current token. The\r\ncompiler returns back to ",(0,r.jsx)(n.code,{children:"parsePrecedence()"})," from the ",(0,r.jsx)(n.code,{children:"variable()"})," prefix parser\r\nand then tries to enter the infix parsing loop. There is no parsing function\r\nassociated with ",(0,r.jsx)(n.code,{children:"="}),", so it skips that loop."]}),"\n",(0,r.jsxs)(n.p,{children:["Then ",(0,r.jsx)(n.code,{children:"parsePrecedence()"})," silently returns back to the caller. That also isn't\r\nright. If the ",(0,r.jsx)(n.code,{children:"="})," doesn't get consumed as part of the expression, nothing else\r\nis going to consume it. It's an error and we should report it."]}),"\n",(0,r.jsx)(n.p,{children:"^code invalid-assign (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["With that, the previous bad program correctly gets an error at compile time. OK,\r\n",(0,r.jsx)(n.em,{children:"now"})," are we done? Still not quite. See, we're passing an argument to one of the\r\nparse functions. But those functions are stored in a table of function pointers,\r\nso all of the parse functions need to have the same type. Even though most parse\r\nfunctions don't support being used as an assignment target -- setters are the\r\n",(0,r.jsx)(n.span,{name:"index",children:"only"})," other one -- our friendly C compiler requires\r\nthem ",(0,r.jsx)(n.em,{children:"all"})," to accept the parameter."]}),"\n",(0,r.jsxs)(n.aside,{name:"index",children:["\n",(0,r.jsxs)(n.p,{children:["If Lox had arrays and subscript operators like ",(0,r.jsx)(n.code,{children:"array[index]"})," then an infix ",(0,r.jsx)(n.code,{children:"["}),"\r\nwould also allow assignment to support ",(0,r.jsx)(n.code,{children:"array[index] = value"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"So we're going to finish off this chapter with some grunt work. First, let's go\r\nahead and pass the flag to the infix parse functions."}),"\n",(0,r.jsx)(n.p,{children:"^code infix-rule (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We'll need that for setters eventually. Then we'll fix the typedef for the\r\nfunction type."}),"\n",(0,r.jsx)(n.p,{children:"^code parse-fn-type (2 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"And some completely tedious code to accept this parameter in all of our existing\r\nparse functions. Here:"}),"\n",(0,r.jsx)(n.p,{children:"^code binary (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And here:"}),"\n",(0,r.jsx)(n.p,{children:"^code parse-literal (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And here:"}),"\n",(0,r.jsx)(n.p,{children:"^code grouping (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And here:"}),"\n",(0,r.jsx)(n.p,{children:"^code number (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And here too:"}),"\n",(0,r.jsx)(n.p,{children:"^code string (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And, finally:"}),"\n",(0,r.jsx)(n.p,{children:"^code unary (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Phew! We're back to a C program we can compile. Fire it up and now you can run\r\nthis:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var breakfast = "beignets";\r\nvar beverage = "cafe au lait";\r\nbreakfast = "beignets with " + beverage;\r\n\r\nprint breakfast;\n'})}),"\n",(0,r.jsx)(n.p,{children:"It's starting to look like real code for an actual language!"}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The compiler adds a global variable's name to the constant table as a string\r\nevery time an identifier is encountered. It creates a new constant each\r\ntime, even if that variable name is already in a previous slot in the\r\nconstant table. That's wasteful in cases where the same variable is\r\nreferenced multiple times by the same function. That, in turn, increases the\r\nodds of filling up the constant table and running out of slots since we\r\nallow only 256 constants in a single chunk."}),"\n",(0,r.jsx)(n.p,{children:"Optimize this. How does your optimization affect the performance of the\r\ncompiler compared to the runtime? Is this the right trade-off?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Looking up a global variable by name in a hash table each time it is used\r\nis pretty slow, even with a good hash table. Can you come up with a more\r\nefficient way to store and access global variables without changing the\r\nsemantics?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'When running in the REPL, a user might write a function that references an\r\nunknown global variable. Then, in the next line, they declare the variable.\r\nLox should handle this gracefully by not reporting an "unknown variable"\r\ncompile error when the function is first defined.'}),"\n",(0,r.jsxs)(n.p,{children:["But when a user runs a Lox ",(0,r.jsx)(n.em,{children:"script"}),", the compiler has access to the full\r\ntext of the entire program before any code is run. Consider this program:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun useVar() {\r\n  print oops;\r\n}\r\n\r\nvar ooops = "too many o\'s!";\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, we can tell statically that ",(0,r.jsx)(n.code,{children:"oops"})," will not be defined because there\r\nis ",(0,r.jsx)(n.em,{children:"no"})," declaration of that global anywhere in the program. Note that\r\n",(0,r.jsx)(n.code,{children:"useVar()"})," is never called either, so even though the variable isn't\r\ndefined, no runtime error will occur because it's never used either."]}),"\n",(0,r.jsx)(n.p,{children:"We could report mistakes like this as compile errors, at least when running\r\nfrom a script. Do you think we should? Justify your answer. What do other\r\nscripting languages you know do?"}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);