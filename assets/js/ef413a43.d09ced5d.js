"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[536],{4499:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var r=t(4848),s=t(8453);const a={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/strings",title:"strings",description:'"Ah? A small aversion to menial labor?" The doctor cocked an eyebrow.',source:"@site/docs/Craftinginterpreters/not-translated-yet/strings.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/strings",permalink:"/docs/Craftinginterpreters/not-translated-yet/strings",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/strings.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"statements-and-state",permalink:"/docs/Craftinginterpreters/not-translated-yet/statements-and-state"},next:{title:"superclasses",permalink:"/docs/Craftinginterpreters/not-translated-yet/superclasses"}},l={},h=[{value:"Values and Objects",id:"values-and-objects",level:2},{value:"Struct Inheritance",id:"struct-inheritance",level:2},{value:"Strings",id:"strings",level:2},{value:"Operations on Strings",id:"operations-on-strings",level:2},{value:"Concatenation",id:"concatenation",level:3},{value:"Freeing Objects",id:"freeing-objects",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: String Encoding",id:"design-note-string-encoding",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:'"Ah? A small aversion to menial labor?" The doctor cocked an eyebrow.\r\n"Understandable, but misplaced. One should treasure those hum-drum\r\ntasks that keep the body occupied but leave the mind and heart unfettered."'}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["Tad Williams, ",(0,r.jsx)(n.em,{children:"The Dragonbone Chair"})]})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Our little VM can represent three types of values right now: numbers, Booleans,\r\nand ",(0,r.jsx)(n.code,{children:"nil"}),". Those types have two important things in common: they're immutable\r\nand they're small. Numbers are the largest, and they still fit into two 64-bit\r\nwords. That's a small enough price that we can afford to pay it for all values,\r\neven Booleans and nils which don't need that much space."]}),"\n",(0,r.jsxs)(n.p,{children:["Strings, unfortunately, are not so petite. There's no maximum length for a\r\nstring. Even if we were to artificially cap it at some contrived limit like\r\n",(0,r.jsx)(n.span,{name:"pascal",children:"255"})," characters, that's still too much memory to spend\r\non every single value."]}),"\n",(0,r.jsxs)(n.aside,{name:"pascal",children:["\n",(0,r.jsx)(n.p,{children:"UCSD Pascal, one of the first implementations of Pascal, had this exact limit.\r\nInstead of using a terminating null byte to indicate the end of the string like\r\nC, Pascal strings started with a length value. Since UCSD used only a single\r\nbyte to store the length, strings couldn't be any longer than 255 characters."}),"\n",(0,r.jsx)(n.img,{src:"image/strings/pstring.png",alt:"The Pascal string 'hello' with a length byte of 5 preceding it."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We need a way to support values whose sizes vary, sometimes greatly. This is\r\nexactly what dynamic allocation on the heap is designed for. We can allocate as\r\nmany bytes as we need. We get back a pointer that we'll use to keep track of the\r\nvalue as it flows through the VM."}),"\n",(0,r.jsx)(n.h2,{id:"values-and-objects",children:"Values and Objects"}),"\n",(0,r.jsx)(n.p,{children:"Using the heap for larger, variable-sized values and the stack for smaller,\r\natomic ones leads to a two-level representation. Every Lox value that you can\r\nstore in a variable or return from an expression will be a Value. For small,\r\nfixed-size types like numbers, the payload is stored directly inside the Value\r\nstruct itself."}),"\n",(0,r.jsxs)(n.p,{children:["If the object is larger, its data lives on the heap. Then the Value's payload is\r\na ",(0,r.jsx)(n.em,{children:"pointer"})," to that blob of memory. We'll eventually have a handful of\r\nheap-allocated types in clox: strings, instances, functions, you get the idea.\r\nEach type has its own unique data, but there is also state they all share that\r\n",(0,r.jsx)(n.a,{href:"garbage-collection.html",children:"our future garbage collector"})," will use to manage their memory."]}),"\n",(0,r.jsx)(n.img,{src:"image/strings/value.png",className:"wide",alt:"Field layout of number and obj values."}),"\n",(0,r.jsxs)(n.p,{children:["We'll call this common representation ",(0,r.jsx)(n.span,{name:"short",children:'"Obj"'}),". Each Lox\r\nvalue whose state lives on the heap is an Obj. We can thus use a single new\r\nValueType case to refer to all heap-allocated types."]}),"\n",(0,r.jsxs)(n.aside,{name:"short",children:["\n",(0,r.jsx)(n.p,{children:'"Obj" is short for "object", natch.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code val-obj (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["When a Value's type is ",(0,r.jsx)(n.code,{children:"VAL_OBJ"}),", the payload is a pointer to the heap memory,\r\nso we add another case to the union for that."]}),"\n",(0,r.jsx)(n.p,{children:"^code union-object (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"As we did with the other value types, we crank out a couple of helpful macros\r\nfor working with Obj values."}),"\n",(0,r.jsx)(n.p,{children:"^code is-obj (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This evaluates to ",(0,r.jsx)(n.code,{children:"true"})," if the given Value is an Obj. If so, we can use this:"]}),"\n",(0,r.jsx)(n.p,{children:"^code as-obj (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"It extracts the Obj pointer from the value. We can also go the other way."}),"\n",(0,r.jsx)(n.p,{children:"^code obj-val (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"This takes a bare Obj pointer and wraps it in a full Value."}),"\n",(0,r.jsx)(n.h2,{id:"struct-inheritance",children:"Struct Inheritance"}),"\n",(0,r.jsxs)(n.p,{children:["Every heap-allocated value is an Obj, but ",(0,r.jsx)(n.span,{name:"objs",children:"Objs"})," are\r\nnot all the same. For strings, we need the array of characters. When we get to\r\ninstances, they will need their data fields. A function object will need its\r\nchunk of bytecode. How do we handle different payloads and sizes? We can't use\r\nanother union like we did for Value since the sizes are all over the place."]}),"\n",(0,r.jsxs)(n.aside,{name:"objs",children:["\n",(0,r.jsx)(n.p,{children:'No, I don\'t know how to pronounce "objs" either. Feels like there should be a\r\nvowel in there somewhere.'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, we'll use another technique. It's been around for ages, to the point\r\nthat the C specification carves out specific support for it, but I don't know\r\nthat it has a canonical name. It's an example of ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Type_punning",children:(0,r.jsx)(n.em,{children:"type punning"})}),", but that\r\nterm is too broad. In the absence of any better ideas, I'll call it ",(0,r.jsx)(n.strong,{children:"struct\r\ninheritance"}),", because it relies on structs and roughly follows how\r\nsingle-inheritance of state works in object-oriented languages."]}),"\n",(0,r.jsx)(n.p,{children:"Like a tagged union, each Obj starts with a tag field that identifies what kind\r\nof object it is -- string, instance, etc. Following that are the payload fields.\r\nInstead of a union with cases for each type, each type is its own separate\r\nstruct. The tricky part is how to treat these structs uniformly since C has no\r\nconcept of inheritance or polymorphism. I'll explain that soon, but first lets\r\nget the preliminary stuff out of the way."}),"\n",(0,r.jsx)(n.p,{children:'The name "Obj" itself refers to a struct that contains the state shared across\r\nall object types. It\'s sort of like the "base class" for objects. Because of\r\nsome cyclic dependencies between values and objects, we forward-declare it in\r\nthe "value" module.'}),"\n",(0,r.jsx)(n.p,{children:"^code forward-declare-obj (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And the actual definition is in a new module."}),"\n",(0,r.jsx)(n.p,{children:"^code object-h"}),"\n",(0,r.jsx)(n.p,{children:"Right now, it contains only the type tag. Shortly, we'll add some other\r\nbookkeeping information for memory management. The type enum is this:"}),"\n",(0,r.jsx)(n.p,{children:"^code obj-type (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"Obviously, that will be more useful in later chapters after we add more\r\nheap-allocated types. Since we'll be accessing these tag types frequently, it's\r\nworth making a little macro that extracts the object type tag from a given\r\nValue."}),"\n",(0,r.jsx)(n.p,{children:"^code obj-type-macro (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"That's our foundation."}),"\n",(0,r.jsx)(n.p,{children:"Now, let's build strings on top of it. The payload for strings is defined in a\r\nseparate struct. Again, we need to forward-declare it."}),"\n",(0,r.jsx)(n.p,{children:"^code forward-declare-obj-string (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"The definition lives alongside Obj."}),"\n",(0,r.jsx)(n.p,{children:"^code obj-string (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"A string object contains an array of characters. Those are stored in a separate,\r\nheap-allocated array so that we set aside only as much room as needed for each\r\nstring. We also store the number of bytes in the array. This isn't strictly\r\nnecessary but lets us tell how much memory is allocated for the string without\r\nwalking the character array to find the null terminator."}),"\n",(0,r.jsx)(n.p,{children:"Because ObjString is an Obj, it also needs the state all Objs share. It\r\naccomplishes that by having its first field be an Obj. C specifies that struct\r\nfields are arranged in memory in the order that they are declared. Also, when\r\nyou nest structs, the inner struct's fields are expanded right in place. So the\r\nmemory for Obj and for ObjString looks like this:"}),"\n",(0,r.jsx)(n.img,{src:"image/strings/obj.png",alt:"The memory layout for the fields in Obj and ObjString."}),"\n",(0,r.jsxs)(n.p,{children:["Note how the first bytes of ObjString exactly line up with Obj. This is not a\r\ncoincidence -- C ",(0,r.jsx)(n.span,{name:"spec",children:"mandates"})," it. This is designed to\r\nenable a clever pattern: You can take a pointer to a struct and safely convert\r\nit to a pointer to its first field and back."]}),"\n",(0,r.jsxs)(n.aside,{name:"spec",children:["\n",(0,r.jsx)(n.p,{children:"The key part of the spec is:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"\xa7 6.7.2.1 13"}),"\n",(0,r.jsx)(n.p,{children:"Within a structure object, the non-bit-field members and the units in which\r\nbit-fields reside have addresses that increase in the order in which they\r\nare declared. A pointer to a structure object, suitably converted, points to\r\nits initial member (or if that member is a bit-field, then to the unit in\r\nwhich it resides), and vice versa. There may be unnamed padding within a\r\nstructure object, but not at its beginning."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Given an ",(0,r.jsx)(n.code,{children:"ObjString*"}),", you can safely cast it to ",(0,r.jsx)(n.code,{children:"Obj*"})," and then access the\r\n",(0,r.jsx)(n.code,{children:"type"}),' field from it. Every ObjString "is" an Obj in the OOP sense of "is". When\r\nwe later add other object types, each struct will have an Obj as its first\r\nfield. Any code that wants to work with all objects can treat them as base\r\n',(0,r.jsx)(n.code,{children:"Obj*"})," and ignore any other fields that may happen to follow."]}),"\n",(0,r.jsxs)(n.p,{children:["You can go in the other direction too. Given an ",(0,r.jsx)(n.code,{children:"Obj*"}),', you can "downcast" it to\r\nan ',(0,r.jsx)(n.code,{children:"ObjString*"}),". Of course, you need to ensure that the ",(0,r.jsx)(n.code,{children:"Obj*"})," pointer you have\r\ndoes point to the ",(0,r.jsx)(n.code,{children:"obj"})," field of an actual ObjString. Otherwise, you are\r\nunsafely reinterpreting random bits of memory. To detect that such a cast is\r\nsafe, we add another macro."]}),"\n",(0,r.jsx)(n.p,{children:"^code is-string (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["It takes a Value, not a raw ",(0,r.jsx)(n.code,{children:"Obj*"})," because most code in the VM works with\r\nValues. It relies on this inline function:"]}),"\n",(0,r.jsx)(n.p,{children:"^code is-obj-type (2 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Pop quiz: Why not just put the body of this function right in the macro? What's\r\ndifferent about this one compared to the others? Right, it's because the body\r\nuses ",(0,r.jsx)(n.code,{children:"value"})," twice. A macro is expanded by inserting the argument ",(0,r.jsx)(n.em,{children:"expression"}),"\r\nevery place the parameter name appears in the body. If a macro uses a parameter\r\nmore than once, that expression gets evaluated multiple times."]}),"\n",(0,r.jsxs)(n.p,{children:["That's bad if the expression has side effects. If we put the body of\r\n",(0,r.jsx)(n.code,{children:"isObjType()"})," into the macro definition and then you did, say,"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"IS_STRING(POP())\n"})}),"\n",(0,r.jsx)(n.p,{children:"then it would pop two values off the stack! Using a function fixes that."}),"\n",(0,r.jsx)(n.p,{children:"As long as we ensure that we set the type tag correctly whenever we create an\r\nObj of some type, this macro will tell us when it's safe to cast a value to a\r\nspecific object type. We can do that using these:"}),"\n",(0,r.jsx)(n.p,{children:"^code as-string (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["These two macros take a Value that is expected to contain a pointer to a valid\r\nObjString on the heap. The first one returns the ",(0,r.jsx)(n.code,{children:"ObjString*"})," pointer. The\r\nsecond one steps through that to return the character array itself, since that's\r\noften what we'll end up needing."]}),"\n",(0,r.jsx)(n.h2,{id:"strings",children:"Strings"}),"\n",(0,r.jsx)(n.p,{children:"OK, our VM can now represent string values. It's time to add strings to the\r\nlanguage itself. As usual, we begin in the front end. The lexer already\r\ntokenizes string literals, so it's the parser's turn."}),"\n",(0,r.jsx)(n.p,{children:"^code table-string (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"When the parser hits a string token, it calls this parse function:"}),"\n",(0,r.jsx)(n.p,{children:"^code parse-string"}),"\n",(0,r.jsxs)(n.p,{children:["This takes the string's characters ",(0,r.jsx)(n.span,{name:"escape",children:"directly"})," from the\r\nlexeme. The ",(0,r.jsx)(n.code,{children:"+ 1"})," and ",(0,r.jsx)(n.code,{children:"- 2"})," parts trim the leading and trailing quotation marks.\r\nIt then creates a string object, wraps it in a Value, and stuffs it into the\r\nconstant table."]}),"\n",(0,r.jsxs)(n.aside,{name:"escape",children:["\n",(0,r.jsxs)(n.p,{children:["If Lox supported string escape sequences like ",(0,r.jsx)(n.code,{children:"\\n"}),", we'd translate those here.\r\nSince it doesn't, we can take the characters as they are."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["To create the string, we use ",(0,r.jsx)(n.code,{children:"copyString()"}),", which is declared in ",(0,r.jsx)(n.code,{children:"object.h"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code copy-string-h (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The compiler module needs to include that."}),"\n",(0,r.jsx)(n.p,{children:"^code compiler-include-object (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:'Our "object" module gets an implementation file where we define the new\r\nfunction.'}),"\n",(0,r.jsx)(n.p,{children:"^code object-c"}),"\n",(0,r.jsxs)(n.p,{children:["First, we allocate a new array on the heap, just big enough for the string's\r\ncharacters and the trailing ",(0,r.jsx)(n.span,{name:"terminator",children:"terminator"}),", using\r\nthis low-level macro that allocates an array with a given element type and\r\ncount:"]}),"\n",(0,r.jsx)(n.p,{children:"^code allocate (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Once we have the array, we copy over the characters from the lexeme and\r\nterminate it."}),"\n",(0,r.jsxs)(n.aside,{name:"terminator",className:"bottom",children:["\n",(0,r.jsx)(n.p,{children:"We need to terminate the string ourselves because the lexeme points at a range\r\nof characters inside the monolithic source string and isn't terminated."}),"\n",(0,r.jsxs)(n.p,{children:["Since ObjString stores the length explicitly, we ",(0,r.jsx)(n.em,{children:"could"})," leave the character\r\narray unterminated, but slapping a terminator on the end costs us only a byte\r\nand lets us pass the character array to C standard library functions that expect\r\na terminated string."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You might wonder why the ObjString can't just point back to the original\r\ncharacters in the source string. Some ObjStrings will be created dynamically at\r\nruntime as a result of string operations like concatenation. Those strings\r\nobviously need to dynamically allocate memory for the characters, which means\r\nthe string needs to ",(0,r.jsx)(n.em,{children:"free"})," that memory when it's no longer needed."]}),"\n",(0,r.jsx)(n.p,{children:"If we had an ObjString for a string literal, and tried to free its character\r\narray that pointed into the original source code string, bad things would\r\nhappen. So, for literals, we preemptively copy the characters over to the heap.\r\nThis way, every ObjString reliably owns its character array and can free it."}),"\n",(0,r.jsx)(n.p,{children:"The real work of creating a string object happens in this function:"}),"\n",(0,r.jsx)(n.p,{children:"^code allocate-string (2 before)"}),"\n",(0,r.jsx)(n.p,{children:'It creates a new ObjString on the heap and then initializes its fields. It\'s\r\nsort of like a constructor in an OOP language. As such, it first calls the "base\r\nclass" constructor to initialize the Obj state, using a new macro.'}),"\n",(0,r.jsx)(n.p,{children:"^code allocate-obj (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"factored",children:"Like"})," the previous macro, this exists mainly to\r\navoid the need to redundantly cast a ",(0,r.jsx)(n.code,{children:"void*"})," back to the desired type. The\r\nactual functionality is here:"]}),"\n",(0,r.jsxs)(n.aside,{name:"factored",children:["\n",(0,r.jsx)(n.p,{children:"I admit this chapter has a sea of helper functions and macros to wade through. I\r\ntry to keep the code nicely factored, but that leads to a scattering of tiny\r\nfunctions. They will pay off when we reuse them later."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code allocate-object (2 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["It allocates an object of the given size on the heap. Note that the size is\r\n",(0,r.jsx)(n.em,{children:"not"})," just the size of Obj itself. The caller passes in the number of bytes so\r\nthat there is room for the extra payload fields needed by the specific object\r\ntype being created."]}),"\n",(0,r.jsxs)(n.p,{children:["Then it initializes the Obj state -- right now, that's just the type tag. This\r\nfunction returns to ",(0,r.jsx)(n.code,{children:"allocateString()"}),", which finishes initializing the ObjString\r\nfields. ",(0,r.jsx)(n.span,{name:"viola",children:(0,r.jsx)(n.em,{children:"Voil\xe0"})}),", we can compile and execute string\r\nliterals."]}),"\n",(0,r.jsxs)(n.aside,{name:"viola",children:["\n",(0,r.jsx)(n.img,{src:"image/strings/viola.png",className:"above",alt:"A viola."}),"\n",(0,r.jsx)(n.p,{children:'Don\'t get "voil\xe0" confused with "viola". One means "there it is" and the other\r\nis a string instrument, the middle child between a violin and a cello. Yes, I\r\ndid spend two hours drawing a viola just to mention that.'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"operations-on-strings",children:"Operations on Strings"}),"\n",(0,r.jsx)(n.p,{children:"Our fancy strings are there, but they don't do much of anything yet. A good\r\nfirst step is to make the existing print code not barf on the new value type."}),"\n",(0,r.jsx)(n.p,{children:"^code call-print-object (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:'If the value is a heap-allocated object, it defers to a helper function over in\r\nthe "object" module.'}),"\n",(0,r.jsx)(n.p,{children:"^code print-object-h (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"The implementation looks like this:"}),"\n",(0,r.jsx)(n.p,{children:"^code print-object"}),"\n",(0,r.jsxs)(n.p,{children:["We have only a single object type now, but this function will sprout additional\r\nswitch cases in later chapters. For string objects, it simply ",(0,r.jsx)(n.span,{name:"term-2",children:"prints"})," the character array as a C string."]}),"\n",(0,r.jsxs)(n.aside,{name:"term-2",children:["\n",(0,r.jsx)(n.p,{children:"I told you terminating the string would come in handy."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The equality operators also need to gracefully handle strings. Consider:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'"string" == "string"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["These are two separate string literals. The compiler will make two separate\r\ncalls to ",(0,r.jsx)(n.code,{children:"copyString()"}),", create two distinct ObjString objects and store them as\r\ntwo constants in the chunk. They are different objects in the heap. But our\r\nusers (and thus we) expect strings to have value equality. The above expression\r\nshould evaluate to ",(0,r.jsx)(n.code,{children:"true"}),". That requires a little special support."]}),"\n",(0,r.jsx)(n.p,{children:"^code strings-equal (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["If the two values are both strings, then they are equal if their character\r\narrays contain the same characters, regardless of whether they are two separate\r\nobjects or the exact same one. This does mean that string equality is slower\r\nthan equality on other types since it has to walk the whole string. We'll revise\r\nthat ",(0,r.jsx)(n.a,{href:"hash-tables.html",children:"later"}),", but this gives us the right semantics for now."]}),"\n",(0,r.jsxs)(n.p,{children:["Finally, in order to use ",(0,r.jsx)(n.code,{children:"memcmp()"}),' and the new stuff in the "object" module, we\r\nneed a couple of includes. Here:']}),"\n",(0,r.jsx)(n.p,{children:"^code value-include-string (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"And here:"}),"\n",(0,r.jsx)(n.p,{children:"^code value-include-object (2 before, 1 after)"}),"\n",(0,r.jsx)(n.h3,{id:"concatenation",children:"Concatenation"}),"\n",(0,r.jsxs)(n.p,{children:["Full-grown languages provide lots of operations for working with strings --\r\naccess to individual characters, the string's length, changing case, splitting,\r\njoining, searching, etc. When you implement your language, you'll likely want\r\nall that. But for this book, we keep things ",(0,r.jsx)(n.em,{children:"very"})," minimal."]}),"\n",(0,r.jsxs)(n.p,{children:["The only interesting operation we support on strings is ",(0,r.jsx)(n.code,{children:"+"}),". If you use that\r\noperator on two string objects, it produces a new string that's a concatenation\r\nof the two operands. Since Lox is dynamically typed, we can't tell which\r\nbehavior is needed at compile time because we don't know the types of the\r\noperands until runtime. Thus, the ",(0,r.jsx)(n.code,{children:"OP_ADD"})," instruction dynamically inspects the\r\noperands and chooses the right operation."]}),"\n",(0,r.jsx)(n.p,{children:"^code add-strings (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["If both operands are strings, it concatenates. If they're both numbers, it adds\r\nthem. Any other ",(0,r.jsx)(n.span,{name:"convert",children:"combination"})," of operand types is a\r\nruntime error."]}),"\n",(0,r.jsxs)(n.aside,{name:"convert",className:"bottom",children:["\n",(0,r.jsx)(n.p,{children:"This is more conservative than most languages. In other languages, if one\r\noperand is a string, the other can be any type and it will be implicitly\r\nconverted to a string before concatenating the two."}),"\n",(0,r.jsx)(n.p,{children:'I think that\'s a fine feature, but would require writing tedious "convert to\r\nstring" code for each type, so I left it out of Lox.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"To concatenate strings, we define a new function."}),"\n",(0,r.jsx)(n.p,{children:"^code concatenate"}),"\n",(0,r.jsx)(n.p,{children:"It's pretty verbose, as C code that works with strings tends to be. First, we\r\ncalculate the length of the result string based on the lengths of the operands.\r\nWe allocate a character array for the result and then copy the two halves in. As\r\nalways, we carefully ensure the string is terminated."}),"\n",(0,r.jsxs)(n.p,{children:["In order to call ",(0,r.jsx)(n.code,{children:"memcpy()"}),", the VM needs an include."]}),"\n",(0,r.jsx)(n.p,{children:"^code vm-include-string (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we produce an ObjString to contain those characters. This time we use a\r\nnew function, ",(0,r.jsx)(n.code,{children:"takeString()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code take-string-h (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The implementation looks like this:"}),"\n",(0,r.jsx)(n.p,{children:"^code take-string"}),"\n",(0,r.jsxs)(n.p,{children:["The previous ",(0,r.jsx)(n.code,{children:"copyString()"})," function assumes it ",(0,r.jsx)(n.em,{children:"cannot"})," take ownership of the\r\ncharacters you pass in. Instead, it conservatively creates a copy of the\r\ncharacters on the heap that the ObjString can own. That's the right thing for\r\nstring literals where the passed-in characters are in the middle of the source\r\nstring."]}),"\n",(0,r.jsxs)(n.p,{children:["But, for concatenation, we've already dynamically allocated a character array on\r\nthe heap. Making another copy of that would be redundant (and would mean\r\n",(0,r.jsx)(n.code,{children:"concatenate()"})," has to remember to free its copy). Instead, this function claims\r\nownership of the string you give it."]}),"\n",(0,r.jsx)(n.p,{children:"As usual, stitching this functionality together requires a couple of includes."}),"\n",(0,r.jsx)(n.p,{children:"^code vm-include-object-memory (1 before, 1 after)"}),"\n",(0,r.jsx)(n.h2,{id:"freeing-objects",children:"Freeing Objects"}),"\n",(0,r.jsx)(n.p,{children:"Behold this innocuous-seeming expression:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'"st" + "ri" + "ng"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When the compiler chews through this, it allocates an ObjString for each of\r\nthose three string literals and stores them in the chunk's constant table and\r\ngenerates this ",(0,r.jsx)(n.span,{name:"stack",children:"bytecode"}),":"]}),"\n",(0,r.jsxs)(n.aside,{name:"stack",children:["\n",(0,r.jsx)(n.p,{children:"Here's what the stack looks like after each instruction:"}),"\n",(0,r.jsx)(n.img,{src:"image/strings/stack.png",alt:"The state of the stack at each instruction."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'0000    OP_CONSTANT         0 "st"\r\n0002    OP_CONSTANT         1 "ri"\r\n0004    OP_ADD\r\n0005    OP_CONSTANT         2 "ng"\r\n0007    OP_ADD\r\n0008    OP_RETURN\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The first two instructions push ",(0,r.jsx)(n.code,{children:'"st"'})," and ",(0,r.jsx)(n.code,{children:'"ri"'})," onto the stack. Then the\r\n",(0,r.jsx)(n.code,{children:"OP_ADD"})," pops those and concatenates them. That dynamically allocates a new\r\n",(0,r.jsx)(n.code,{children:'"stri"'})," string on the heap. The VM pushes that and then pushes the ",(0,r.jsx)(n.code,{children:'"ng"'}),"\r\nconstant. The last ",(0,r.jsx)(n.code,{children:"OP_ADD"})," pops ",(0,r.jsx)(n.code,{children:'"stri"'})," and ",(0,r.jsx)(n.code,{children:'"ng"'}),", concatenates them, and\r\npushes the result: ",(0,r.jsx)(n.code,{children:'"string"'}),". Great, that's what we expect."]}),"\n",(0,r.jsxs)(n.p,{children:["But, wait. What happened to that ",(0,r.jsx)(n.code,{children:'"stri"'})," string? We dynamically allocated it,\r\nthen the VM discarded it after concatenating it with ",(0,r.jsx)(n.code,{children:'"ng"'}),". We popped it from\r\nthe stack and no longer have a reference to it, but we never freed its memory.\r\nWe've got ourselves a classic memory leak."]}),"\n",(0,r.jsxs)(n.p,{children:["Of course, it's perfectly fine for the ",(0,r.jsx)(n.em,{children:"Lox program"})," to forget about\r\nintermediate strings and not worry about freeing them. Lox automatically manages\r\nmemory on the user's behalf. The responsibility to manage memory doesn't\r\n",(0,r.jsx)(n.em,{children:"disappear"}),". Instead, it falls on our shoulders as VM implementers."]}),"\n",(0,r.jsxs)(n.p,{children:["The full ",(0,r.jsx)(n.span,{name:"borrowed",children:"solution"})," is a ",(0,r.jsx)(n.a,{href:"garbage-collection.html",children:"garbage collector"})," that\r\nreclaims unused memory while the program is running. We've got some other stuff\r\nto get in place before we're ready to tackle that project. Until then, we are\r\nliving on borrowed time. The longer we wait to add the collector, the harder it\r\nis to do."]}),"\n",(0,r.jsxs)(n.aside,{name:"borrowed",children:["\n",(0,r.jsx)(n.p,{children:"I've seen a number of people implement large swathes of their language before\r\ntrying to start on the GC. For the kind of toy programs you typically run while\r\na language is being developed, you actually don't run out of memory before\r\nreaching the end of the program, so this gets you surprisingly far."}),"\n",(0,r.jsxs)(n.p,{children:["But that underestimates how ",(0,r.jsx)(n.em,{children:"hard"})," it is to add a garbage collector later. The\r\ncollector ",(0,r.jsx)(n.em,{children:"must"})," ensure it can find every bit of memory that ",(0,r.jsx)(n.em,{children:"is"})," still being\r\nused so that it doesn't collect live data. There are hundreds of places a\r\nlanguage implementation can squirrel away a reference to some object. If you\r\ndon't find all of them, you get nightmarish bugs."]}),"\n",(0,r.jsx)(n.p,{children:"I've seen language implementations die because it was too hard to get the GC in\r\nlater. If your language needs GC, get it working as soon as you can. It's a\r\ncrosscutting concern that touches the entire codebase."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Today, we should at least do the bare minimum: avoid ",(0,r.jsx)(n.em,{children:"leaking"})," memory by making\r\nsure the VM can still find every allocated object even if the Lox program itself\r\nno longer references them. There are many sophisticated techniques that advanced\r\nmemory managers use to allocate and track memory for objects. We're going to\r\ntake the simplest practical approach."]}),"\n",(0,r.jsx)(n.p,{children:"We'll create a linked list that stores every Obj. The VM can traverse that\r\nlist to find every single object that has been allocated on the heap, whether or\r\nnot the user's program or the VM's stack still has a reference to it."}),"\n",(0,r.jsxs)(n.p,{children:["We could define a separate linked list node struct but then we'd have to\r\nallocate those too. Instead, we'll use an ",(0,r.jsx)(n.strong,{children:"intrusive list"})," -- the Obj struct\r\nitself will be the linked list node. Each Obj gets a pointer to the next Obj in\r\nthe chain."]}),"\n",(0,r.jsx)(n.p,{children:"^code next-field (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The VM stores a pointer to the head of the list."}),"\n",(0,r.jsx)(n.p,{children:"^code objects-root (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"When we first initialize the VM, there are no allocated objects."}),"\n",(0,r.jsx)(n.p,{children:"^code init-objects-root (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Every time we allocate an Obj, we insert it in the list."}),"\n",(0,r.jsx)(n.p,{children:"^code add-to-list (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Since this is a singly linked list, the easiest place to insert it is as the\r\nhead. That way, we don't need to also store a pointer to the tail and keep it\r\nupdated."}),"\n",(0,r.jsxs)(n.p,{children:['The "object" module is directly using the global ',(0,r.jsx)(n.code,{children:"vm"}),' variable from the "vm"\r\nmodule, so we need to expose that externally.']}),"\n",(0,r.jsx)(n.p,{children:"^code extern-vm (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Eventually, the garbage collector will free memory while the VM is still\r\nrunning. But, even then, there will usually be unused objects still lingering in\r\nmemory when the user's program completes. The VM should free those too."}),"\n",(0,r.jsxs)(n.p,{children:["There's no sophisticated logic for that. Once the program is done, we can free\r\n",(0,r.jsx)(n.em,{children:"every"})," object. We can and should implement that now."]}),"\n",(0,r.jsx)(n.p,{children:"^code call-free-objects (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["That empty function we defined ",(0,r.jsx)(n.a,{href:"a-virtual-machine.html#an-instruction-execution-machine",children:"way back when"})," finally does something! It\r\ncalls this:"]}),"\n",(0,r.jsx)(n.p,{children:"^code free-objects-h (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"Here's how we free the objects:"}),"\n",(0,r.jsx)(n.p,{children:"^code free-objects"}),"\n",(0,r.jsx)(n.p,{children:"This is a CS 101 textbook implementation of walking a linked list and freeing\r\nits nodes. For each node, we call:"}),"\n",(0,r.jsx)(n.p,{children:"^code free-object"}),"\n",(0,r.jsx)(n.p,{children:"We aren't only freeing the Obj itself. Since some object types also allocate\r\nother memory that they own, we also need a little type-specific code to handle\r\neach object type's special needs. Here, that means we free the character array\r\nand then free the ObjString. Those both use one last memory management macro."}),"\n",(0,r.jsx)(n.p,{children:"^code free (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["It's a tiny ",(0,r.jsx)(n.span,{name:"free",children:"wrapper"})," around ",(0,r.jsx)(n.code,{children:"reallocate()"}),' that\r\n"resizes" an allocation down to zero bytes.']}),"\n",(0,r.jsxs)(n.aside,{name:"free",children:["\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"reallocate()"})," to free memory might seem pointless. Why not just call\r\n",(0,r.jsx)(n.code,{children:"free()"}),"? Later, this will help the VM track how much memory is still being\r\nused. If all allocation and freeing goes through ",(0,r.jsx)(n.code,{children:"reallocate()"}),", it's easy to\r\nkeep a running count of the number of bytes of allocated memory."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"As usual, we need an include to wire everything together."}),"\n",(0,r.jsx)(n.p,{children:"^code memory-include-object (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"Then in the implementation file:"}),"\n",(0,r.jsx)(n.p,{children:"^code memory-include-vm (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"With this, our VM no longer leaks memory. Like a good C program, it cleans up\r\nits mess before exiting. But it doesn't free any objects while the VM is\r\nrunning. Later, when it's possible to write longer-running Lox programs, the VM\r\nwill eat more and more memory as it goes, not relinquishing a single byte until\r\nthe entire program is done."}),"\n",(0,r.jsxs)(n.p,{children:["We won't address that until we've added ",(0,r.jsx)(n.a,{href:"garbage-collection.html",children:"a real garbage collector"}),", but this\r\nis a big step. We now have the infrastructure to support a variety of different\r\nkinds of dynamically allocated objects. And we've used that to add strings to\r\nclox, one of the most used types in most programming languages. Strings in turn\r\nenable us to build another fundamental data type, especially in dynamic\r\nlanguages: the venerable ",(0,r.jsx)(n.a,{href:"hash-tables.html",children:"hash table"}),". But that's for the next chapter..."]}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Each string requires two separate dynamic allocations -- one for the\r\nObjString and a second for the character array. Accessing the characters\r\nfrom a value requires two pointer indirections, which can be bad for\r\nperformance. A more efficient solution relies on a technique called\r\n",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Flexible_array_member",children:"flexible array members"})}),". Use that to store the ObjString and its\r\ncharacter array in a single contiguous allocation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"When we create the ObjString for each string literal, we copy the characters\r\nonto the heap. That way, when the string is later freed, we know it is safe\r\nto free the characters too."}),"\n",(0,r.jsx)(n.p,{children:'This is a simpler approach but wastes some memory, which might be a problem\r\non very constrained devices. Instead, we could keep track of which\r\nObjStrings own their character array and which are "constant strings" that\r\njust point back to the original source string or some other non-freeable\r\nlocation. Add support for this.'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If Lox was your language, what would you have it do when a user tries to use\r\n",(0,r.jsx)(n.code,{children:"+"})," with one string operand and the other some other type? Justify your\r\nchoice. What do other languages do?"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.div,{className:"design-note",children:["\n",(0,r.jsx)(n.h2,{id:"design-note-string-encoding",children:"Design Note: String Encoding"}),"\n",(0,r.jsxs)(n.p,{children:["In this book, I try not to shy away from the gnarly problems you'll run into in\r\na real language implementation. We might not always use the most ",(0,r.jsx)(n.em,{children:"sophisticated"}),"\r\nsolution -- it's an intro book after all -- but I don't think it's honest to\r\npretend the problem doesn't exist at all. However, I did skirt around one really\r\nnasty conundrum: deciding how to represent strings."]}),"\n",(0,r.jsx)(n.p,{children:"There are two facets to a string encoding:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:'What is a single "character" in a string?'})," How many different values are\r\nthere and what do they represent? The first widely adopted standard answer\r\nto this was ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/ASCII",children:"ASCII"}),'. It gave you 127 different character values and\r\nspecified what they were. It was great... if you only ever cared about\r\nEnglish. While it has weird, mostly forgotten characters like "record\r\nseparator" and "synchronous idle", it doesn\'t have a single umlaut, acute,\r\nor grave. It can\'t represent "jalape\xf1o", "na\xefve", ',(0,r.jsx)(n.span,{name:"gruyere",children:'"Gruy\xe8re"'}),', or "M\xf6tley Cr\xfce".']}),"\n",(0,r.jsxs)(n.aside,{name:"gruyere",children:["\n",(0,r.jsx)(n.p,{children:"It goes without saying that a language that does not let one discuss Gruy\xe8re\r\nor M\xf6tley Cr\xfce is a language not worth using."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Next came ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Unicode",children:"Unicode"}),". Initially, it supported 16,384 different characters\r\n(",(0,r.jsx)(n.strong,{children:"code points"}),"), which fit nicely in 16 bits with a couple of bits to\r\nspare. Later that grew and grew, and now there are well over 100,000\r\ndifferent code points including such vital instruments of human\r\ncommunication as \ud83d\udca9 (Unicode Character 'PILE OF POO', ",(0,r.jsx)(n.code,{children:"U+1F4A9"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["Even that long list of code points is not enough to represent each possible\r\nvisible glyph a language might support. To handle that, Unicode also has\r\n",(0,r.jsx)(n.strong,{children:"combining characters"}),' that modify a preceding code point. For example,\r\n"a" followed by the combining character "\xa8" gives you "\xe4". (To make things\r\nmore confusing Unicode ',(0,r.jsx)(n.em,{children:"also"}),' has a single code point that looks like "\xe4".)']}),"\n",(0,r.jsxs)(n.p,{children:['If a user accesses the fourth "character" in "na\xefve", do they expect to get\r\nback "v" or \u201c\xa8\u201d? The former means they are thinking of each code\r\npoint and its combining character as a single unit -- what Unicode calls an\r\n',(0,r.jsx)(n.strong,{children:"extended grapheme cluster"})," -- the latter means they are thinking in\r\nindividual code points. Which do your users expect?"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"How is a single unit represented in memory?"})," Most systems using ASCII\r\ngave a single byte to each character and left the high bit unused. Unicode\r\nhas a handful of common encodings. UTF-16 packs most code points into 16\r\nbits. That was great when every code point fit in that size. When that\r\noverflowed, they added ",(0,r.jsx)(n.em,{children:"surrogate pairs"})," that use multiple 16-bit code units\r\nto represent a single code point. UTF-32 is the next evolution of\r\nUTF-16 -- it gives a full 32 bits to each and every code point."]}),"\n",(0,r.jsx)(n.p,{children:"UTF-8 is more complex than either of those. It uses a variable number of\r\nbytes to encode a code point. Lower-valued code points fit in fewer bytes.\r\nSince each character may occupy a different number of bytes, you can't\r\ndirectly index into the string to find a specific code point. If you want,\r\nsay, the 10th code point, you don't know how many bytes into the string that\r\nis without walking and decoding all of the preceding ones."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Choosing a character representation and encoding involves fundamental\r\ntrade-offs. Like many things in engineering, there's no ",(0,r.jsx)(n.span,{name:"python",children:"perfect"})," solution:"]}),"\n",(0,r.jsxs)(n.aside,{name:"python",children:["\n",(0,r.jsx)(n.p,{children:"An example of how difficult this problem is comes from Python. The achingly long\r\ntransition from Python 2 to 3 is painful mostly because of its changes around\r\nstring encoding."}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"ASCII is memory efficient and fast, but it kicks non-Latin languages to the\r\nside."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"UTF-32 is fast and supports the whole Unicode range, but wastes a lot of\r\nmemory given that most code points do tend to be in the lower range of\r\nvalues, where a full 32 bits aren't needed."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"UTF-8 is memory efficient and supports the whole Unicode range, but its\r\nvariable-length encoding makes it slow to access arbitrary code points."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"UTF-16 is worse than all of them -- an ugly consequence of Unicode\r\noutgrowing its earlier 16-bit range. It's less memory efficient than UTF-8\r\nbut is still a variable-length encoding thanks to surrogate pairs. Avoid it\r\nif you can. Alas, if your language needs to run on or interoperate with the\r\nbrowser, the JVM, or the CLR, you might be stuck with it, since those all\r\nuse UTF-16 for their strings and you don't want to have to convert every\r\ntime you pass a string to the underlying system."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'One option is to take the maximal approach and do the "rightest" thing. Support\r\nall the Unicode code points. Internally, select an encoding for each string\r\nbased on its contents -- use ASCII if every code point fits in a byte, UTF-16 if\r\nthere are no surrogate pairs, etc. Provide APIs to let users iterate over both\r\ncode points and extended grapheme clusters.'}),"\n",(0,r.jsx)(n.p,{children:"This covers all your bases but is really complex. It's a lot to implement,\r\ndebug, and optimize. When serializing strings or interoperating with other\r\nsystems, you have to deal with all of the encodings. Users need to understand\r\nthe two indexing APIs and know which to use when. This is the approach that\r\nnewer, big languages tend to take -- like Raku and Swift."}),"\n",(0,r.jsxs)(n.p,{children:["A simpler compromise is to always encode using UTF-8 and only expose an API that\r\nworks with code points. For users that want to work with grapheme clusters, let\r\nthem use a third-party library for that. This is less Latin-centric than ASCII\r\nbut not much more complex. You lose fast direct indexing by code point, but you\r\ncan usually live without that or afford to make it ",(0,r.jsx)(n.em,{children:"O(n)"})," instead of ",(0,r.jsx)(n.em,{children:"O(1)"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If I were designing a big workhorse language for people writing large\r\napplications, I'd probably go with the maximal approach. For my little embedded\r\nscripting language ",(0,r.jsx)(n.a,{href:"http://wren.io",children:"Wren"}),", I went with UTF-8 and code points."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);