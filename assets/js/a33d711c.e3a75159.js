"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[9930],{6977:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var s=t(4848),r=t(8453);const i={},a=void 0,o={id:"Craftinginterpreters/not-translated-yet/control-flow",title:"control-flow",description:"Logic, like whiskey, loses its beneficial effect when taken in too large",source:"@site/docs/Craftinginterpreters/not-translated-yet/control-flow.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/control-flow",permalink:"/docs/Craftinginterpreters/not-translated-yet/control-flow",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/control-flow.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"contents",permalink:"/docs/Craftinginterpreters/not-translated-yet/contents"},next:{title:"dedication",permalink:"/docs/Craftinginterpreters/not-translated-yet/dedication"}},l={},h=[{value:"Turing Machines (Briefly)",id:"turing-machines-briefly",level:2},{value:"Conditional Execution",id:"conditional-execution",level:2},{value:"Logical Operators",id:"logical-operators",level:2},{value:"While Loops",id:"while-loops",level:2},{value:"For Loops",id:"for-loops",level:2},{value:"Desugaring",id:"desugaring",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Spoonfuls of Syntactic Sugar",id:"design-note-spoonfuls-of-syntactic-sugar",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Logic, like whiskey, loses its beneficial effect when taken in too large\r\nquantities."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.cite,{children:"Edward John Moreton Drax Plunkett, Lord Dunsany"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Compared to ",(0,s.jsx)(n.a,{href:"statements-and-state.html",children:"last chapter's"})," grueling marathon, today is a\r\nlighthearted frolic through a daisy meadow. But while the work is easy, the\r\nreward is surprisingly large."]}),"\n",(0,s.jsxs)(n.p,{children:["Right now, our interpreter is little more than a calculator. A Lox program can\r\nonly do a fixed amount of work before completing. To make it run twice as long\r\nyou have to make the source code twice as lengthy. We're about to fix that. In\r\nthis chapter, our interpreter takes a big step towards the programming\r\nlanguage major leagues: ",(0,s.jsx)(n.em,{children:"Turing-completeness"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"turing-machines-briefly",children:"Turing Machines (Briefly)"}),"\n",(0,s.jsxs)(n.p,{children:["In the early part of last century, mathematicians stumbled into a series of\r\nconfusing ",(0,s.jsx)(n.span,{name:"paradox",children:"paradoxes"})," that led them to doubt the\r\nstability of the foundation they had built their work upon. To address that\r\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis",children:"crisis"}),", they went back to square one. Starting from a handful of axioms,\r\nlogic, and set theory, they hoped to rebuild mathematics on top of an\r\nimpervious foundation."]}),"\n",(0,s.jsxs)(n.aside,{name:"paradox",children:["\n",(0,s.jsxs)(n.p,{children:["The most famous is ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Russell%27s_paradox",children:(0,s.jsx)(n.strong,{children:"Russell's paradox"})}),". Initially, set theory\r\nallowed you to define any sort of set. If you could describe it in English, it\r\nwas valid. Naturally, given mathematicians' predilection for self-reference,\r\nsets can contain other sets. So Russell, rascal that he was, came up with:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"R is the set of all sets that do not contain themselves."})}),"\n",(0,s.jsx)(n.p,{children:"Does R contain itself? If it doesn't, then according to the second half of the\r\ndefinition it should. But if it does, then it no longer meets the definition.\r\nCue mind exploding."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['They wanted to rigorously answer questions like, "Can all true statements be\r\nproven?", "Can we ',(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Computable_function",children:"compute"}),' all functions that we can define?", or even the\r\nmore general question, "What do we mean when we claim a function is\r\n\'computable\'?"']}),"\n",(0,s.jsx)(n.p,{children:'They presumed the answer to the first two questions would be "yes". All that\r\nremained was to prove it. It turns out that the answer to both is "no", and\r\nastonishingly, the two questions are deeply intertwined. This is a fascinating\r\ncorner of mathematics that touches fundamental questions about what brains are\r\nable to do and how the universe works. I can\'t do it justice here.'}),"\n",(0,s.jsxs)(n.p,{children:['What I do want to note is that in the process of proving that the answer to the\r\nfirst two questions is "no", Alan Turing and Alonzo Church devised a precise\r\nanswer to the last question -- a definition of what kinds of functions are ',(0,s.jsx)(n.span,{name:"uncomputable",children:"computable"}),". They each crafted a tiny system with a\r\nminimum set of machinery that is still powerful enough to compute any of a\r\n(very) large class of functions."]}),"\n",(0,s.jsxs)(n.aside,{name:"uncomputable",children:["\n",(0,s.jsxs)(n.p,{children:['They proved the answer to the first question is "no" by showing that the\r\nfunction that returns the truth value of a given statement is ',(0,s.jsx)(n.em,{children:"not"})," a computable\r\none."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['These are now considered the "computable functions". Turing\'s system is called a\r\n',(0,s.jsx)(n.span,{name:"turing",children:(0,s.jsx)(n.strong,{children:"Turing machine"})}),". Church's is the ",(0,s.jsx)(n.strong,{children:"lambda\r\ncalculus"}),". Both are still widely used as the basis for models of computation\r\nand, in fact, many modern functional programming languages use the lambda\r\ncalculus at their core."]}),"\n",(0,s.jsxs)(n.aside,{name:"turing",children:["\n",(0,s.jsxs)(n.p,{children:['Turing called his inventions "a-machines" for "automatic". He wasn\'t so\r\nself-aggrandizing as to put his ',(0,s.jsx)(n.em,{children:"own"})," name on them. Later mathematicians did\r\nthat for him. That's how you get famous while still retaining some modesty."]}),"\n"]}),"\n",(0,s.jsx)(n.img,{src:"image/control-flow/turing-machine.png",alt:"A Turing machine."}),"\n",(0,s.jsxs)(n.p,{children:["Turing machines have better name recognition -- there's no Hollywood film about\r\nAlonzo Church yet -- but the two formalisms are ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis",children:"equivalent in power"}),".\r\nIn fact, any programming language with some minimal level of expressiveness is\r\npowerful enough to compute ",(0,s.jsx)(n.em,{children:"any"})," computable function."]}),"\n",(0,s.jsx)(n.p,{children:"You can prove that by writing a simulator for a Turing machine in your language.\r\nSince Turing proved his machine can compute any computable function, by\r\nextension, that means your language can too. All you need to do is translate the\r\nfunction into a Turing machine, and then run that on your simulator."}),"\n",(0,s.jsxs)(n.p,{children:["If your language is expressive enough to do that, it's considered\r\n",(0,s.jsx)(n.strong,{children:"Turing-complete"}),". Turing machines are pretty dang simple, so it doesn't take\r\nmuch power to do this. You basically need arithmetic, a little control flow,\r\nand the ability to allocate and use (theoretically) arbitrary amounts of memory.\r\nWe've got the first. By the end of this chapter, we'll have the ",(0,s.jsx)(n.span,{name:"memory",children:"second"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"memory",children:["\n",(0,s.jsxs)(n.p,{children:["We ",(0,s.jsx)(n.em,{children:"almost"})," have the third too. You can create and concatenate strings of\r\narbitrary size, so you can ",(0,s.jsx)(n.em,{children:"store"})," unbounded memory. But we don't have any way\r\nto access parts of a string."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conditional-execution",children:"Conditional Execution"}),"\n",(0,s.jsx)(n.p,{children:"Enough history, let's jazz up our language. We can divide control flow roughly\r\ninto two kinds:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Conditional"})," or ",(0,s.jsx)(n.strong,{children:"branching control flow"})," is used to ",(0,s.jsx)(n.em,{children:"not"})," execute\r\nsome piece of code. Imperatively, you can think of it as jumping ",(0,s.jsx)(n.em,{children:"ahead"}),"\r\nover a region of code."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Looping control flow"})," executes a chunk of code more than once. It jumps\r\n",(0,s.jsx)(n.em,{children:"back"})," so that you can do something again. Since you don't usually want\r\n",(0,s.jsx)(n.em,{children:"infinite"})," loops, it typically has some conditional logic to know when to\r\nstop looping as well."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Branching is simpler, so we'll start there. C-derived languages have two main\r\nconditional execution features, the ",(0,s.jsx)(n.code,{children:"if"}),' statement and the perspicaciously named\r\n"conditional" ',(0,s.jsx)(n.span,{name:"ternary",children:"operator"})," (",(0,s.jsx)(n.code,{children:"?:"}),"). An ",(0,s.jsx)(n.code,{children:"if"})," statement\r\nlets you conditionally execute statements and the conditional operator lets you\r\nconditionally execute expressions."]}),"\n",(0,s.jsxs)(n.aside,{name:"ternary",children:["\n",(0,s.jsx)(n.p,{children:'The conditional operator is also called the "ternary" operator because it\'s the\r\nonly operator in C that takes three operands.'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For simplicity's sake, Lox doesn't have a conditional operator, so let's get our\r\n",(0,s.jsx)(n.code,{children:"if"})," statement on. Our statement grammar gets a new production."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.span,{name:"semicolon"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'statement      \u2192 exprStmt\r\n               | ifStmt\r\n               | printStmt\r\n               | block ;\r\n\r\nifStmt         \u2192 "if" "(" expression ")" statement\r\n               ( "else" statement )? ;\n'})}),"\n",(0,s.jsxs)(n.aside,{name:"semicolon",children:["\n",(0,s.jsxs)(n.p,{children:["The semicolons in the rules aren't quoted, which means they are part of the\r\ngrammar metasyntax, not Lox's syntax. A block does not have a ",(0,s.jsx)(n.code,{children:";"})," at the end and\r\nan ",(0,s.jsx)(n.code,{children:"if"})," statement doesn't either, unless the then or else statement happens to\r\nbe one that ends in a semicolon."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"if"})," statement has an expression for the condition, then a statement to execute\r\nif the condition is truthy. Optionally, it may also have an ",(0,s.jsx)(n.code,{children:"else"})," keyword and a\r\nstatement to execute if the condition is falsey. The ",(0,s.jsx)(n.span,{name:"if-ast",children:"syntax\r\ntree node"})," has fields for each of those three pieces."]}),"\n",(0,s.jsx)(n.p,{children:"^code if-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"if-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#if-statement",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Like other statements, the parser recognizes an ",(0,s.jsx)(n.code,{children:"if"})," statement by the leading\r\n",(0,s.jsx)(n.code,{children:"if"})," keyword."]}),"\n",(0,s.jsx)(n.p,{children:"^code match-if (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"When it finds one, it calls this new method to parse the rest:"}),"\n",(0,s.jsx)(n.p,{children:"^code if-statement"}),"\n",(0,s.jsxs)(n.aside,{name:"parens",children:["\n",(0,s.jsxs)(n.p,{children:["The parentheses around the condition are only half useful. You need some kind of\r\ndelimiter ",(0,s.jsx)(n.em,{children:"between"})," the condition and the then statement, otherwise the parser\r\ncan't tell when it has reached the end of the condition expression. But the\r\n",(0,s.jsx)(n.em,{children:"opening"})," parenthesis after ",(0,s.jsx)(n.code,{children:"if"})," doesn't do anything useful. Dennis Ritchie put\r\nit there so he could use ",(0,s.jsx)(n.code,{children:")"})," as the ending delimiter without having unbalanced\r\nparentheses."]}),"\n",(0,s.jsxs)(n.p,{children:["Other languages like Lua and some BASICs use a keyword like ",(0,s.jsx)(n.code,{children:"then"})," as the ending\r\ndelimiter and don't have anything before the condition. Go and Swift instead\r\nrequire the statement to be a braced block. That lets them use the ",(0,s.jsx)(n.code,{children:"{"})," at the\r\nbeginning of the statement to tell when the condition is done."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As usual, the parsing code hews closely to the grammar. It detects an else\r\nclause by looking for the preceding ",(0,s.jsx)(n.code,{children:"else"})," keyword. If there isn't one, the\r\n",(0,s.jsx)(n.code,{children:"elseBranch"})," field in the syntax tree is ",(0,s.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"That seemingly innocuous optional else has, in fact, opened up an ambiguity in\r\nour grammar. Consider:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"if (first) if (second) whenTrue(); else whenFalse();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here's the riddle: Which ",(0,s.jsx)(n.code,{children:"if"})," statement does that else clause belong to? This\r\nisn't just a theoretical question about how we notate our grammar. It actually\r\naffects how the code executes:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If we attach the else to the first ",(0,s.jsx)(n.code,{children:"if"})," statement, then ",(0,s.jsx)(n.code,{children:"whenFalse()"})," is\r\ncalled if ",(0,s.jsx)(n.code,{children:"first"})," is falsey, regardless of what value ",(0,s.jsx)(n.code,{children:"second"})," has."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If we attach it to the second ",(0,s.jsx)(n.code,{children:"if"})," statement, then ",(0,s.jsx)(n.code,{children:"whenFalse()"})," is only\r\ncalled if ",(0,s.jsx)(n.code,{children:"first"})," is truthy and ",(0,s.jsx)(n.code,{children:"second"})," is falsey."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Since else clauses are optional, and there is no explicit delimiter marking the\r\nend of the ",(0,s.jsx)(n.code,{children:"if"})," statement, the grammar is ambiguous when you nest ",(0,s.jsx)(n.code,{children:"if"}),"s in this\r\nway. This classic pitfall of syntax is called the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dangling_else",children:"dangling else"})})," problem."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.span,{name:"else"})}),"\n",(0,s.jsx)(n.img,{className:"above",src:"image/control-flow/dangling-else.png",alt:"Two ways the else can be interpreted."}),"\n",(0,s.jsxs)(n.aside,{name:"else",children:["\n",(0,s.jsx)(n.p,{children:"Here, formatting highlights the two ways the else could be parsed. But note that\r\nsince whitespace characters are ignored by the parser, this is only a guide to\r\nthe human reader."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It ",(0,s.jsx)(n.em,{children:"is"})," possible to define a context-free grammar that avoids the ambiguity\r\ndirectly, but it requires splitting most of the statement rules into pairs, one\r\nthat allows an ",(0,s.jsx)(n.code,{children:"if"})," with an ",(0,s.jsx)(n.code,{children:"else"})," and one that doesn't. It's annoying."]}),"\n",(0,s.jsxs)(n.p,{children:["Instead, most languages and parsers avoid the problem in an ad hoc way. No\r\nmatter what hack they use to get themselves out of the trouble, they always\r\nchoose the same interpretation -- the ",(0,s.jsx)(n.code,{children:"else"})," is bound to the nearest ",(0,s.jsx)(n.code,{children:"if"})," that\r\nprecedes it."]}),"\n",(0,s.jsxs)(n.p,{children:["Our parser conveniently does that already. Since ",(0,s.jsx)(n.code,{children:"ifStatement()"})," eagerly looks\r\nfor an ",(0,s.jsx)(n.code,{children:"else"})," before returning, the innermost call to a nested series will claim\r\nthe else clause for itself before returning to the outer ",(0,s.jsx)(n.code,{children:"if"})," statements."]}),"\n",(0,s.jsx)(n.p,{children:"Syntax in hand, we are ready to interpret."}),"\n",(0,s.jsx)(n.p,{children:"^code visit-if"}),"\n",(0,s.jsx)(n.p,{children:"The interpreter implementation is a thin wrapper around the self-same Java code.\r\nIt evaluates the condition. If truthy, it executes the then branch. Otherwise,\r\nif there is an else branch, it executes that."}),"\n",(0,s.jsxs)(n.p,{children:["If you compare this code to how the interpreter handles other syntax we've\r\nimplemented, the part that makes control flow special is that Java ",(0,s.jsx)(n.code,{children:"if"}),"\r\nstatement. Most other syntax trees always evaluate their subtrees. Here, we may\r\nnot evaluate the then or else statement. If either of those has a side effect,\r\nthe choice not to evaluate it becomes user visible."]}),"\n",(0,s.jsx)(n.h2,{id:"logical-operators",children:"Logical Operators"}),"\n",(0,s.jsxs)(n.p,{children:["Since we don't have the conditional operator, you might think we're done with\r\nbranching, but no. Even without the ternary operator, there are two other\r\noperators that are technically control flow constructs -- the logical operators\r\n",(0,s.jsx)(n.code,{children:"and"})," and ",(0,s.jsx)(n.code,{children:"or"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["These aren't like other binary operators because they ",(0,s.jsx)(n.strong,{children:"short-circuit"}),". If,\r\nafter evaluating the left operand, we know what the result of the logical\r\nexpression must be, we don't evaluate the right operand. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"false and sideEffect();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For an ",(0,s.jsx)(n.code,{children:"and"})," expression to evaluate to something truthy, both operands must be\r\ntruthy. We can see as soon as we evaluate the left ",(0,s.jsx)(n.code,{children:"false"})," operand that that\r\nisn't going to be the case, so there's no need to evaluate ",(0,s.jsx)(n.code,{children:"sideEffect()"})," and it\r\ngets skipped."]}),"\n",(0,s.jsxs)(n.p,{children:["This is why we didn't implement the logical operators with the other binary\r\noperators. Now we're ready. The two new operators are low in the precedence\r\ntable. Similar to ",(0,s.jsx)(n.code,{children:"||"})," and ",(0,s.jsx)(n.code,{children:"&&"})," in C, they each have their ",(0,s.jsx)(n.span,{name:"logical",children:"own"})," precedence with ",(0,s.jsx)(n.code,{children:"or"})," lower than ",(0,s.jsx)(n.code,{children:"and"}),". We slot them\r\nright between ",(0,s.jsx)(n.code,{children:"assignment"})," and ",(0,s.jsx)(n.code,{children:"equality"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"logical",children:["\n",(0,s.jsx)(n.p,{children:"I've always wondered why they don't have the same precedence, like the various\r\ncomparison or equality operators do."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'expression     \u2192 assignment ;\r\nassignment     \u2192 IDENTIFIER "=" assignment\r\n               | logic_or ;\r\nlogic_or       \u2192 logic_and ( "or" logic_and )* ;\r\nlogic_and      \u2192 equality ( "and" equality )* ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Instead of falling back to ",(0,s.jsx)(n.code,{children:"equality"}),", ",(0,s.jsx)(n.code,{children:"assignment"})," now cascades to ",(0,s.jsx)(n.code,{children:"logic_or"}),".\r\nThe two new rules, ",(0,s.jsx)(n.code,{children:"logic_or"})," and ",(0,s.jsx)(n.code,{children:"logic_and"}),", are ",(0,s.jsx)(n.span,{name:"same",children:"similar"})," to other binary operators. Then ",(0,s.jsx)(n.code,{children:"logic_and"})," calls\r\nout to ",(0,s.jsx)(n.code,{children:"equality"})," for its operands, and we chain back to the rest of the\r\nexpression rules."]}),"\n",(0,s.jsxs)(n.aside,{name:"same",children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"syntax"})," doesn't care that they short-circuit. That's a semantic concern."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We could reuse the existing Expr.Binary class for these two new expressions\r\nsince they have the same fields. But then ",(0,s.jsx)(n.code,{children:"visitBinaryExpr()"})," would have to\r\ncheck to see if the operator is one of the logical operators and use a different\r\ncode path to handle the short circuiting. I think it's cleaner to define a ",(0,s.jsx)(n.span,{name:"logical-ast",children:"new class"})," for these operators so that they get their\r\nown visit method."]}),"\n",(0,s.jsx)(n.p,{children:"^code logical-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"logical-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#logical-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To weave the new expressions into the parser, we first change the parsing code\r\nfor assignment to call ",(0,s.jsx)(n.code,{children:"or()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"^code or-in-assignment (1 before, 2 after)"}),"\n",(0,s.jsxs)(n.p,{children:["The code to parse a series of ",(0,s.jsx)(n.code,{children:"or"})," expressions mirrors other binary operators."]}),"\n",(0,s.jsx)(n.p,{children:"^code or"}),"\n",(0,s.jsxs)(n.p,{children:["Its operands are the next higher level of precedence, the new ",(0,s.jsx)(n.code,{children:"and"})," expression."]}),"\n",(0,s.jsx)(n.p,{children:"^code and"}),"\n",(0,s.jsxs)(n.p,{children:["That calls ",(0,s.jsx)(n.code,{children:"equality()"})," for its operands, and with that, the expression parser\r\nis all tied back together again. We're ready to interpret."]}),"\n",(0,s.jsx)(n.p,{children:"^code visit-logical"}),"\n",(0,s.jsxs)(n.p,{children:["If you compare this to the ",(0,s.jsx)(n.a,{href:"evaluating-expressions.html",children:"earlier chapter's"})," ",(0,s.jsx)(n.code,{children:"visitBinaryExpr()"}),"\r\nmethod, you can see the difference. Here, we evaluate the left operand first. We\r\nlook at its value to see if we can short-circuit. If not, and only then, do we\r\nevaluate the right operand."]}),"\n",(0,s.jsxs)(n.p,{children:["The other interesting piece here is deciding what actual value to return. Since\r\nLox is dynamically typed, we allow operands of any type and use truthiness to\r\ndetermine what each operand represents. We apply similar reasoning to the\r\nresult. Instead of promising to literally return ",(0,s.jsx)(n.code,{children:"true"})," or ",(0,s.jsx)(n.code,{children:"false"}),", a logic\r\noperator merely guarantees it will return a value with appropriate truthiness."]}),"\n",(0,s.jsx)(n.p,{children:"Fortunately, we have values with proper truthiness right at hand -- the results\r\nof the operands themselves. So we use those. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'print "hi" or 2; // "hi".\r\nprint nil or "yes"; // "yes".\n'})}),"\n",(0,s.jsxs)(n.p,{children:["On the first line, ",(0,s.jsx)(n.code,{children:'"hi"'})," is truthy, so the ",(0,s.jsx)(n.code,{children:"or"})," short-circuits and returns\r\nthat. On the second line, ",(0,s.jsx)(n.code,{children:"nil"})," is falsey, so it evaluates and returns the\r\nsecond operand, ",(0,s.jsx)(n.code,{children:'"yes"'}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["That covers all of the branching primitives in Lox. We're ready to jump ahead to\r\nloops. You see what I did there? ",(0,s.jsx)(n.em,{children:"Jump. Ahead."})," Get it? See, it's like a\r\nreference to... oh, forget it."]}),"\n",(0,s.jsx)(n.h2,{id:"while-loops",children:"While Loops"}),"\n",(0,s.jsxs)(n.p,{children:["Lox features two looping control flow statements, ",(0,s.jsx)(n.code,{children:"while"})," and ",(0,s.jsx)(n.code,{children:"for"}),". The ",(0,s.jsx)(n.code,{children:"while"}),"\r\nloop is the simpler one, so we'll start there. Its grammar is the same as in C."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'statement      \u2192 exprStmt\r\n               | ifStmt\r\n               | printStmt\r\n               | whileStmt\r\n               | block ;\r\n\r\nwhileStmt      \u2192 "while" "(" expression ")" statement ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We add another clause to the statement rule that points to the new rule for\r\nwhile. It takes a ",(0,s.jsx)(n.code,{children:"while"})," keyword, followed by a parenthesized condition\r\nexpression, then a statement for the body. That new grammar rule gets a ",(0,s.jsx)(n.span,{name:"while-ast",children:"syntax tree node"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"^code while-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"while-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#while-statement",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The node stores the condition and body. Here you can see why it's nice to have\r\nseparate base classes for expressions and statements. The field declarations\r\nmake it clear that the condition is an expression and the body is a statement."}),"\n",(0,s.jsxs)(n.p,{children:["Over in the parser, we follow the same process we used for ",(0,s.jsx)(n.code,{children:"if"})," statements.\r\nFirst, we add another case in ",(0,s.jsx)(n.code,{children:"statement()"})," to detect and match the leading\r\nkeyword."]}),"\n",(0,s.jsx)(n.p,{children:"^code match-while (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"That delegates the real work to this method:"}),"\n",(0,s.jsx)(n.p,{children:"^code while-statement"}),"\n",(0,s.jsx)(n.p,{children:"The grammar is dead simple and this is a straight translation of it to Java.\r\nSpeaking of translating straight to Java, here's how we execute the new syntax:"}),"\n",(0,s.jsx)(n.p,{children:"^code visit-while"}),"\n",(0,s.jsxs)(n.p,{children:["Like the visit method for ",(0,s.jsx)(n.code,{children:"if"}),", this visitor uses the corresponding Java\r\nfeature. This method isn't complex, but it makes Lox much more powerful. We can\r\nfinally write a program whose running time isn't strictly bound by the length of\r\nthe source code."]}),"\n",(0,s.jsx)(n.h2,{id:"for-loops",children:"For Loops"}),"\n",(0,s.jsxs)(n.p,{children:["We're down to the last control flow construct, ",(0,s.jsx)(n.span,{name:"for",children:"Ye Olde"}),"\r\nC-style ",(0,s.jsx)(n.code,{children:"for"})," loop. I probably don't need to remind you, but it looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"for (var i = 0; i < 10; i = i + 1) print i;\n"})}),"\n",(0,s.jsx)(n.p,{children:"In grammarese, that's:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'statement      \u2192 exprStmt\r\n               | forStmt\r\n               | ifStmt\r\n               | printStmt\r\n               | whileStmt\r\n               | block ;\r\n\r\nforStmt        \u2192 "for" "(" ( varDecl | exprStmt | ";" )\r\n                 expression? ";"\r\n                 expression? ")" statement ;\n'})}),"\n",(0,s.jsxs)(n.aside,{name:"for",children:["\n",(0,s.jsxs)(n.p,{children:["Most modern languages have a higher-level looping statement for iterating over\r\narbitrary user-defined sequences. C# has ",(0,s.jsx)(n.code,{children:"foreach"}),', Java has "enhanced for",\r\neven C++ has range-based ',(0,s.jsx)(n.code,{children:"for"})," statements now. Those offer cleaner syntax than\r\nC's ",(0,s.jsx)(n.code,{children:"for"})," statement by implicitly calling into an iteration protocol that the\r\nobject being looped over supports."]}),"\n",(0,s.jsxs)(n.p,{children:["I love those. For Lox, though, we're limited by building up the interpreter a\r\nchapter at a time. We don't have objects and methods yet, so we have no way of\r\ndefining an iteration protocol that the ",(0,s.jsx)(n.code,{children:"for"})," loop could use. So we'll stick\r\nwith the old school C ",(0,s.jsx)(n.code,{children:"for"}),' loop. Think of it as "vintage". The fixie of control\r\nflow statements.']}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Inside the parentheses, you have three clauses separated by semicolons:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The first clause is the ",(0,s.jsx)(n.em,{children:"initializer"}),". It is executed exactly once, before\r\nanything else. It's usually an expression, but for convenience, we also\r\nallow a variable declaration. In that case, the variable is scoped to the\r\nrest of the ",(0,s.jsx)(n.code,{children:"for"})," loop -- the other two clauses and the body."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Next is the ",(0,s.jsx)(n.em,{children:"condition"}),". As in a ",(0,s.jsx)(n.code,{children:"while"})," loop, this expression controls when\r\nto exit the loop. It's evaluated once at the beginning of each iteration,\r\nincluding the first. If the result is truthy, it executes the loop body.\r\nOtherwise, it bails."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The last clause is the ",(0,s.jsx)(n.em,{children:"increment"}),". It's an arbitrary expression that does\r\nsome work at the end of each loop iteration. The result of the expression is\r\ndiscarded, so it must have a side effect to be useful. In practice, it\r\nusually increments a variable."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Any of these clauses can be omitted. Following the closing parenthesis is a\r\nstatement for the body, which is typically a block."}),"\n",(0,s.jsx)(n.h3,{id:"desugaring",children:"Desugaring"}),"\n",(0,s.jsxs)(n.p,{children:["That's a lot of machinery, but note that none of it does anything you couldn't\r\ndo with the statements we already have. If ",(0,s.jsx)(n.code,{children:"for"})," loops didn't support\r\ninitializer clauses, you could just put the initializer expression before the\r\n",(0,s.jsx)(n.code,{children:"for"})," statement. Without an increment clause, you could simply put the increment\r\nexpression at the end of the body yourself."]}),"\n",(0,s.jsxs)(n.p,{children:["In other words, Lox doesn't ",(0,s.jsx)(n.em,{children:"need"})," ",(0,s.jsx)(n.code,{children:"for"})," loops, they just make some common code\r\npatterns more pleasant to write. These kinds of features are called ",(0,s.jsx)(n.span,{name:"sugar",children:(0,s.jsx)(n.strong,{children:"syntactic sugar"})}),". For example, the previous ",(0,s.jsx)(n.code,{children:"for"})," loop\r\ncould be rewritten like so:"]}),"\n",(0,s.jsxs)(n.aside,{name:"sugar",children:["\n",(0,s.jsx)(n.p,{children:"This delightful turn of phrase was coined by Peter J. Landin in 1964 to describe\r\nhow some of the nice expression forms supported by languages like ALGOL were a\r\nsweetener sprinkled over the more fundamental -- but presumably less palatable\r\n-- lambda calculus underneath."}),"\n",(0,s.jsx)(n.img,{className:"above",src:"image/control-flow/sugar.png",alt:"Slightly more than a spoonful of sugar."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"{\r\n  var i = 0;\r\n  while (i < 10) {\r\n    print i;\r\n    i = i + 1;\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This script has the exact same semantics as the previous one, though it's not as\r\neasy on the eyes. Syntactic sugar features like Lox's ",(0,s.jsx)(n.code,{children:"for"})," loop make a language\r\nmore pleasant and productive to work in. But, especially in sophisticated\r\nlanguage implementations, every language feature that requires back-end support\r\nand optimization is expensive."]}),"\n",(0,s.jsxs)(n.p,{children:["We can have our cake and eat it too by ",(0,s.jsx)(n.span,{name:"caramel",children:(0,s.jsx)(n.strong,{children:"desugaring"})}),". That funny word describes a process where\r\nthe front end takes code using syntax sugar and translates it to a more\r\nprimitive form that the back end already knows how to execute."]}),"\n",(0,s.jsxs)(n.aside,{name:"caramel",children:["\n",(0,s.jsx)(n.p,{children:'Oh, how I wish the accepted term for this was "caramelization". Why introduce a\r\nmetaphor if you aren\'t going to stick with it?'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We're going to desugar ",(0,s.jsx)(n.code,{children:"for"})," loops to the ",(0,s.jsx)(n.code,{children:"while"})," loops and other statements the\r\ninterpreter already handles. In our simple interpreter, desugaring really\r\ndoesn't save us much work, but it does give me an excuse to introduce you to the\r\ntechnique. So, unlike the previous statements, we ",(0,s.jsx)(n.em,{children:"won't"})," add a new syntax tree\r\nnode. Instead, we go straight to parsing. First, add an import we'll need soon."]}),"\n",(0,s.jsx)(n.p,{children:"^code import-arrays (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["Like every statement, we start parsing a ",(0,s.jsx)(n.code,{children:"for"})," loop by matching its keyword."]}),"\n",(0,s.jsx)(n.p,{children:"^code match-for (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"Here is where it gets interesting. The desugaring is going to happen here, so\r\nwe'll build this method a piece at a time, starting with the opening parenthesis\r\nbefore the clauses."}),"\n",(0,s.jsx)(n.p,{children:"^code for-statement"}),"\n",(0,s.jsx)(n.p,{children:"The first clause following that is the initializer."}),"\n",(0,s.jsx)(n.p,{children:"^code for-initializer (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["If the token following the ",(0,s.jsx)(n.code,{children:"("})," is a semicolon then the initializer has been\r\nomitted. Otherwise, we check for a ",(0,s.jsx)(n.code,{children:"var"})," keyword to see if it's a ",(0,s.jsx)(n.span,{name:"variable",children:"variable"})," declaration. If neither of those matched, it\r\nmust be an expression. We parse that and wrap it in an expression statement so\r\nthat the initializer is always of type Stmt."]}),"\n",(0,s.jsxs)(n.aside,{name:"variable",children:["\n",(0,s.jsxs)(n.p,{children:["In a previous chapter, I said we can split expression and statement syntax trees\r\ninto two separate class hierarchies because there's no single place in the\r\ngrammar that allows both an expression and a statement. That wasn't ",(0,s.jsx)(n.em,{children:"entirely"}),"\r\ntrue, I guess."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Next up is the condition."}),"\n",(0,s.jsx)(n.p,{children:"^code for-condition (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"Again, we look for a semicolon to see if the clause has been omitted. The last\r\nclause is the increment."}),"\n",(0,s.jsx)(n.p,{children:"^code for-increment (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["It's similar to the condition clause except this one is terminated by the\r\nclosing parenthesis. All that remains is the ",(0,s.jsx)(n.span,{name:"body",children:"body"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"body",children:["\n",(0,s.jsxs)(n.p,{children:['Is it just me or does that sound morbid? "All that remained... was the ',(0,s.jsx)(n.em,{children:"body"}),'".']}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code for-body (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["We've parsed all of the various pieces of the ",(0,s.jsx)(n.code,{children:"for"})," loop and the resulting AST\r\nnodes are sitting in a handful of Java local variables. This is where the\r\ndesugaring comes in. We take those and use them to synthesize syntax tree nodes\r\nthat express the semantics of the ",(0,s.jsx)(n.code,{children:"for"})," loop, like the hand-desugared example I\r\nshowed you earlier."]}),"\n",(0,s.jsx)(n.p,{children:"The code is a little simpler if we work backward, so we start with the increment\r\nclause."}),"\n",(0,s.jsx)(n.p,{children:"^code for-desugar-increment (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"The increment, if there is one, executes after the body in each iteration of the\r\nloop. We do that by replacing the body with a little block that contains the\r\noriginal body followed by an expression statement that evaluates the increment."}),"\n",(0,s.jsx)(n.p,{children:"^code for-desugar-condition (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["Next, we take the condition and the body and build the loop using a primitive\r\n",(0,s.jsx)(n.code,{children:"while"})," loop. If the condition is omitted, we jam in ",(0,s.jsx)(n.code,{children:"true"})," to make an infinite\r\nloop."]}),"\n",(0,s.jsx)(n.p,{children:"^code for-desugar-initializer (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"Finally, if there is an initializer, it runs once before the entire loop. We do\r\nthat by, again, replacing the whole statement with a block that runs the\r\ninitializer and then executes the loop."}),"\n",(0,s.jsxs)(n.p,{children:["That's it. Our interpreter now supports C-style ",(0,s.jsx)(n.code,{children:"for"})," loops and we didn't have\r\nto touch the Interpreter class at all. Since we desugared to nodes the\r\ninterpreter already knows how to visit, there is no more work to do."]}),"\n",(0,s.jsx)(n.p,{children:"Finally, Lox is powerful enough to entertain us, at least for a few minutes.\r\nHere's a tiny program to print the first 21 elements in the Fibonacci\r\nsequence:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var a = 0;\r\nvar temp;\r\n\r\nfor (var b = 1; a < 10000; b = temp + b) {\r\n  print a;\r\n  temp = a;\r\n  a = b;\r\n}\n"})}),"\n",(0,s.jsxs)(n.div,{className:"challenges",children:["\n",(0,s.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A few chapters from now, when Lox supports first-class functions and dynamic\r\ndispatch, we technically won't ",(0,s.jsx)(n.em,{children:"need"})," branching statements built into the\r\nlanguage. Show how conditional execution can be implemented in terms of\r\nthose. Name a language that uses this technique for its control flow."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Likewise, looping can be implemented using those same tools, provided our\r\ninterpreter supports an important optimization. What is it, and why is it\r\nnecessary? Name a language that uses this technique for iteration."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Unlike Lox, most other C-style languages also support ",(0,s.jsx)(n.code,{children:"break"})," and ",(0,s.jsx)(n.code,{children:"continue"}),"\r\nstatements inside loops. Add support for ",(0,s.jsx)(n.code,{children:"break"})," statements."]}),"\n",(0,s.jsxs)(n.p,{children:["The syntax is a ",(0,s.jsx)(n.code,{children:"break"})," keyword followed by a semicolon. It should be a\r\nsyntax error to have a ",(0,s.jsx)(n.code,{children:"break"})," statement appear outside of any enclosing\r\nloop. At runtime, a ",(0,s.jsx)(n.code,{children:"break"})," statement causes execution to jump to the end of\r\nthe nearest enclosing loop and proceeds from there. Note that the ",(0,s.jsx)(n.code,{children:"break"}),"\r\nmay be nested inside other blocks and ",(0,s.jsx)(n.code,{children:"if"})," statements that also need to be\r\nexited."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.div,{className:"design-note",children:["\n",(0,s.jsx)(n.h2,{id:"design-note-spoonfuls-of-syntactic-sugar",children:"Design Note: Spoonfuls of Syntactic Sugar"}),"\n",(0,s.jsx)(n.p,{children:"When you design your own language, you choose how much syntactic sugar to pour\r\ninto the grammar. Do you make an unsweetened health food where each semantic\r\noperation maps to a single syntactic unit, or some decadent dessert where every\r\nbit of behavior can be expressed ten different ways? Successful languages\r\ninhabit all points along this continuum."}),"\n",(0,s.jsxs)(n.p,{children:['On the extreme acrid end are those with ruthlessly minimal syntax like Lisp,\r\nForth, and Smalltalk. Lispers famously claim their language "has no syntax",\r\nwhile Smalltalkers proudly show that you can fit the entire grammar on an index\r\ncard. This tribe has the philosophy that the ',(0,s.jsx)(n.em,{children:"language"})," doesn't need syntactic\r\nsugar. Instead, the minimal syntax and semantics it provides are powerful enough\r\nto let library code be as expressive as if it were part of the language itself."]}),"\n",(0,s.jsx)(n.p,{children:"Near these are languages like C, Lua, and Go. They aim for simplicity and\r\nclarity over minimalism. Some, like Go, deliberately eschew both syntactic sugar\r\nand the kind of syntactic extensibility of the previous category. They want the\r\nsyntax to get out of the way of the semantics, so they focus on keeping both the\r\ngrammar and libraries simple. Code should be obvious more than beautiful."}),"\n",(0,s.jsx)(n.p,{children:"Somewhere in the middle you have languages like Java, C#, and Python. Eventually\r\nyou reach Ruby, C++, Perl, and D -- languages which have stuffed so much syntax\r\ninto their grammar, they are running out of punctuation characters on the\r\nkeyboard."}),"\n",(0,s.jsx)(n.p,{children:"To some degree, location on the spectrum correlates with age. It's relatively\r\neasy to add bits of syntactic sugar in later releases. New syntax is a crowd\r\npleaser, and it's less likely to break existing programs than mucking with the\r\nsemantics. Once added, you can never take it away, so languages tend to sweeten\r\nwith time. One of the main benefits of creating a new language from scratch is\r\nit gives you an opportunity to scrape off those accumulated layers of frosting\r\nand start over."}),"\n",(0,s.jsx)(n.p,{children:"Syntactic sugar has a bad rap among the PL intelligentsia. There's a real fetish\r\nfor minimalism in that crowd. There is some justification for that. Poorly\r\ndesigned, unneeded syntax raises the cognitive load without adding enough\r\nexpressiveness to carry its weight. Since there is always pressure to cram new\r\nfeatures into the language, it takes discipline and a focus on simplicity to\r\navoid bloat. Once you add some syntax, you're stuck with it, so it's smart to be\r\nparsimonious."}),"\n",(0,s.jsx)(n.p,{children:"At the same time, most successful languages do have fairly complex grammars, at\r\nleast by the time they are widely used. Programmers spend a ton of time in their\r\nlanguage of choice, and a few niceties here and there really can improve the\r\ncomfort and efficiency of their work."}),"\n",(0,s.jsx)(n.p,{children:"Striking the right balance -- choosing the right level of sweetness for your\r\nlanguage -- relies on your own sense of taste."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);