"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[9033],{9196:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=t(4848),a=t(8453);const i={},s=void 0,o={id:"Craftinginterpreters/not-translated-yet/functions",title:"functions",description:"And that is also the way the human mind works -- by the compounding of old",source:"@site/docs/Craftinginterpreters/not-translated-yet/functions.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/functions",permalink:"/docs/Craftinginterpreters/not-translated-yet/functions",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/functions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"evaluating-expressions",permalink:"/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions"},next:{title:"garbage-collection",permalink:"/docs/Craftinginterpreters/not-translated-yet/garbage-collection"}},l={},c=[{value:"Function Calls",id:"function-calls",level:2},{value:"Maximum argument counts",id:"maximum-argument-counts",level:3},{value:"Interpreting function calls",id:"interpreting-function-calls",level:3},{value:"Call type errors",id:"call-type-errors",level:3},{value:"Checking arity",id:"checking-arity",level:3},{value:"Native Functions",id:"native-functions",level:2},{value:"Telling time",id:"telling-time",level:3},{value:"Function Declarations",id:"function-declarations",level:2},{value:"Function Objects",id:"function-objects",level:2},{value:"Interpreting function declarations",id:"interpreting-function-declarations",level:3},{value:"Return Statements",id:"return-statements",level:2},{value:"Returning from calls",id:"returning-from-calls",level:3},{value:"Local Functions and Closures",id:"local-functions-and-closures",level:2},{value:"Challenges",id:"challenges",level:2}];function h(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"And that is also the way the human mind works -- by the compounding of old\r\nideas into new structures that become new ideas that can themselves be used in\r\ncompounds, and round and round endlessly, growing ever more remote from the\r\nbasic earthbound imagery that is each language's soil."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["Douglas R. Hofstadter, ",(0,r.jsx)(n.em,{children:"I Am a Strange Loop"})]})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This chapter marks the culmination of a lot of hard work. The previous chapters\r\nadd useful functionality in their own right, but each also supplies a piece of a\r\n",(0,r.jsx)(n.span,{name:"lambda",children:"puzzle"}),". We'll take those pieces -- expressions,\r\nstatements, variables, control flow, and lexical scope -- add a couple more, and\r\nassemble them all into support for real user-defined functions and function\r\ncalls."]}),"\n",(0,r.jsxs)(n.aside,{name:"lambda",children:["\n",(0,r.jsx)(n.img,{src:"image/functions/lambda.png",alt:"A lambda puzzle."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"function-calls",children:"Function Calls"}),"\n",(0,r.jsx)(n.p,{children:"You're certainly familiar with C-style function call syntax, but the grammar is\r\nmore subtle than you may realize. Calls are typically to named functions like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"average(1, 2);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["But the ",(0,r.jsx)(n.span,{name:"pascal",children:"name"})," of the function being called isn't\r\nactually part of the call syntax. The thing being called -- the ",(0,r.jsx)(n.strong,{children:"callee"})," --\r\ncan be any expression that evaluates to a function. (Well, it does have to be a\r\npretty ",(0,r.jsx)(n.em,{children:"high precedence"})," expression, but parentheses take care of that.) For\r\nexample:"]}),"\n",(0,r.jsxs)(n.aside,{name:"pascal",children:["\n",(0,r.jsxs)(n.p,{children:["The name ",(0,r.jsx)(n.em,{children:"is"})," part of the call syntax in Pascal. You can call only named\r\nfunctions or functions stored directly in variables."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"getCallback()();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["There are two call expressions here. The first pair of parentheses has\r\n",(0,r.jsx)(n.code,{children:"getCallback"})," as its callee. But the second call has the entire ",(0,r.jsx)(n.code,{children:"getCallback()"}),"\r\nexpression as its callee. It is the parentheses following an expression that\r\nindicate a function call. You can think of a call as sort of like a postfix\r\noperator that starts with ",(0,r.jsx)(n.code,{children:"("}),"."]}),"\n",(0,r.jsxs)(n.p,{children:['This "operator" has higher precedence than any other operator, even the unary\r\nones. So we slot it into the grammar by having the ',(0,r.jsx)(n.code,{children:"unary"})," rule bubble up to a\r\nnew ",(0,r.jsx)(n.code,{children:"call"})," rule."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.span,{name:"curry"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:'unary          \u2192 ( "!" | "-" ) unary | call ;\r\ncall           \u2192 primary ( "(" arguments? ")" )* ;\n'})}),"\n",(0,r.jsx)(n.p,{children:"This rule matches a primary expression followed by zero or more function calls.\r\nIf there are no parentheses, this parses a bare primary expression. Otherwise,\r\neach call is recognized by a pair of parentheses with an optional list of\r\narguments inside. The argument list grammar is:"}),"\n",(0,r.jsxs)(n.aside,{name:"curry",children:["\n",(0,r.jsxs)(n.p,{children:["The rule uses ",(0,r.jsx)(n.code,{children:"*"})," to allow matching a series of calls like ",(0,r.jsx)(n.code,{children:"fn(1)(2)(3)"}),". Code\r\nlike that isn't common in C-style languages, but it is in the family of\r\nlanguages derived from ML. There, the normal way of defining a function that\r\ntakes multiple arguments is as a series of nested functions. Each function takes\r\none argument and returns a new function. That function consumes the next\r\nargument, returns yet another function, and so on. Eventually, once all of the\r\narguments are consumed, the last function completes the operation."]}),"\n",(0,r.jsxs)(n.p,{children:["This style, called ",(0,r.jsx)(n.strong,{children:"currying"}),", after Haskell Curry (the same guy whose first\r\nname graces that ",(0,r.jsx)(n.em,{children:"other"})," well-known functional language), is baked directly into\r\nthe language syntax so it's not as weird looking as it would be here."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:'arguments      \u2192 expression ( "," expression )* ;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This rule requires at least one argument expression, followed by zero or more\r\nother expressions, each preceded by a comma. To handle zero-argument calls, the\r\n",(0,r.jsx)(n.code,{children:"call"})," rule itself considers the entire ",(0,r.jsx)(n.code,{children:"arguments"})," production to be optional."]}),"\n",(0,r.jsx)(n.p,{children:"I admit, this seems more grammatically awkward than you'd expect for the\r\nincredibly common \"zero or more comma-separated things\" pattern. There are some\r\nsophisticated metasyntaxes that handle this better, but in our BNF and in many\r\nlanguage specs I've seen, it is this cumbersome."}),"\n",(0,r.jsxs)(n.p,{children:["Over in our syntax tree generator, we add a ",(0,r.jsx)(n.span,{name:"call-ast",children:"new\r\nnode"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code call-expr (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.aside,{name:"call-ast",children:["\n",(0,r.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,r.jsx)(n.a,{href:"appendix-ii.html#call-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"It stores the callee expression and a list of expressions for the arguments. It\r\nalso stores the token for the closing parenthesis. We'll use that token's\r\nlocation when we report a runtime error caused by a function call."}),"\n",(0,r.jsxs)(n.p,{children:["Crack open the parser. Where ",(0,r.jsx)(n.code,{children:"unary()"})," used to jump straight to ",(0,r.jsx)(n.code,{children:"primary()"}),",\r\nchange it to call, well, ",(0,r.jsx)(n.code,{children:"call()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code unary-call (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Its definition is:"}),"\n",(0,r.jsx)(n.p,{children:"^code call"}),"\n",(0,r.jsxs)(n.p,{children:["The code here doesn't quite line up with the grammar rules. I moved a few things\r\naround to make the code cleaner -- one of the luxuries we have with a\r\nhandwritten parser. But it's roughly similar to how we parse infix operators.\r\nFirst, we parse a primary expression, the \"left operand\" to the call. Then, each\r\ntime we see a ",(0,r.jsx)(n.code,{children:"("}),", we call ",(0,r.jsx)(n.code,{children:"finishCall()"})," to parse the call expression using the\r\npreviously parsed expression as the callee. The returned expression becomes the\r\nnew ",(0,r.jsx)(n.code,{children:"expr"})," and we loop to see if the result is itself called."]}),"\n",(0,r.jsxs)(n.aside,{name:"while-true",children:["\n",(0,r.jsxs)(n.p,{children:["This code would be simpler as ",(0,r.jsx)(n.code,{children:"while (match(LEFT_PAREN))"})," instead of the silly\r\n",(0,r.jsx)(n.code,{children:"while (true)"})," and ",(0,r.jsx)(n.code,{children:"break"}),". Don't worry, it will make sense when we expand the\r\nparser later to handle properties on objects."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The code to parse the argument list is in this helper:"}),"\n",(0,r.jsx)(n.p,{children:"^code finish-call"}),"\n",(0,r.jsxs)(n.p,{children:["This is more or less the ",(0,r.jsx)(n.code,{children:"arguments"})," grammar rule translated to code, except\r\nthat we also handle the zero-argument case. We check for that case first by\r\nseeing if the next token is ",(0,r.jsx)(n.code,{children:")"}),". If it is, we don't try to parse any arguments."]}),"\n",(0,r.jsx)(n.p,{children:"Otherwise, we parse an expression, then look for a comma indicating that there\r\nis another argument after that. We keep doing that as long as we find commas\r\nafter each expression. When we don't find a comma, then the argument list must\r\nbe done and we consume the expected closing parenthesis. Finally, we wrap the\r\ncallee and those arguments up into a call AST node."}),"\n",(0,r.jsx)(n.h3,{id:"maximum-argument-counts",children:"Maximum argument counts"}),"\n",(0,r.jsx)(n.p,{children:"Right now, the loop where we parse arguments has no bound. If you want to call a\r\nfunction and pass a million arguments to it, the parser would have no problem\r\nwith it. Do we want to limit that?"}),"\n",(0,r.jsxs)(n.p,{children:["Other languages have various approaches. The C standard says a conforming\r\nimplementation has to support ",(0,r.jsx)(n.em,{children:"at least"})," 127 arguments to a function, but\r\ndoesn't say there's any upper limit. The Java specification says a method can\r\naccept ",(0,r.jsx)(n.em,{children:"no more than"})," ",(0,r.jsx)(n.span,{name:"254",children:"255"})," arguments."]}),"\n",(0,r.jsxs)(n.aside,{name:"254",children:["\n",(0,r.jsxs)(n.p,{children:["The limit is 25",(0,r.jsx)(n.em,{children:"4"})," arguments if the method is an instance method. That's because\r\n",(0,r.jsx)(n.code,{children:"this"})," -- the receiver of the method -- works like an argument that is\r\nimplicitly passed to the method, so it claims one of the slots."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Our Java interpreter for Lox doesn't really need a limit, but having a maximum\r\nnumber of arguments will simplify our bytecode interpreter in ",(0,r.jsx)(n.a,{href:"a-bytecode-virtual-machine.html",children:"Part III"}),". We\r\nwant our two interpreters to be compatible with each other, even in weird corner\r\ncases like this, so we'll add the same limit to jlox."]}),"\n",(0,r.jsx)(n.p,{children:"^code check-max-arity (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Note that the code here ",(0,r.jsx)(n.em,{children:"reports"})," an error if it encounters too many arguments,\r\nbut it doesn't ",(0,r.jsx)(n.em,{children:"throw"})," the error. Throwing is how we kick into panic mode which\r\nis what we want if the parser is in a confused state and doesn't know where it\r\nis in the grammar anymore. But here, the parser is still in a perfectly valid\r\nstate -- it just found too many arguments. So it reports the error and keeps on\r\nkeepin' on."]}),"\n",(0,r.jsx)(n.h3,{id:"interpreting-function-calls",children:"Interpreting function calls"}),"\n",(0,r.jsx)(n.p,{children:"We don't have any functions we can call, so it seems weird to start implementing\r\ncalls first, but we'll worry about that when we get there. First, our\r\ninterpreter needs a new import."}),"\n",(0,r.jsx)(n.p,{children:"^code import-array-list (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"As always, interpretation starts with a new visit method for our new call\r\nexpression node."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-call"}),"\n",(0,r.jsx)(n.p,{children:"First, we evaluate the expression for the callee. Typically, this expression is\r\njust an identifier that looks up the function by its name, but it could be\r\nanything. Then we evaluate each of the argument expressions in order and store\r\nthe resulting values in a list."}),"\n",(0,r.jsxs)(n.aside,{name:"in-order",children:["\n",(0,r.jsx)(n.p,{children:"This is another one of those subtle semantic choices. Since argument expressions\r\nmay have side effects, the order they are evaluated could be user visible. Even\r\nso, some languages like Scheme and C don't specify an order. This gives\r\ncompilers freedom to reorder them for efficiency, but means users may be\r\nunpleasantly surprised if arguments aren't evaluated in the order they expect."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Once we've got the callee and the arguments ready, all that remains is to\r\nperform the call. We do that by casting the callee to a ",(0,r.jsx)(n.span,{name:"callable",children:"LoxCallable"})," and then invoking a ",(0,r.jsx)(n.code,{children:"call()"}),' method on it.\r\nThe Java representation of any Lox object that can be called like a function\r\nwill implement this interface. That includes user-defined functions, naturally,\r\nbut also class objects since classes are "called" to construct new instances.\r\nWe\'ll also use it for one more purpose shortly.']}),"\n",(0,r.jsxs)(n.aside,{name:"callable",children:["\n",(0,r.jsx)(n.p,{children:'I stuck "Lox" before the name to distinguish it from the Java standard library\'s\r\nown Callable interface. Alas, all the good simple names are already taken.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"There isn't too much to this new interface."}),"\n",(0,r.jsx)(n.p,{children:"^code callable"}),"\n",(0,r.jsxs)(n.p,{children:["We pass in the interpreter in case the class implementing ",(0,r.jsx)(n.code,{children:"call()"})," needs it. We\r\nalso give it the list of evaluated argument values. The implementer's job is\r\nthen to return the value that the call expression produces."]}),"\n",(0,r.jsx)(n.h3,{id:"call-type-errors",children:"Call type errors"}),"\n",(0,r.jsx)(n.p,{children:"Before we get to implementing LoxCallable, we need to make the visit method a\r\nlittle more robust. It currently ignores a couple of failure modes that we can't\r\npretend won't occur. First, what happens if the callee isn't actually something\r\nyou can call? What if you try to do this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'"totally not a function"();\n'})}),"\n",(0,r.jsx)(n.p,{children:"Strings aren't callable in Lox. The runtime representation of a Lox string is a\r\nJava string, so when we cast that to LoxCallable, the JVM will throw a\r\nClassCastException. We don't want our interpreter to vomit out some nasty Java\r\nstack trace and die. Instead, we need to check the type ourselves first."}),"\n",(0,r.jsx)(n.p,{children:"^code check-is-callable (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We still throw an exception, but now we're throwing our own exception type, one\r\nthat the interpreter knows to catch and report gracefully."}),"\n",(0,r.jsx)(n.h3,{id:"checking-arity",children:"Checking arity"}),"\n",(0,r.jsxs)(n.p,{children:["The other problem relates to the function's ",(0,r.jsx)(n.strong,{children:"arity"}),". Arity is the fancy term\r\nfor the number of arguments a function or operation expects. Unary operators\r\nhave arity one, binary operators two, etc. With functions, the arity is\r\ndetermined by the number of parameters it declares."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun add(a, b, c) {\r\n  print a + b + c;\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This function defines three parameters, ",(0,r.jsx)(n.code,{children:"a"}),", ",(0,r.jsx)(n.code,{children:"b"}),", and ",(0,r.jsx)(n.code,{children:"c"}),", so its arity is\r\nthree and it expects three arguments. So what if you try to call it like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"add(1, 2, 3, 4); // Too many.\r\nadd(1, 2);       // Too few.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Different languages take different approaches to this problem. Of course, most\r\nstatically typed languages check this at compile time and refuse to compile the\r\ncode if the argument count doesn't match the function's arity. JavaScript\r\ndiscards any extra arguments you pass. If you don't pass enough, it fills in the\r\nmissing parameters with the magic sort-of-like-null-but-not-really value\r\n",(0,r.jsx)(n.code,{children:"undefined"}),". Python is stricter. It raises a runtime error if the argument list\r\nis too short or too long."]}),"\n",(0,r.jsx)(n.p,{children:"I think the latter is a better approach. Passing the wrong number of arguments\r\nis almost always a bug, and it's a mistake I do make in practice. Given that,\r\nthe sooner the implementation draws my attention to it, the better. So for Lox,\r\nwe'll take Python's approach. Before invoking the callable, we check to see if\r\nthe argument list's length matches the callable's arity."}),"\n",(0,r.jsx)(n.p,{children:"^code check-arity (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That requires a new method on the LoxCallable interface to ask it its arity."}),"\n",(0,r.jsx)(n.p,{children:"^code callable-arity (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We ",(0,r.jsx)(n.em,{children:"could"})," push the arity checking into the concrete implementation of ",(0,r.jsx)(n.code,{children:"call()"}),".\r\nBut, since we'll have multiple classes implementing LoxCallable, that would end\r\nup with redundant validation spread across a few classes. Hoisting it up into\r\nthe visit method lets us do it in one place."]}),"\n",(0,r.jsx)(n.h2,{id:"native-functions",children:"Native Functions"}),"\n",(0,r.jsxs)(n.p,{children:["We can theoretically call functions, but we have no functions to call yet.\r\nBefore we get to user-defined functions, now is a good time to introduce a vital\r\nbut often overlooked facet of language implementations -- ",(0,r.jsx)(n.span,{name:"native",children:(0,r.jsx)(n.strong,{children:"native functions"})}),". These are functions that the\r\ninterpreter exposes to user code but that are implemented in the host language\r\n(in our case Java), not the language being implemented (Lox)."]}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes these are called ",(0,r.jsx)(n.strong,{children:"primitives"}),", ",(0,r.jsx)(n.strong,{children:"external functions"}),", or ",(0,r.jsx)(n.strong,{children:"foreign\r\nfunctions"}),". Since these functions can be called while the user's program is\r\nrunning, they form part of the implementation's runtime. A lot of programming\r\nlanguage books gloss over these because they aren't conceptually interesting.\r\nThey're mostly grunt work."]}),"\n",(0,r.jsxs)(n.aside,{name:"native",children:["\n",(0,r.jsxs)(n.p,{children:['Curiously, two names for these functions -- "native" and "foreign" -- are\r\nantonyms. Maybe it depends on the perspective of the person choosing the term.\r\nIf you think of yourself as "living" within the runtime\'s implementation (in our\r\ncase, Java) then functions written in that are "native". But if you have the\r\nmindset of a ',(0,r.jsx)(n.em,{children:"user"}),' of your language, then the runtime is implemented in some\r\nother "foreign" language.']}),"\n",(0,r.jsx)(n.p,{children:'Or it may be that "native" refers to the machine code language of the underlying\r\nhardware. In Java, "native" methods are ones implemented in C or C++ and\r\ncompiled to native machine code.'}),"\n",(0,r.jsx)(n.img,{src:"image/functions/foreign.png",className:"above",alt:"All a matter of perspective."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["But when it comes to making your language actually good at doing useful stuff,\r\nthe native functions your implementation provides are key. They provide access\r\nto the fundamental services that all programs are defined in terms of. If you\r\ndon't provide native functions to access the file system, a user's going to have\r\na hell of a time writing a program that reads and ",(0,r.jsx)(n.span,{name:"print",children:"displays"})," a file."]}),"\n",(0,r.jsxs)(n.aside,{name:"print",children:["\n",(0,r.jsxs)(n.p,{children:["A classic native function almost every language provides is one to print text to\r\nstdout. In Lox, I made ",(0,r.jsx)(n.code,{children:"print"})," a built-in statement so that we could get stuff\r\non screen in the chapters before this one."]}),"\n",(0,r.jsx)(n.p,{children:"Once we have functions, we could simplify the language by tearing out the old\r\nprint syntax and replacing it with a native function. But that would mean that\r\nexamples early in the book wouldn't run on the interpreter from later chapters\r\nand vice versa. So, for the book, I'll leave it alone."}),"\n",(0,r.jsxs)(n.p,{children:["If you're building an interpreter for your ",(0,r.jsx)(n.em,{children:"own"})," language, though, you may want\r\nto consider it."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Many languages also allow users to provide their own native functions. The\r\nmechanism for doing so is called a ",(0,r.jsx)(n.strong,{children:"foreign function interface"})," (",(0,r.jsx)(n.strong,{children:"FFI"}),"),\r\n",(0,r.jsx)(n.strong,{children:"native extension"}),", ",(0,r.jsx)(n.strong,{children:"native interface"}),", or something along those lines.\r\nThese are nice because they free the language implementer from providing access\r\nto every single capability the underlying platform supports. We won't define an\r\nFFI for jlox, but we will add one native function to give you an idea of what it\r\nlooks like."]}),"\n",(0,r.jsx)(n.h3,{id:"telling-time",children:"Telling time"}),"\n",(0,r.jsxs)(n.p,{children:["When we get to ",(0,r.jsx)(n.a,{href:"a-bytecode-virtual-machine.html",children:"Part III"})," and start working on a much more efficient\r\nimplementation of Lox, we're going to care deeply about performance. Performance\r\nwork requires measurement, and that in turn means ",(0,r.jsx)(n.strong,{children:"benchmarks"}),". These are\r\nprograms that measure the time it takes to exercise some corner of the\r\ninterpreter."]}),"\n",(0,r.jsx)(n.p,{children:"We could measure the time it takes to start up the interpreter, run the\r\nbenchmark, and exit, but that adds a lot of overhead -- JVM startup time, OS\r\nshenanigans, etc. That stuff does matter, of course, but if you're just trying\r\nto validate an optimization to some piece of the interpreter, you don't want\r\nthat overhead obscuring your results."}),"\n",(0,r.jsx)(n.p,{children:"A nicer solution is to have the benchmark script itself measure the time elapsed\r\nbetween two points in the code. To do that, a Lox program needs to be able to\r\ntell time. There's no way to do that now -- you can't implement a useful clock\r\n\"from scratch\" without access to the underlying clock on the computer."}),"\n",(0,r.jsxs)(n.p,{children:["So we'll add ",(0,r.jsx)(n.code,{children:"clock()"}),", a native function that returns the number of seconds\r\nthat have passed since some fixed point in time. The difference between two\r\nsuccessive invocations tells you how much time elapsed between the two calls.\r\nThis function is defined in the global scope, so let's ensure the interpreter\r\nhas access to that."]}),"\n",(0,r.jsx)(n.p,{children:"^code global-environment (2 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"environment"})," field in the interpreter changes as we enter and exit local\r\nscopes. It tracks the ",(0,r.jsx)(n.em,{children:"current"})," environment. This new ",(0,r.jsx)(n.code,{children:"globals"})," field holds a\r\nfixed reference to the outermost global environment."]}),"\n",(0,r.jsx)(n.p,{children:"When we instantiate an Interpreter, we stuff the native function in that global\r\nscope."}),"\n",(0,r.jsx)(n.p,{children:"^code interpreter-constructor (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This defines a ",(0,r.jsx)(n.span,{name:"lisp-1",children:"variable"}),' named "clock". Its value is a\r\nJava anonymous class that implements LoxCallable. The ',(0,r.jsx)(n.code,{children:"clock()"})," function takes\r\nno arguments, so its arity is zero. The implementation of ",(0,r.jsx)(n.code,{children:"call()"})," calls the\r\ncorresponding Java function and converts the result to a double value in\r\nseconds."]}),"\n",(0,r.jsxs)(n.aside,{name:"lisp-1",children:["\n",(0,r.jsx)(n.p,{children:"In Lox, functions and variables occupy the same namespace. In Common Lisp, the\r\ntwo live in their own worlds. A function and variable with the same name don't\r\ncollide. If you call the name, it looks up the function. If you refer to it, it\r\nlooks up the variable. This does require jumping through some hoops when you do\r\nwant to refer to a function as a first-class value."}),"\n",(0,r.jsx)(n.p,{children:'Richard P. Gabriel and Kent Pitman coined the terms "Lisp-1" to refer to\r\nlanguages like Scheme that put functions and variables in the same namespace,\r\nand "Lisp-2" for languages like Common Lisp that partition them. Despite being\r\ntotally opaque, those names have since stuck. Lox is a Lisp-1.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If we wanted to add other native functions -- reading input from the user,\r\nworking with files, etc. -- we could add them each as their own anonymous class\r\nthat implements LoxCallable. But for the book, this one is really all we need."}),"\n",(0,r.jsx)(n.p,{children:"Let's get ourselves out of the function-defining business and let our users\r\ntake over..."}),"\n",(0,r.jsx)(n.h2,{id:"function-declarations",children:"Function Declarations"}),"\n",(0,r.jsxs)(n.p,{children:["We finally get to add a new production to the ",(0,r.jsx)(n.code,{children:"declaration"})," rule we introduced\r\nback when we added variables. Function declarations, like variables, bind a new\r\n",(0,r.jsx)(n.span,{name:"name",children:"name"}),". That means they are allowed only in places where\r\na declaration is permitted."]}),"\n",(0,r.jsxs)(n.aside,{name:"name",children:["\n",(0,r.jsx)(n.p,{children:"A named function declaration isn't really a single primitive operation. It's\r\nsyntactic sugar for two distinct steps: (1) creating a new function object, and\r\n(2) binding a new variable to it. If Lox had syntax for anonymous functions, we\r\nwouldn't need function declaration statements. You could just do:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"var add = fun (a, b) {\r\n  print a + b;\r\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"However, since named functions are the common case, I went ahead and gave Lox\r\nnice syntax for them."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:"declaration    \u2192 funDecl\r\n               | varDecl\r\n               | statement ;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The updated ",(0,r.jsx)(n.code,{children:"declaration"})," rule references this new rule:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:'funDecl        \u2192 "fun" function ;\r\nfunction       \u2192 IDENTIFIER "(" parameters? ")" block ;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The main ",(0,r.jsx)(n.code,{children:"funDecl"})," rule uses a separate helper rule ",(0,r.jsx)(n.code,{children:"function"}),". A function\r\n",(0,r.jsx)(n.em,{children:"declaration statement"})," is the ",(0,r.jsx)(n.code,{children:"fun"})," keyword followed by the actual function-y\r\nstuff. When we get to classes, we'll reuse that ",(0,r.jsx)(n.code,{children:"function"})," rule for declaring\r\nmethods. Those look similar to function declarations, but aren't preceded by\r\n",(0,r.jsx)(n.span,{name:"fun",children:(0,r.jsx)(n.code,{children:"fun"})}),"."]}),"\n",(0,r.jsxs)(n.aside,{name:"fun",children:["\n",(0,r.jsx)(n.p,{children:"Methods are too classy to have fun."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The function itself is a name followed by the parenthesized parameter list and\r\nthe body. The body is always a braced block, using the same grammar rule that\r\nblock statements use. The parameter list uses this rule:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:'parameters     \u2192 IDENTIFIER ( "," IDENTIFIER )* ;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["It's like the earlier ",(0,r.jsx)(n.code,{children:"arguments"})," rule, except that each parameter is an\r\nidentifier, not an expression. That's a lot of new syntax for the parser to chew\r\nthrough, but the resulting AST ",(0,r.jsx)(n.span,{name:"fun-ast",children:"node"})," isn't too bad."]}),"\n",(0,r.jsx)(n.p,{children:"^code function-ast (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.aside,{name:"fun-ast",children:["\n",(0,r.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,r.jsx)(n.a,{href:"appendix-ii.html#function-statement",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A function node has a name, a list of parameters (their names), and then the\r\nbody. We store the body as the list of statements contained inside the curly\r\nbraces."}),"\n",(0,r.jsx)(n.p,{children:"Over in the parser, we weave in the new declaration."}),"\n",(0,r.jsx)(n.p,{children:"^code match-fun (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Like other statements, a function is recognized by the leading keyword. When we\r\nencounter ",(0,r.jsx)(n.code,{children:"fun"}),", we call ",(0,r.jsx)(n.code,{children:"function"}),". That corresponds to the ",(0,r.jsx)(n.code,{children:"function"})," grammar\r\nrule since we already matched and consumed the ",(0,r.jsx)(n.code,{children:"fun"})," keyword. We'll build the\r\nmethod up a piece at a time, starting with this:"]}),"\n",(0,r.jsx)(n.p,{children:"^code parse-function"}),"\n",(0,r.jsxs)(n.p,{children:["Right now, it only consumes the identifier token for the function's name. You\r\nmight be wondering about that funny little ",(0,r.jsx)(n.code,{children:"kind"})," parameter. Just like we reuse\r\nthe grammar rule, we'll reuse the ",(0,r.jsx)(n.code,{children:"function()"}),' method later to parse methods\r\ninside classes. When we do that, we\'ll pass in "method" for ',(0,r.jsx)(n.code,{children:"kind"})," so that the\r\nerror messages are specific to the kind of declaration being parsed."]}),"\n",(0,r.jsx)(n.p,{children:"Next, we parse the parameter list and the pair of parentheses wrapped around it."}),"\n",(0,r.jsx)(n.p,{children:"^code parse-parameters (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This is like the code for handling arguments in a call, except not split out\r\ninto a helper method. The outer ",(0,r.jsx)(n.code,{children:"if"})," statement handles the zero parameter case,\r\nand the inner ",(0,r.jsx)(n.code,{children:"while"})," loop parses parameters as long as we find commas to\r\nseparate them. The result is the list of tokens for each parameter's name."]}),"\n",(0,r.jsx)(n.p,{children:"Just like we do with arguments to function calls, we validate at parse time\r\nthat you don't exceed the maximum number of parameters a function is allowed to\r\nhave."}),"\n",(0,r.jsx)(n.p,{children:"Finally, we parse the body and wrap it all up in a function node."}),"\n",(0,r.jsx)(n.p,{children:"^code parse-body (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Note that we consume the ",(0,r.jsx)(n.code,{children:"{"})," at the beginning of the body here before calling\r\n",(0,r.jsx)(n.code,{children:"block()"}),". That's because ",(0,r.jsx)(n.code,{children:"block()"})," assumes the brace token has already been\r\nmatched. Consuming it here lets us report a more precise error message if the\r\n",(0,r.jsx)(n.code,{children:"{"})," isn't found since we know it's in the context of a function declaration."]}),"\n",(0,r.jsx)(n.h2,{id:"function-objects",children:"Function Objects"}),"\n",(0,r.jsx)(n.p,{children:"We've got some syntax parsed so usually we're ready to interpret, but first we\r\nneed to think about how to represent a Lox function in Java. We need to keep\r\ntrack of the parameters so that we can bind them to argument values when the\r\nfunction is called. And, of course, we need to keep the code for the body of the\r\nfunction so that we can execute it."}),"\n",(0,r.jsx)(n.p,{children:"That's basically what the Stmt.Function class is. Could we just use that?\r\nAlmost, but not quite. We also need a class that implements LoxCallable so that\r\nwe can call it. We don't want the runtime phase of the interpreter to bleed into\r\nthe front end's syntax classes so we don't want Stmt.Function itself to\r\nimplement that. Instead, we wrap it in a new class."}),"\n",(0,r.jsx)(n.p,{children:"^code lox-function"}),"\n",(0,r.jsxs)(n.p,{children:["We implement the ",(0,r.jsx)(n.code,{children:"call()"})," of LoxCallable like so:"]}),"\n",(0,r.jsx)(n.p,{children:"^code function-call"}),"\n",(0,r.jsxs)(n.p,{children:["This handful of lines of code is one of the most fundamental, powerful pieces of\r\nour interpreter. As we saw in ",(0,r.jsxs)(n.a,{href:"statements-and-state.html",children:["the chapter on statements and ",(0,r.jsx)(n.span,{name:"env",children:"state"})]}),", managing name environments is a core part\r\nof a language implementation. Functions are deeply tied to that."]}),"\n",(0,r.jsxs)(n.aside,{name:"env",children:["\n",(0,r.jsxs)(n.p,{children:["We'll dig even deeper into environments in the ",(0,r.jsx)(n.a,{href:"resolving-and-binding.html",children:"next chapter"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Parameters are core to functions, especially the fact that a function\r\n",(0,r.jsx)(n.em,{children:"encapsulates"})," its parameters -- no other code outside of the function can see\r\nthem. This means each function gets its own environment where it stores those\r\nvariables."]}),"\n",(0,r.jsxs)(n.p,{children:["Further, this environment must be created dynamically. Each function ",(0,r.jsx)(n.em,{children:"call"})," gets\r\nits own environment. Otherwise, recursion would break. If there are multiple\r\ncalls to the same function in play at the same time, each needs its ",(0,r.jsx)(n.em,{children:"own"}),"\r\nenvironment, even though they are all calls to the same function."]}),"\n",(0,r.jsx)(n.p,{children:"For example, here's a convoluted way to count to three:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun count(n) {\r\n  if (n > 1) count(n - 1);\r\n  print n;\r\n}\r\n\r\ncount(3);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Imagine we pause the interpreter right at the point where it's about to print 1\r\nin the innermost nested call. The outer calls to print 2 and 3 haven't printed\r\ntheir values yet, so there must be environments somewhere in memory that still\r\nstore the fact that ",(0,r.jsx)(n.code,{children:"n"})," is bound to 3 in one context, 2 in another, and 1 in the\r\ninnermost, like:"]}),"\n",(0,r.jsx)(n.img,{src:"image/functions/recursion.png",alt:"A separate environment for each recursive call."}),"\n",(0,r.jsxs)(n.p,{children:["That's why we create a new environment at each ",(0,r.jsx)(n.em,{children:"call"}),", not at the function\r\n",(0,r.jsx)(n.em,{children:"declaration"}),". The ",(0,r.jsx)(n.code,{children:"call()"})," method we saw earlier does that. At the beginning of\r\nthe call, it creates a new environment. Then it walks the parameter and argument\r\nlists in lockstep. For each pair, it creates a new variable with the parameter's\r\nname and binds it to the argument's value."]}),"\n",(0,r.jsx)(n.p,{children:"So, for a program like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun add(a, b, c) {\r\n  print a + b + c;\r\n}\r\n\r\nadd(1, 2, 3);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["At the point of the call to ",(0,r.jsx)(n.code,{children:"add()"}),", the interpreter creates something like\r\nthis:"]}),"\n",(0,r.jsx)(n.img,{src:"image/functions/binding.png",alt:"Binding arguments to their parameters."}),"\n",(0,r.jsxs)(n.p,{children:["Then ",(0,r.jsx)(n.code,{children:"call()"})," tells the interpreter to execute the body of the function in this\r\nnew function-local environment. Up until now, the current environment was the\r\nenvironment where the function was being called. Now, we teleport from there\r\ninside the new parameter space we've created for the function."]}),"\n",(0,r.jsx)(n.p,{children:"This is all that's required to pass data into the function. By using different\r\nenvironments when we execute the body, calls to the same function with the\r\nsame code can produce different results."}),"\n",(0,r.jsxs)(n.p,{children:["Once the body of the function has finished executing, ",(0,r.jsx)(n.code,{children:"executeBlock()"})," discards\r\nthat function-local environment and restores the previous one that was active\r\nback at the callsite. Finally, ",(0,r.jsx)(n.code,{children:"call()"})," returns ",(0,r.jsx)(n.code,{children:"null"}),", which returns ",(0,r.jsx)(n.code,{children:"nil"})," to\r\nthe caller. (We'll add return values later.)"]}),"\n",(0,r.jsxs)(n.p,{children:["Mechanically, the code is pretty simple. Walk a couple of lists. Bind some new\r\nvariables. Call a method. But this is where the crystalline ",(0,r.jsx)(n.em,{children:"code"})," of the\r\nfunction declaration becomes a living, breathing ",(0,r.jsx)(n.em,{children:"invocation"}),". This is one of my\r\nfavorite snippets in this entire book. Feel free to take a moment to meditate on\r\nit if you're so inclined."]}),"\n",(0,r.jsxs)(n.p,{children:["Done? OK. Note when we bind the parameters, we assume the parameter and argument\r\nlists have the same length. This is safe because ",(0,r.jsx)(n.code,{children:"visitCallExpr()"})," checks the\r\narity before calling ",(0,r.jsx)(n.code,{children:"call()"}),". It relies on the function reporting its arity to\r\ndo that."]}),"\n",(0,r.jsx)(n.p,{children:"^code function-arity"}),"\n",(0,r.jsxs)(n.p,{children:["That's most of our object representation. While we're in here, we may as well\r\nimplement ",(0,r.jsx)(n.code,{children:"toString()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code function-to-string"}),"\n",(0,r.jsx)(n.p,{children:"This gives nicer output if a user decides to print a function value."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun add(a, b) {\r\n  print a + b;\r\n}\r\n\r\nprint add; // "<fn add>".\n'})}),"\n",(0,r.jsx)(n.h3,{id:"interpreting-function-declarations",children:"Interpreting function declarations"}),"\n",(0,r.jsx)(n.p,{children:"We'll come back and refine LoxFunction soon, but that's enough to get started.\r\nNow we can visit a function declaration."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-function"}),"\n",(0,r.jsxs)(n.p,{children:["This is similar to how we interpret other literal expressions. We take a\r\nfunction ",(0,r.jsx)(n.em,{children:"syntax node"})," -- a compile-time representation of the function -- and\r\nconvert it to its runtime representation. Here, that's a LoxFunction that wraps\r\nthe syntax node."]}),"\n",(0,r.jsxs)(n.p,{children:["Function declarations are different from other literal nodes in that the\r\ndeclaration ",(0,r.jsx)(n.em,{children:"also"})," binds the resulting object to a new variable. So, after\r\ncreating the LoxFunction, we create a new binding in the current environment and\r\nstore a reference to it there."]}),"\n",(0,r.jsx)(n.p,{children:"With that, we can define and call our own functions all within Lox. Give it a\r\ntry:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun sayHi(first, last) {\r\n  print "Hi, " + first + " " + last + "!";\r\n}\r\n\r\nsayHi("Dear", "Reader");\n'})}),"\n",(0,r.jsx)(n.p,{children:"I don't know about you, but that looks like an honest-to-God programming\r\nlanguage to me."}),"\n",(0,r.jsx)(n.h2,{id:"return-statements",children:"Return Statements"}),"\n",(0,r.jsxs)(n.p,{children:["We can get data into functions by passing parameters, but we've got no way to\r\nget results back ",(0,r.jsx)(n.span,{name:"hotel",children:(0,r.jsx)(n.em,{children:"out"})}),". If Lox were an\r\nexpression-oriented language like Ruby or Scheme, the body would be an\r\nexpression whose value is implicitly the function's result. But in Lox, the body\r\nof a function is a list of statements which don't produce values, so we need\r\ndedicated syntax for emitting a result. In other words, ",(0,r.jsx)(n.code,{children:"return"})," statements. I'm\r\nsure you can guess the grammar already."]}),"\n",(0,r.jsxs)(n.aside,{name:"hotel",children:["\n",(0,r.jsx)(n.p,{children:"The Hotel California of data."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ebnf",children:'statement      \u2192 exprStmt\r\n               | forStmt\r\n               | ifStmt\r\n               | printStmt\r\n               | returnStmt\r\n               | whileStmt\r\n               | block ;\r\n\r\nreturnStmt     \u2192 "return" expression? ";" ;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We've got one more -- the final, in fact -- production under the venerable\r\n",(0,r.jsx)(n.code,{children:"statement"})," rule. A ",(0,r.jsx)(n.code,{children:"return"})," statement is the ",(0,r.jsx)(n.code,{children:"return"})," keyword followed by an\r\noptional expression and terminated with a semicolon."]}),"\n",(0,r.jsxs)(n.p,{children:["The return value is optional to support exiting early from a function that\r\ndoesn't return a useful value. In statically typed languages, \"void\" functions\r\ndon't return a value and non-void ones do. Since Lox is dynamically typed, there\r\nare no true void functions. The compiler has no way of preventing you from\r\ntaking the result value of a call to a function that doesn't contain a ",(0,r.jsx)(n.code,{children:"return"}),"\r\nstatement."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun procedure() {\r\n  print "don\'t return anything";\r\n}\r\n\r\nvar result = procedure();\r\nprint result; // ?\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This means every Lox function must return ",(0,r.jsx)(n.em,{children:"something"}),", even if it contains no\r\n",(0,r.jsx)(n.code,{children:"return"})," statements at all. We use ",(0,r.jsx)(n.code,{children:"nil"})," for this, which is why LoxFunction's\r\nimplementation of ",(0,r.jsx)(n.code,{children:"call()"})," returns ",(0,r.jsx)(n.code,{children:"null"})," at the end. In that same vein, if you\r\nomit the value in a ",(0,r.jsx)(n.code,{children:"return"})," statement, we simply treat it as equivalent to:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"return nil;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Over in our AST generator, we add a ",(0,r.jsx)(n.span,{name:"return-ast",children:"new node"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code return-ast (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.aside,{name:"return-ast",children:["\n",(0,r.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,r.jsx)(n.a,{href:"appendix-ii.html#return-statement",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["It keeps the ",(0,r.jsx)(n.code,{children:"return"})," keyword token so we can use its location for error\r\nreporting, and the value being returned, if any. We parse it like other\r\nstatements, first by recognizing the initial keyword."]}),"\n",(0,r.jsx)(n.p,{children:"^code match-return (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That branches out to:"}),"\n",(0,r.jsx)(n.p,{children:"^code parse-return-statement"}),"\n",(0,r.jsxs)(n.p,{children:["After snagging the previously consumed ",(0,r.jsx)(n.code,{children:"return"})," keyword, we look for a value\r\nexpression. Since many different tokens can potentially start an expression,\r\nit's hard to tell if a return value is ",(0,r.jsx)(n.em,{children:"present"}),". Instead, we check if it's\r\n",(0,r.jsx)(n.em,{children:"absent"}),". Since a semicolon can't begin an expression, if the next token is\r\nthat, we know there must not be a value."]}),"\n",(0,r.jsx)(n.h3,{id:"returning-from-calls",children:"Returning from calls"}),"\n",(0,r.jsxs)(n.p,{children:["Interpreting a ",(0,r.jsx)(n.code,{children:"return"})," statement is tricky. You can return from anywhere within\r\nthe body of a function, even deeply nested inside other statements. When the\r\nreturn is executed, the interpreter needs to jump all the way out of whatever\r\ncontext it's currently in and cause the function call to complete, like some\r\nkind of jacked up control flow construct."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, say we're running this program and we're about to execute the\r\n",(0,r.jsx)(n.code,{children:"return"})," statement:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun count(n) {\r\n  while (n < 100) {\r\n    if (n == 3) return n; // <--\r\n    print n;\r\n    n = n + 1;\r\n  }\r\n}\r\n\r\ncount(1);\n"})}),"\n",(0,r.jsx)(n.p,{children:"The Java call stack currently looks roughly like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Interpreter.visitReturnStmt()\r\nInterpreter.visitIfStmt()\r\nInterpreter.executeBlock()\r\nInterpreter.visitBlockStmt()\r\nInterpreter.visitWhileStmt()\r\nInterpreter.executeBlock()\r\nLoxFunction.call()\r\nInterpreter.visitCallExpr()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We need to get from the top of the stack all the way back to ",(0,r.jsx)(n.code,{children:"call()"}),". I don't\r\nknow about you, but to me that sounds like exceptions. When we execute a\r\n",(0,r.jsx)(n.code,{children:"return"})," statement, we'll use an exception to unwind the interpreter past the\r\nvisit methods of all of the containing statements back to the code that began\r\nexecuting the body."]}),"\n",(0,r.jsx)(n.p,{children:"The visit method for our new AST node looks like this:"}),"\n",(0,r.jsx)(n.p,{children:"^code visit-return"}),"\n",(0,r.jsxs)(n.p,{children:["If we have a return value, we evaluate it, otherwise, we use ",(0,r.jsx)(n.code,{children:"nil"}),". Then we take\r\nthat value and wrap it in a custom exception class and throw it."]}),"\n",(0,r.jsx)(n.p,{children:"^code return-exception"}),"\n",(0,r.jsxs)(n.p,{children:["This class wraps the return value with the accoutrements Java requires for a\r\nruntime exception class. The weird super constructor call with those ",(0,r.jsx)(n.code,{children:"null"})," and\r\n",(0,r.jsx)(n.code,{children:"false"})," arguments disables some JVM machinery that we don't need. Since we're\r\nusing our exception class for ",(0,r.jsx)(n.span,{name:"exception",children:"control flow"})," and not\r\nactual error handling, we don't need overhead like stack traces."]}),"\n",(0,r.jsxs)(n.aside,{name:"exception",children:["\n",(0,r.jsx)(n.p,{children:"For the record, I'm not generally a fan of using exceptions for control flow.\r\nBut inside a heavily recursive tree-walk interpreter, it's the way to go. Since\r\nour own syntax tree evaluation is so heavily tied to the Java call stack, we're\r\npressed to do some heavyweight call stack manipulation occasionally, and\r\nexceptions are a handy tool for that."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We want this to unwind all the way to where the function call began, the\r\n",(0,r.jsx)(n.code,{children:"call()"})," method in LoxFunction."]}),"\n",(0,r.jsx)(n.p,{children:"^code catch-return (3 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We wrap the call to ",(0,r.jsx)(n.code,{children:"executeBlock()"})," in a try-catch block. When it catches a\r\nreturn exception, it pulls out the value and makes that the return value from\r\n",(0,r.jsx)(n.code,{children:"call()"}),". If it never catches one of these exceptions, it means the function\r\nreached the end of its body without hitting a ",(0,r.jsx)(n.code,{children:"return"})," statement. In that case,\r\nit implicitly returns ",(0,r.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Let's try it out. We finally have enough power to support this classic\r\nexample -- a recursive function to calculate Fibonacci numbers:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.span,{name:"slow"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun fib(n) {\r\n  if (n <= 1) return n;\r\n  return fib(n - 2) + fib(n - 1);\r\n}\r\n\r\nfor (var i = 0; i < 20; i = i + 1) {\r\n  print fib(i);\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This tiny program exercises almost every language feature we have spent the past\r\nseveral chapters implementing -- expressions, arithmetic, branching, looping,\r\nvariables, functions, function calls, parameter binding, and returns."}),"\n",(0,r.jsxs)(n.aside,{name:"slow",children:["\n",(0,r.jsx)(n.p,{children:"You might notice this is pretty slow. Obviously, recursion isn't the most\r\nefficient way to calculate Fibonacci numbers, but as a microbenchmark, it does\r\na good job of stress testing how fast our interpreter implements function calls."}),"\n",(0,r.jsx)(n.p,{children:'As you can see, the answer is "not very fast". That\'s OK. Our C interpreter will\r\nbe faster.'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"local-functions-and-closures",children:"Local Functions and Closures"}),"\n",(0,r.jsxs)(n.p,{children:["Our functions are pretty full featured, but there is one hole to patch. In fact,\r\nit's a big enough gap that we'll spend most of the ",(0,r.jsx)(n.a,{href:"resolving-and-binding.html",children:"next chapter"})," sealing it\r\nup, but we can get started here."]}),"\n",(0,r.jsxs)(n.p,{children:["LoxFunction's implementation of ",(0,r.jsx)(n.code,{children:"call()"})," creates a new environment where it\r\nbinds the function's parameters. When I showed you that code, I glossed over one\r\nimportant point: What is the ",(0,r.jsx)(n.em,{children:"parent"})," of that environment?"]}),"\n",(0,r.jsxs)(n.p,{children:["Right now, it is always ",(0,r.jsx)(n.code,{children:"globals"}),", the top-level global environment. That way,\r\nif an identifier isn't defined inside the function body itself, the interpreter\r\ncan look outside the function in the global scope to find it. In the Fibonacci\r\nexample, that's how the interpreter is able to look up the recursive call to\r\n",(0,r.jsx)(n.code,{children:"fib"})," inside the function's own body -- ",(0,r.jsx)(n.code,{children:"fib"})," is a global variable."]}),"\n",(0,r.jsxs)(n.p,{children:["But recall that in Lox, function declarations are allowed ",(0,r.jsx)(n.em,{children:"anywhere"})," a name can\r\nbe bound. That includes the top level of a Lox script, but also the inside of\r\nblocks or other functions. Lox supports ",(0,r.jsx)(n.strong,{children:"local functions"})," that are defined\r\ninside another function, or nested inside a block."]}),"\n",(0,r.jsx)(n.p,{children:"Consider this classic example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun makeCounter() {\r\n  var i = 0;\r\n  fun count() {\r\n    i = i + 1;\r\n    print i;\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\nvar counter = makeCounter();\r\ncounter(); // "1".\r\ncounter(); // "2".\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, ",(0,r.jsx)(n.code,{children:"count()"})," uses ",(0,r.jsx)(n.code,{children:"i"}),", which is declared outside of itself in the containing\r\nfunction ",(0,r.jsx)(n.code,{children:"makeCounter()"}),". ",(0,r.jsx)(n.code,{children:"makeCounter()"})," returns a reference to the ",(0,r.jsx)(n.code,{children:"count()"}),"\r\nfunction and then its own body finishes executing completely."]}),"\n",(0,r.jsxs)(n.p,{children:["Meanwhile, the top-level code invokes the returned ",(0,r.jsx)(n.code,{children:"count()"})," function. That\r\nexecutes the body of ",(0,r.jsx)(n.code,{children:"count()"}),", which assigns to and reads ",(0,r.jsx)(n.code,{children:"i"}),", even though the\r\nfunction where ",(0,r.jsx)(n.code,{children:"i"})," was defined has already exited."]}),"\n",(0,r.jsxs)(n.p,{children:["If you've never encountered a language with nested functions before, this might\r\nseem crazy, but users do expect it to work. Alas, if you run it now, you get an\r\nundefined variable error in the call to ",(0,r.jsx)(n.code,{children:"counter()"})," when the body of ",(0,r.jsx)(n.code,{children:"count()"}),"\r\ntries to look up ",(0,r.jsx)(n.code,{children:"i"}),". That's because the environment chain in effect looks like\r\nthis:"]}),"\n",(0,r.jsx)(n.img,{src:"image/functions/global.png",alt:"The environment chain from count()'s body to the global scope."}),"\n",(0,r.jsxs)(n.p,{children:["When we call ",(0,r.jsx)(n.code,{children:"count()"})," (through the reference to it stored in ",(0,r.jsx)(n.code,{children:"counter"}),"), we\r\ncreate a new empty environment for the function body. The parent of that is the\r\nglobal environment. We lost the environment for ",(0,r.jsx)(n.code,{children:"makeCounter()"})," where ",(0,r.jsx)(n.code,{children:"i"})," is\r\nbound."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's go back in time a bit. Here's what the environment chain looked like right\r\nwhen we declared ",(0,r.jsx)(n.code,{children:"count()"})," inside the body of ",(0,r.jsx)(n.code,{children:"makeCounter()"}),":"]}),"\n",(0,r.jsx)(n.img,{src:"image/functions/body.png",alt:"The environment chain inside the body of makeCounter()."}),"\n",(0,r.jsxs)(n.p,{children:["So at the point where the function is declared, we can see ",(0,r.jsx)(n.code,{children:"i"}),". But when we\r\nreturn from ",(0,r.jsx)(n.code,{children:"makeCounter()"})," and exit its body, the interpreter discards that\r\nenvironment. Since the interpreter doesn't keep the environment surrounding\r\n",(0,r.jsx)(n.code,{children:"count()"})," around, it's up to the function object itself to hang on to it."]}),"\n",(0,r.jsxs)(n.p,{children:["This data structure is called a ",(0,r.jsx)(n.span,{name:"closure",children:(0,r.jsx)(n.strong,{children:"closure"})}),' because\r\nit "closes over" and holds on to the surrounding variables where the function is\r\ndeclared. Closures have been around since the early Lisp days, and language\r\nhackers have come up with all manner of ways to implement them. For jlox, we\'ll\r\ndo the simplest thing that works. In LoxFunction, we add a field to store an\r\nenvironment.']}),"\n",(0,r.jsxs)(n.aside,{name:"closure",children:["\n",(0,r.jsx)(n.p,{children:'"Closure" is yet another term coined by Peter J. Landin. I assume before he came\r\nalong that computer scientists communicated with each other using only primitive\r\ngrunts and pawing hand gestures.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code closure-field (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We initialize that in the constructor."}),"\n",(0,r.jsx)(n.p,{children:"^code closure-constructor (1 after)"}),"\n",(0,r.jsx)(n.p,{children:"When we create a LoxFunction, we capture the current environment."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-closure (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["This is the environment that is active when the function is ",(0,r.jsx)(n.em,{children:"declared"})," not when\r\nit's ",(0,r.jsx)(n.em,{children:"called"}),", which is what we want. It represents the lexical scope\r\nsurrounding the function declaration. Finally, when we call the function, we use\r\nthat environment as the call's parent instead of going straight to ",(0,r.jsx)(n.code,{children:"globals"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"^code call-closure (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"This creates an environment chain that goes from the function's body out through\r\nthe environments where the function is declared, all the way out to the global\r\nscope. The runtime environment chain matches the textual nesting of the source\r\ncode like we want. The end result when we call that function looks like this:"}),"\n",(0,r.jsx)(n.img,{src:"image/functions/closure.png",alt:"The environment chain with the closure."}),"\n",(0,r.jsxs)(n.p,{children:["Now, as you can see, the interpreter can still find ",(0,r.jsx)(n.code,{children:"i"})," when it needs to because\r\nit's in the middle of the environment chain. Try running that ",(0,r.jsx)(n.code,{children:"makeCounter()"}),"\r\nexample now. It works!"]}),"\n",(0,r.jsxs)(n.p,{children:["Functions let us abstract over, reuse, and compose code. Lox is much more\r\npowerful than the rudimentary arithmetic calculator it used to be. Alas, in our\r\nrush to cram closures in, we have let a tiny bit of dynamic scoping leak into\r\nthe interpreter. In the ",(0,r.jsx)(n.a,{href:"resolving-and-binding.html",children:"next chapter"}),", we will explore deeper into lexical\r\nscope and close that hole."]}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Our interpreter carefully checks that the number of arguments passed to a\r\nfunction matches the number of parameters it expects. Since this check is\r\ndone at runtime on every call, it has a performance cost. Smalltalk\r\nimplementations don't have that problem. Why not?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Lox's function declaration syntax performs two independent operations. It\r\ncreates a function and also binds it to a name. This improves usability for\r\nthe common case where you do want to associate a name with the function.\r\nBut in functional-styled code, you often want to create a function to\r\nimmediately pass it to some other function or return it. In that case, it\r\ndoesn't need a name."}),"\n",(0,r.jsxs)(n.p,{children:["Languages that encourage a functional style usually support ",(0,r.jsx)(n.strong,{children:"anonymous\r\nfunctions"})," or ",(0,r.jsx)(n.strong,{children:"lambdas"})," -- an expression syntax that creates a function\r\nwithout binding it to a name. Add anonymous function syntax to Lox so that\r\nthis works:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun thrice(fn) {\r\n  for (var i = 1; i <= 3; i = i + 1) {\r\n    fn(i);\r\n  }\r\n}\r\n\r\nthrice(fun (a) {\r\n  print a;\r\n});\r\n// "1".\r\n// "2".\r\n// "3".\n'})}),"\n",(0,r.jsx)(n.p,{children:"How do you handle the tricky case of an anonymous function expression\r\noccurring in an expression statement:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"fun () {};\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Is this program valid?"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun scope(a) {\r\n  var a = "local";\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In other words, are a function's parameters in the ",(0,r.jsx)(n.em,{children:"same"})," scope as its local\r\nvariables, or in an outer scope? What does Lox do? What about other\r\nlanguages you are familiar with? What do you think a language ",(0,r.jsx)(n.em,{children:"should"})," do?"]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);