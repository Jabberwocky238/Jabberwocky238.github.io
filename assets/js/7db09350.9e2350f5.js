"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[3523],{3559:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var r=t(4848),s=t(8453);const a={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/evaluating-expressions",title:"evaluating-expressions",description:"You are my creator, but I am your master; Obey!",source:"@site/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/evaluating-expressions",permalink:"/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"dedication",permalink:"/docs/Craftinginterpreters/not-translated-yet/dedication"},next:{title:"functions",permalink:"/docs/Craftinginterpreters/not-translated-yet/functions"}},l={},h=[{value:"Representing Values",id:"representing-values",level:2},{value:"Evaluating Expressions",id:"evaluating-expressions",level:2},{value:"Evaluating literals",id:"evaluating-literals",level:3},{value:"Evaluating parentheses",id:"evaluating-parentheses",level:3},{value:"Evaluating unary expressions",id:"evaluating-unary-expressions",level:3},{value:"Truthiness and falsiness",id:"truthiness-and-falsiness",level:3},{value:"Evaluating binary operators",id:"evaluating-binary-operators",level:3},{value:"Runtime Errors",id:"runtime-errors",level:2},{value:"Detecting runtime errors",id:"detecting-runtime-errors",level:3},{value:"Hooking Up the Interpreter",id:"hooking-up-the-interpreter",level:2},{value:"Reporting runtime errors",id:"reporting-runtime-errors",level:3},{value:"Running the interpreter",id:"running-the-interpreter",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Static and Dynamic Typing",id:"design-note-static-and-dynamic-typing",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"You are my creator, but I am your master; Obey!"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["Mary Shelley, ",(0,r.jsx)(n.em,{children:"Frankenstein"})]})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If you want to properly set the mood for this chapter, try to conjure up a\r\nthunderstorm, one of those swirling tempests that likes to yank open shutters at\r\nthe climax of the story. Maybe toss in a few bolts of lightning. In this\r\nchapter, our interpreter will take breath, open its eyes, and execute some code."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.span,{name:"spooky"})}),"\n",(0,r.jsx)(n.img,{src:"image/evaluating-expressions/lightning.png",alt:"A bolt of lightning strikes a Victorian mansion. Spooky!"}),"\n",(0,r.jsxs)(n.aside,{name:"spooky",children:["\n",(0,r.jsx)(n.p,{children:"A decrepit Victorian mansion is optional, but adds to the ambiance."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"There are all manner of ways that language implementations make a computer do\r\nwhat the user's source code commands. They can compile it to machine code,\r\ntranslate it to another high-level language, or reduce it to some bytecode\r\nformat for a virtual machine to run. For our first interpreter, though, we are\r\ngoing to take the simplest, shortest path and execute the syntax tree itself."}),"\n",(0,r.jsx)(n.p,{children:'Right now, our parser only supports expressions. So, to "execute" code, we will\r\nevaluate an expression and produce a value. For each kind of expression syntax\r\nwe can parse -- literal, operator, etc. -- we need a corresponding chunk of code\r\nthat knows how to evaluate that tree and produce a result. That raises two\r\nquestions:'}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"What kinds of values do we produce?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"How do we organize those chunks of code?"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Taking them on one at a time..."}),"\n",(0,r.jsx)(n.h2,{id:"representing-values",children:"Representing Values"}),"\n",(0,r.jsxs)(n.p,{children:["In Lox, ",(0,r.jsx)(n.span,{name:"value",children:"values"})," are created by literals, computed by\r\nexpressions, and stored in variables. The user sees these as ",(0,r.jsx)(n.em,{children:"Lox"})," objects, but\r\nthey are implemented in the underlying language our interpreter is written in.\r\nThat means bridging the lands of Lox's dynamic typing and Java's static types. A\r\nvariable in Lox can store a value of any (Lox) type, and can even store values\r\nof different types at different points in time. What Java type might we use to\r\nrepresent that?"]}),"\n",(0,r.jsxs)(n.aside,{name:"value",children:["\n",(0,r.jsx)(n.p,{children:'Here, I\'m using "value" and "object" pretty much interchangeably.'}),"\n",(0,r.jsx)(n.p,{children:"Later in the C interpreter we'll make a slight distinction between them, but\r\nthat's mostly to have unique terms for two different corners of the\r\nimplementation -- in-place versus heap-allocated data. From the user's\r\nperspective, the terms are synonymous."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Given a Java variable with that static type, we must also be able to determine\r\nwhich kind of value it holds at runtime. When the interpreter executes a ",(0,r.jsx)(n.code,{children:"+"}),"\r\noperator, it needs to tell if it is adding two numbers or concatenating two\r\nstrings. Is there a Java type that can hold numbers, strings, Booleans, and\r\nmore? Is there one that can tell us what its runtime type is? There is! Good old\r\njava.lang.Object."]}),"\n",(0,r.jsx)(n.p,{children:"In places in the interpreter where we need to store a Lox value, we can use\r\nObject as the type. Java has boxed versions of its primitive types that all\r\nsubclass Object, so we can use those for Lox's built-in types:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:["\n  ",(0,r.jsx)(n.td,{children:"Lox type"}),"\n  ",(0,r.jsx)(n.td,{children:"Java representation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:["\n  ",(0,r.jsx)(n.td,{children:"Any Lox value"}),"\n  ",(0,r.jsx)(n.td,{children:"Object"})]}),(0,r.jsxs)(n.tr,{children:["\n  ",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"nil"})}),"\n  ",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"null"})})]}),(0,r.jsxs)(n.tr,{children:["\n  ",(0,r.jsx)(n.td,{children:"Boolean"}),"\n  ",(0,r.jsx)(n.td,{children:"Boolean"})]}),(0,r.jsxs)(n.tr,{children:["\n  ",(0,r.jsx)(n.td,{children:"number"}),"\n  ",(0,r.jsx)(n.td,{children:"Double"})]}),(0,r.jsxs)(n.tr,{children:["\n  ",(0,r.jsx)(n.td,{children:"string"}),"\n  ",(0,r.jsx)(n.td,{children:"String"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Given a value of static type Object, we can determine if the runtime value is a\r\nnumber or a string or whatever using Java's built-in ",(0,r.jsx)(n.code,{children:"instanceof"})," operator. In\r\nother words, the ",(0,r.jsx)(n.span,{name:"jvm",children:"JVM"}),"'s own object representation\r\nconveniently gives us everything we need to implement Lox's built-in types.\r\nWe'll have to do a little more work later when we add Lox's notions of\r\nfunctions, classes, and instances, but Object and the boxed primitive classes\r\nare sufficient for the types we need right now."]}),"\n",(0,r.jsxs)(n.aside,{name:"jvm",children:["\n",(0,r.jsx)(n.p,{children:"Another thing we need to do with values is manage their memory, and Java does\r\nthat too. A handy object representation and a really nice garbage collector are\r\nthe main reasons we're writing our first interpreter in Java."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"evaluating-expressions",children:"Evaluating Expressions"}),"\n",(0,r.jsxs)(n.p,{children:["Next, we need blobs of code to implement the evaluation logic for each kind of\r\nexpression we can parse. We could stuff that code into the syntax tree classes\r\nin something like an ",(0,r.jsx)(n.code,{children:"interpret()"}),' method. In effect, we could tell each syntax\r\ntree node, "Interpret thyself". This is the Gang of Four\'s\r\n',(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Interpreter_pattern",children:"Interpreter design pattern"}),". It's a neat pattern, but like I mentioned\r\nearlier, it gets messy if we jam all sorts of logic into the tree classes."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, we're going to reuse our groovy ",(0,r.jsx)(n.a,{href:"representing-code.html#the-visitor-pattern",children:"Visitor pattern"}),". In the previous\r\nchapter, we created an AstPrinter class. It took in a syntax tree and\r\nrecursively traversed it, building up a string which it ultimately returned.\r\nThat's almost exactly what a real interpreter does, except instead of\r\nconcatenating strings, it computes values."]}),"\n",(0,r.jsx)(n.p,{children:"We start with a new class."}),"\n",(0,r.jsx)(n.p,{children:"^code interpreter-class"}),"\n",(0,r.jsx)(n.p,{children:"The class declares that it's a visitor. The return type of the visit methods\r\nwill be Object, the root class that we use to refer to a Lox value in our Java\r\ncode. To satisfy the Visitor interface, we need to define visit methods for each\r\nof the four expression tree classes our parser produces. We'll start with the\r\nsimplest..."}),"\n",(0,r.jsx)(n.h3,{id:"evaluating-literals",children:"Evaluating literals"}),"\n",(0,r.jsxs)(n.p,{children:["The leaves of an expression tree -- the atomic bits of syntax that all other\r\nexpressions are composed of -- are ",(0,r.jsx)(n.span,{name:"leaf",children:"literals"}),". Literals\r\nare almost values already, but the distinction is important. A literal is a ",(0,r.jsx)(n.em,{children:"bit\r\nof syntax"})," that produces a value. A literal always appears somewhere in the\r\nuser's source code. Lots of values are produced by computation and don't exist\r\nanywhere in the code itself. Those aren't literals. A literal comes from the\r\nparser's domain. Values are an interpreter concept, part of the runtime's world."]}),"\n",(0,r.jsxs)(n.aside,{name:"leaf",children:["\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.a,{href:"statements-and-state.html",children:"next chapter"}),", when we implement variables, we'll add identifier\r\nexpressions, which are also leaf nodes."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["So, much like we converted a literal ",(0,r.jsx)(n.em,{children:"token"})," into a literal ",(0,r.jsx)(n.em,{children:"syntax tree node"}),"\r\nin the parser, now we convert the literal tree node into a runtime value. That\r\nturns out to be trivial."]}),"\n",(0,r.jsx)(n.p,{children:"^code visit-literal"}),"\n",(0,r.jsx)(n.p,{children:"We eagerly produced the runtime value way back during scanning and stuffed it in\r\nthe token. The parser took that value and stuck it in the literal tree node,\r\nso to evaluate a literal, we simply pull it back out."}),"\n",(0,r.jsx)(n.h3,{id:"evaluating-parentheses",children:"Evaluating parentheses"}),"\n",(0,r.jsx)(n.p,{children:"The next simplest node to evaluate is grouping -- the node you get as a result\r\nof using explicit parentheses in an expression."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-grouping"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.span,{name:"grouping",children:"grouping"})," node has a reference to an inner node\r\nfor the expression contained inside the parentheses. To evaluate the grouping\r\nexpression itself, we recursively evaluate that subexpression and return it."]}),"\n",(0,r.jsx)(n.p,{children:"We rely on this helper method which simply sends the expression back into the\r\ninterpreter's visitor implementation:"}),"\n",(0,r.jsxs)(n.aside,{name:"grouping",children:["\n",(0,r.jsx)(n.p,{children:"Some parsers don't define tree nodes for parentheses. Instead, when parsing a\r\nparenthesized expression, they simply return the node for the inner expression.\r\nWe do create a node for parentheses in Lox because we'll need it later to\r\ncorrectly handle the left-hand sides of assignment expressions."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"^code evaluate"}),"\n",(0,r.jsx)(n.h3,{id:"evaluating-unary-expressions",children:"Evaluating unary expressions"}),"\n",(0,r.jsx)(n.p,{children:"Like grouping, unary expressions have a single subexpression that we must\r\nevaluate first. The difference is that the unary expression itself does a little\r\nwork afterwards."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-unary"}),"\n",(0,r.jsx)(n.p,{children:"First, we evaluate the operand expression. Then we apply the unary operator\r\nitself to the result of that. There are two different unary expressions,\r\nidentified by the type of the operator token."}),"\n",(0,r.jsxs)(n.p,{children:["Shown here is ",(0,r.jsx)(n.code,{children:"-"}),", which negates the result of the subexpression. The\r\nsubexpression must be a number. Since we don't ",(0,r.jsx)(n.em,{children:"statically"})," know that in Java,\r\nwe ",(0,r.jsx)(n.span,{name:"cast",children:"cast"})," it before performing the operation. This type\r\ncast happens at runtime when the ",(0,r.jsx)(n.code,{children:"-"})," is evaluated. That's the core of what makes\r\na language dynamically typed right there."]}),"\n",(0,r.jsxs)(n.aside,{name:"cast",children:["\n",(0,r.jsx)(n.p,{children:"You're probably wondering what happens if the cast fails. Fear not, we'll get\r\ninto that soon."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You can start to see how evaluation recursively traverses the tree. We can't\r\nevaluate the unary operator itself until after we evaluate its operand\r\nsubexpression. That means our interpreter is doing a ",(0,r.jsx)(n.strong,{children:"post-order traversal"})," --\r\neach node evaluates its children before doing its own work."]}),"\n",(0,r.jsx)(n.p,{children:"The other unary operator is logical not."}),"\n",(0,r.jsx)(n.p,{children:"^code unary-bang (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:['The implementation is simple, but what is this "truthy" thing about? We need to\r\nmake a little side trip to one of the great questions of Western philosophy:\r\n',(0,r.jsx)(n.em,{children:"What is truth?"})]}),"\n",(0,r.jsx)(n.h3,{id:"truthiness-and-falsiness",children:"Truthiness and falsiness"}),"\n",(0,r.jsxs)(n.p,{children:["OK, maybe we're not going to really get into the universal question, but at\r\nleast inside the world of Lox, we need to decide what happens when you use\r\nsomething other than ",(0,r.jsx)(n.code,{children:"true"})," or ",(0,r.jsx)(n.code,{children:"false"})," in a logic operation like ",(0,r.jsx)(n.code,{children:"!"})," or any\r\nother place where a Boolean is expected."]}),"\n",(0,r.jsxs)(n.p,{children:["We ",(0,r.jsx)(n.em,{children:"could"}),' just say it\'s an error because we don\'t roll with implicit\r\nconversions, but most dynamically typed languages aren\'t that ascetic. Instead,\r\nthey take the universe of values of all types and partition them into two sets,\r\none of which they define to be "true", or "truthful", or (my favorite) "truthy",\r\nand the rest which are "false" or "falsey". This partitioning is somewhat\r\narbitrary and gets ',(0,r.jsx)(n.span,{name:"weird",children:"weird"})," in a few languages."]}),"\n",(0,r.jsxs)(n.aside,{name:"weird",className:"bottom",children:["\n",(0,r.jsxs)(n.p,{children:["In JavaScript, strings are truthy, but empty strings are not. Arrays are truthy\r\nbut empty arrays are... also truthy. The number ",(0,r.jsx)(n.code,{children:"0"})," is falsey, but the ",(0,r.jsx)(n.em,{children:"string"}),"\r\n",(0,r.jsx)(n.code,{children:'"0"'})," is truthy."]}),"\n",(0,r.jsx)(n.p,{children:"In Python, empty strings are falsey like in JS, but other empty sequences are\r\nfalsey too."}),"\n",(0,r.jsxs)(n.p,{children:["In PHP, both the number ",(0,r.jsx)(n.code,{children:"0"})," and the string ",(0,r.jsx)(n.code,{children:'"0"'})," are falsey. Most other\r\nnon-empty strings are truthy."]}),"\n",(0,r.jsx)(n.p,{children:"Get all that?"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Lox follows Ruby's simple rule: ",(0,r.jsx)(n.code,{children:"false"})," and ",(0,r.jsx)(n.code,{children:"nil"})," are falsey, and everything else\r\nis truthy. We implement that like so:"]}),"\n",(0,r.jsx)(n.p,{children:"^code is-truthy"}),"\n",(0,r.jsx)(n.h3,{id:"evaluating-binary-operators",children:"Evaluating binary operators"}),"\n",(0,r.jsx)(n.p,{children:"On to the last expression tree class, binary operators. There's a handful of\r\nthem, and we'll start with the arithmetic ones."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-binary"}),"\n",(0,r.jsxs)(n.aside,{name:"left",children:["\n",(0,r.jsx)(n.p,{children:"Did you notice we pinned down a subtle corner of the language semantics here?\r\nIn a binary expression, we evaluate the operands in left-to-right order. If\r\nthose operands have side effects, that choice is user visible, so this isn't\r\nsimply an implementation detail."}),"\n",(0,r.jsx)(n.p,{children:"If we want our two interpreters to be consistent (hint: we do), we'll need to\r\nmake sure clox does the same thing."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"I think you can figure out what's going on here. The main difference from the\r\nunary negation operator is that we have two operands to evaluate."}),"\n",(0,r.jsx)(n.p,{children:"I left out one arithmetic operator because it's a little special."}),"\n",(0,r.jsx)(n.p,{children:"^code binary-plus (3 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"+"})," operator can also be used to concatenate two strings. To handle that, we\r\ndon't just assume the operands are a certain type and ",(0,r.jsx)(n.em,{children:"cast"})," them, we\r\ndynamically ",(0,r.jsx)(n.em,{children:"check"})," the type and choose the appropriate operation. This is why\r\nwe need our object representation to support ",(0,r.jsx)(n.code,{children:"instanceof"}),"."]}),"\n",(0,r.jsxs)(n.aside,{name:"plus",children:["\n",(0,r.jsxs)(n.p,{children:["We could have defined an operator specifically for string concatenation. That's\r\nwhat Perl (",(0,r.jsx)(n.code,{children:"."}),"), Lua (",(0,r.jsx)(n.code,{children:".."}),"), Smalltalk (",(0,r.jsx)(n.code,{children:","}),"), Haskell (",(0,r.jsx)(n.code,{children:"++"}),"), and others do."]}),"\n",(0,r.jsxs)(n.p,{children:["I thought it would make Lox a little more approachable to use the same syntax as\r\nJava, JavaScript, Python, and others. This means that the ",(0,r.jsx)(n.code,{children:"+"})," operator is\r\n",(0,r.jsx)(n.strong,{children:"overloaded"})," to support both adding numbers and concatenating strings. Even in\r\nlanguages that don't use ",(0,r.jsx)(n.code,{children:"+"})," for strings, they still often overload it for\r\nadding both integers and floating-point numbers."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Next up are the comparison operators."}),"\n",(0,r.jsx)(n.p,{children:"^code binary-comparison (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"They are basically the same as arithmetic. The only difference is that where the\r\narithmetic operators produce a value whose type is the same as the operands\r\n(numbers or strings), the comparison operators always produce a Boolean."}),"\n",(0,r.jsx)(n.p,{children:"The last pair of operators are equality."}),"\n",(0,r.jsx)(n.p,{children:"^code binary-equality"}),"\n",(0,r.jsxs)(n.p,{children:["Unlike the comparison operators which require numbers, the equality operators\r\nsupport operands of any type, even mixed ones. You can't ask Lox if 3 is ",(0,r.jsx)(n.em,{children:"less"}),"\r\nthan ",(0,r.jsx)(n.code,{children:'"three"'}),", but you can ask if it's ",(0,r.jsx)(n.span,{name:"equal",children:(0,r.jsx)(n.em,{children:"equal"})})," to\r\nit."]}),"\n",(0,r.jsxs)(n.aside,{name:"equal",children:["\n",(0,r.jsx)(n.p,{children:"Spoiler alert: it's not."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Like truthiness, the equality logic is hoisted out into a separate method."}),"\n",(0,r.jsx)(n.p,{children:"^code is-equal"}),"\n",(0,r.jsxs)(n.p,{children:["This is one of those corners where the details of how we represent Lox objects\r\nin terms of Java matter. We need to correctly implement ",(0,r.jsx)(n.em,{children:"Lox's"})," notion of\r\nequality, which may be different from Java's."]}),"\n",(0,r.jsxs)(n.p,{children:["Fortunately, the two are pretty similar. Lox doesn't do implicit conversions in\r\nequality and Java does not either. We do have to handle ",(0,r.jsx)(n.code,{children:"nil"}),"/",(0,r.jsx)(n.code,{children:"null"})," specially\r\nso that we don't throw a NullPointerException if we try to call ",(0,r.jsx)(n.code,{children:"equals()"})," on\r\n",(0,r.jsx)(n.code,{children:"null"}),". Otherwise, we're fine. Java's ",(0,r.jsx)(n.span,{name:"nan",children:(0,r.jsx)(n.code,{children:"equals()"})})," method\r\non Boolean, Double, and String have the behavior we want for Lox."]}),"\n",(0,r.jsxs)(n.aside,{name:"nan",children:["\n",(0,r.jsx)(n.p,{children:"What do you expect this to evaluate to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"(0 / 0) == (0 / 0)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["According to ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/IEEE_754",children:"IEEE 754"}),", which specifies the behavior of double-precision\r\nnumbers, dividing a zero by zero gives you the special ",(0,r.jsx)(n.strong,{children:"NaN"}),' ("not a number")\r\nvalue. Strangely enough, NaN is ',(0,r.jsx)(n.em,{children:"not"})," equal to itself."]}),"\n",(0,r.jsxs)(n.p,{children:["In Java, the ",(0,r.jsx)(n.code,{children:"=="})," operator on primitive doubles preserves that behavior, but the\r\n",(0,r.jsx)(n.code,{children:"equals()"})," method on the Double class does not. Lox uses the latter, so doesn't\r\nfollow IEEE. These kinds of subtle incompatibilities occupy a dismaying fraction\r\nof language implementers' lives."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["And that's it! That's all the code we need to correctly interpret a valid Lox\r\nexpression. But what about an ",(0,r.jsx)(n.em,{children:"invalid"})," one? In particular, what happens when a\r\nsubexpression evaluates to an object of the wrong type for the operation being\r\nperformed?"]}),"\n",(0,r.jsx)(n.h2,{id:"runtime-errors",children:"Runtime Errors"}),"\n",(0,r.jsxs)(n.p,{children:["I was cavalier about jamming casts in whenever a subexpression produces an\r\nObject and the operator requires it to be a number or a string. Those casts can\r\nfail. Even though the user's code is erroneous, if we want to make a ",(0,r.jsx)(n.span,{name:"fail",children:"usable"})," language, we are responsible for handling that error\r\ngracefully."]}),"\n",(0,r.jsxs)(n.aside,{name:"fail",children:["\n",(0,r.jsx)(n.p,{children:"We could simply not detect or report a type error at all. This is what C does if\r\nyou cast a pointer to some type that doesn't match the data that is actually\r\nbeing pointed to. C gains flexibility and speed by allowing that, but is\r\nalso famously dangerous. Once you misinterpret bits in memory, all bets are off."}),"\n",(0,r.jsxs)(n.p,{children:["Few modern languages accept unsafe operations like that. Instead, most are\r\n",(0,r.jsx)(n.strong,{children:"memory safe"})," and ensure -- through a combination of static and runtime checks\r\n-- that a program can never incorrectly interpret the value stored in a piece of\r\nmemory."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["It's time for us to talk about ",(0,r.jsx)(n.strong,{children:"runtime errors"}),". I spilled a lot of ink in the\r\nprevious chapters talking about error handling, but those were all ",(0,r.jsx)(n.em,{children:"syntax"})," or\r\n",(0,r.jsx)(n.em,{children:"static"})," errors. Those are detected and reported before ",(0,r.jsx)(n.em,{children:"any"})," code is executed.\r\nRuntime errors are failures that the language semantics demand we detect and\r\nreport while the program is running (hence the name)."]}),"\n",(0,r.jsxs)(n.p,{children:["Right now, if an operand is the wrong type for the operation being performed,\r\nthe Java cast will fail and the JVM will throw a ClassCastException. That\r\nunwinds the whole stack and exits the application, vomiting a Java stack trace\r\nonto the user. That's probably not what we want. The fact that Lox is\r\nimplemented in Java should be a detail hidden from the user. Instead, we want\r\nthem to understand that a ",(0,r.jsx)(n.em,{children:"Lox"})," runtime error occurred, and give them an error\r\nmessage relevant to our language and their program."]}),"\n",(0,r.jsx)(n.p,{children:"The Java behavior does have one thing going for it, though. It correctly stops\r\nexecuting any code when the error occurs. Let's say the user enters some\r\nexpression like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'2 * (3 / -"muffin")\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can't negate a ",(0,r.jsx)(n.span,{name:"muffin",children:"muffin"}),", so we need to report a\r\nruntime error at that inner ",(0,r.jsx)(n.code,{children:"-"})," expression. That in turn means we can't evaluate\r\nthe ",(0,r.jsx)(n.code,{children:"/"})," expression since it has no meaningful right operand. Likewise for the\r\n",(0,r.jsx)(n.code,{children:"*"}),". So when a runtime error occurs deep in some expression, we need to escape\r\nall the way out."]}),"\n",(0,r.jsxs)(n.aside,{name:"muffin",children:["\n",(0,r.jsxs)(n.p,{children:["I don't know, man, ",(0,r.jsx)(n.em,{children:"can"})," you negate a muffin?"]}),"\n",(0,r.jsx)(n.img,{src:"image/evaluating-expressions/muffin.png",alt:"A muffin, negated."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We could print a runtime error and then abort the process and exit the\r\napplication entirely. That has a certain melodramatic flair. Sort of the\r\nprogramming language interpreter equivalent of a mic drop."}),"\n",(0,r.jsxs)(n.p,{children:["Tempting as that is, we should probably do something a little less cataclysmic.\r\nWhile a runtime error needs to stop evaluating the ",(0,r.jsx)(n.em,{children:"expression"}),", it shouldn't\r\nkill the ",(0,r.jsx)(n.em,{children:"interpreter"}),". If a user is running the REPL and has a typo in a line\r\nof code, they should still be able to keep the session going and enter more code\r\nafter that."]}),"\n",(0,r.jsx)(n.h3,{id:"detecting-runtime-errors",children:"Detecting runtime errors"}),"\n",(0,r.jsx)(n.p,{children:"Our tree-walk interpreter evaluates nested expressions using recursive method\r\ncalls, and we need to unwind out of all of those. Throwing an exception in Java\r\nis a fine way to accomplish that. However, instead of using Java's own cast\r\nfailure, we'll define a Lox-specific one so that we can handle it how we want."}),"\n",(0,r.jsxs)(n.p,{children:["Before we do the cast, we check the object's type ourselves. So, for unary ",(0,r.jsx)(n.code,{children:"-"}),",\r\nwe add:"]}),"\n",(0,r.jsx)(n.p,{children:"^code check-unary-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"The code to check the operand is:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-operand"}),"\n",(0,r.jsx)(n.p,{children:"When the check fails, it throws one of these:"}),"\n",(0,r.jsx)(n.p,{children:"^code runtime-error-class"}),"\n",(0,r.jsxs)(n.p,{children:["Unlike the Java cast exception, our ",(0,r.jsx)(n.span,{name:"class",children:"class"})," tracks the\r\ntoken that identifies where in the user's code the runtime error came from. As\r\nwith static errors, this helps the user know where to fix their code."]}),"\n",(0,r.jsxs)(n.aside,{name:"class",children:["\n",(0,r.jsx)(n.p,{children:'I admit the name "RuntimeError" is confusing since Java defines a\r\nRuntimeException class. An annoying thing about building interpreters is your\r\nnames often collide with ones already taken by the implementation language. Just\r\nwait until we support Lox classes.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We need similar checking for the binary operators. Since I promised you every\r\nsingle line of code needed to implement the interpreters, I'll run through them\r\nall."}),"\n",(0,r.jsx)(n.p,{children:"Greater than:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-greater-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Greater than or equal to:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-greater-equal-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Less than:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-less-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Less than or equal to:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-less-equal-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Subtraction:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-minus-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Division:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-slash-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Multiplication:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-star-operand (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"All of those rely on this validator, which is virtually the same as the unary\r\none:"}),"\n",(0,r.jsx)(n.p,{children:"^code check-operands"}),"\n",(0,r.jsxs)(n.aside,{name:"operand",children:["\n",(0,r.jsxs)(n.p,{children:["Another subtle semantic choice: We evaluate ",(0,r.jsx)(n.em,{children:"both"})," operands before checking the\r\ntype of ",(0,r.jsx)(n.em,{children:"either"}),". Imagine we have a function ",(0,r.jsx)(n.code,{children:"say()"})," that prints its argument\r\nthen returns it. Using that, we write:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'say("left") - say("right");\n'})}),"\n",(0,r.jsx)(n.p,{children:'Our interpreter prints "left" and "right" before reporting the runtime error. We\r\ncould have instead specified that the left operand is checked before even\r\nevaluating the right.'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The last remaining operator, again the odd one out, is addition. Since ",(0,r.jsx)(n.code,{children:"+"})," is\r\noverloaded for numbers and strings, it already has code to check the types. All\r\nwe need to do is fail if neither of the two success cases match."]}),"\n",(0,r.jsx)(n.p,{children:"^code string-wrong-type (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That gets us detecting runtime errors deep in the innards of the evaluator. The\r\nerrors are getting thrown. The next step is to write the code that catches them.\r\nFor that, we need to wire up the Interpreter class into the main Lox class that\r\ndrives it."}),"\n",(0,r.jsx)(n.h2,{id:"hooking-up-the-interpreter",children:"Hooking Up the Interpreter"}),"\n",(0,r.jsx)(n.p,{children:"The visit methods are sort of the guts of the Interpreter class, where the real\r\nwork happens. We need to wrap a skin around them to interface with the rest of\r\nthe program. The Interpreter's public API is simply one method."}),"\n",(0,r.jsx)(n.p,{children:"^code interpret"}),"\n",(0,r.jsxs)(n.p,{children:["This takes in a syntax tree for an expression and evaluates it. If that\r\nsucceeds, ",(0,r.jsx)(n.code,{children:"evaluate()"})," returns an object for the result value. ",(0,r.jsx)(n.code,{children:"interpret()"}),"\r\nconverts that to a string and shows it to the user. To convert a Lox value to a\r\nstring, we rely on:"]}),"\n",(0,r.jsx)(n.p,{children:"^code stringify"}),"\n",(0,r.jsxs)(n.p,{children:["This is another of those pieces of code like ",(0,r.jsx)(n.code,{children:"isTruthy()"})," that crosses the\r\nmembrane between the user's view of Lox objects and their internal\r\nrepresentation in Java."]}),"\n",(0,r.jsxs)(n.p,{children:["It's pretty straightforward. Since Lox was designed to be familiar to someone\r\ncoming from Java, things like Booleans look the same in both languages. The two\r\nedge cases are ",(0,r.jsx)(n.code,{children:"nil"}),", which we represent using Java's ",(0,r.jsx)(n.code,{children:"null"}),", and numbers."]}),"\n",(0,r.jsxs)(n.p,{children:["Lox uses double-precision numbers even for integer values. In that case, they\r\nshould print without a decimal point. Since Java has both floating point and\r\ninteger types, it wants you to know which one you're using. It tells you by\r\nadding an explicit ",(0,r.jsx)(n.code,{children:".0"})," to integer-valued doubles. We don't care about that, so\r\nwe ",(0,r.jsx)(n.span,{name:"number",children:"hack"})," it off the end."]}),"\n",(0,r.jsxs)(n.aside,{name:"number",children:["\n",(0,r.jsx)(n.p,{children:"Yet again, we take care of this edge case with numbers to ensure that jlox and\r\nclox work the same. Handling weird corners of the language like this will drive\r\nyou crazy but is an important part of the job."}),"\n",(0,r.jsx)(n.p,{children:"Users rely on these details -- either deliberately or inadvertently -- and if\r\nthe implementations aren't consistent, their program will break when they run it\r\non different interpreters."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"reporting-runtime-errors",children:"Reporting runtime errors"}),"\n",(0,r.jsxs)(n.p,{children:["If a runtime error is thrown while evaluating the expression, ",(0,r.jsx)(n.code,{children:"interpret()"}),"\r\ncatches it. This lets us report the error to the user and then gracefully\r\ncontinue. All of our existing error reporting code lives in the Lox class, so we\r\nput this method there too:"]}),"\n",(0,r.jsx)(n.p,{children:"^code runtime-error-method"}),"\n",(0,r.jsxs)(n.p,{children:["We use the token associated with the RuntimeError to tell the user what line of\r\ncode was executing when the error occurred. Even better would be to give the\r\nuser an entire call stack to show how they ",(0,r.jsx)(n.em,{children:"got"})," to be executing that code. But\r\nwe don't have function calls yet, so I guess we don't have to worry about it."]}),"\n",(0,r.jsxs)(n.p,{children:["After showing the error, ",(0,r.jsx)(n.code,{children:"runtimeError()"})," sets this field:"]}),"\n",(0,r.jsx)(n.p,{children:"^code had-runtime-error-field (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That field plays a small but important role."}),"\n",(0,r.jsx)(n.p,{children:"^code check-runtime-error (4 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["If the user is running a Lox ",(0,r.jsx)(n.span,{name:"repl",children:"script from a file"})," and a\r\nruntime error occurs, we set an exit code when the process quits to let the\r\ncalling process know. Not everyone cares about shell etiquette, but we do."]}),"\n",(0,r.jsxs)(n.aside,{name:"repl",children:["\n",(0,r.jsx)(n.p,{children:"If the user is running the REPL, we don't care about tracking runtime errors.\r\nAfter they are reported, we simply loop around and let them input new code and\r\nkeep going."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"running-the-interpreter",children:"Running the interpreter"}),"\n",(0,r.jsx)(n.p,{children:"Now that we have an interpreter, the Lox class can start using it."}),"\n",(0,r.jsx)(n.p,{children:"^code interpreter-instance (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We make the field static so that successive calls to ",(0,r.jsx)(n.code,{children:"run()"})," inside a REPL\r\nsession reuse the same interpreter. That doesn't make a difference now, but it\r\nwill later when the interpreter stores global variables. Those variables should\r\npersist throughout the REPL session."]}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we remove the line of temporary code from the ",(0,r.jsx)(n.a,{href:"parsing-expressions.html",children:"last chapter"})," for\r\nprinting the syntax tree and replace it with this:"]}),"\n",(0,r.jsx)(n.p,{children:"^code interpreter-interpret (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We have an entire language pipeline now: scanning, parsing, and\r\nexecution. Congratulations, you now have your very own arithmetic calculator."}),"\n",(0,r.jsx)(n.p,{children:"As you can see, the interpreter is pretty bare bones. But the Interpreter class\r\nand the Visitor pattern we've set up today form the skeleton that later chapters\r\nwill stuff full of interesting guts -- variables, functions, etc. Right now, the\r\ninterpreter doesn't do very much, but it's alive!"}),"\n",(0,r.jsx)(n.img,{src:"image/evaluating-expressions/skeleton.png",alt:"A skeleton waving hello."}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Allowing comparisons on types other than numbers could be useful. The\r\noperators might have a reasonable interpretation for strings. Even\r\ncomparisons among mixed types, like ",(0,r.jsx)(n.code,{children:'3 < "pancake"'})," could be handy to enable\r\nthings like ordered collections of heterogeneous types. Or it could simply\r\nlead to bugs and confusion."]}),"\n",(0,r.jsx)(n.p,{children:"Would you extend Lox to support comparing other types? If so, which pairs of\r\ntypes do you allow and how do you define their ordering? Justify your\r\nchoices and compare them to other languages."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Many languages define ",(0,r.jsx)(n.code,{children:"+"})," such that if ",(0,r.jsx)(n.em,{children:"either"})," operand is a string, the\r\nother is converted to a string and the results are then concatenated. For\r\nexample, ",(0,r.jsx)(n.code,{children:'"scone" + 4'})," would yield ",(0,r.jsx)(n.code,{children:"scone4"}),". Extend the code in\r\n",(0,r.jsx)(n.code,{children:"visitBinaryExpr()"})," to support that."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"What happens right now if you divide a number by zero? What do you think\r\nshould happen? Justify your choice. How do other languages you know handle\r\ndivision by zero, and why do they make the choices they do?"}),"\n",(0,r.jsxs)(n.p,{children:["Change the implementation in ",(0,r.jsx)(n.code,{children:"visitBinaryExpr()"})," to detect and report a\r\nruntime error for this case."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.div,{className:"design-note",children:["\n",(0,r.jsx)(n.h2,{id:"design-note-static-and-dynamic-typing",children:"Design Note: Static and Dynamic Typing"}),"\n",(0,r.jsx)(n.p,{children:"Some languages, like Java, are statically typed which means type errors are\r\ndetected and reported at compile time before any code is run. Others, like Lox,\r\nare dynamically typed and defer checking for type errors until runtime right\r\nbefore an operation is attempted. We tend to consider this a black-and-white\r\nchoice, but there is actually a continuum between them."}),"\n",(0,r.jsxs)(n.p,{children:["It turns out even most statically typed languages do ",(0,r.jsx)(n.em,{children:"some"})," type checks at\r\nruntime. The type system checks most type rules statically, but inserts runtime\r\nchecks in the generated code for other operations."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, in Java, the ",(0,r.jsx)(n.em,{children:"static"})," type system assumes a cast expression will\r\nalways safely succeed. After you cast some value, you can statically treat it as\r\nthe destination type and not get any compile errors. But downcasts can fail,\r\nobviously. The only reason the static checker can presume that casts always\r\nsucceed without violating the language's soundness guarantees, is because the\r\ncast is checked ",(0,r.jsx)(n.em,{children:"at runtime"})," and throws an exception on failure."]}),"\n",(0,r.jsxs)(n.p,{children:["A more subtle example is ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Covariant_arrays_in_Java_and_C.23",children:"covariant arrays"})," in Java and C#. The static\r\nsubtyping rules for arrays allow operations that are not sound. Consider:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'Object[] stuff = new Integer[1];\r\nstuff[0] = "not an int!";\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This code compiles without any errors. The first line upcasts the Integer array\r\nand stores it in a variable of type Object array. The second line stores a\r\nstring in one of its cells. The Object array type statically allows that\r\n-- strings ",(0,r.jsx)(n.em,{children:"are"})," Objects -- but the actual Integer array that ",(0,r.jsx)(n.code,{children:"stuff"})," refers to\r\nat runtime should never have a string in it! To avoid that catastrophe, when you\r\nstore a value in an array, the JVM does a ",(0,r.jsx)(n.em,{children:"runtime"})," check to make sure it's an\r\nallowed type. If not, it throws an ArrayStoreException."]}),"\n",(0,r.jsxs)(n.p,{children:["Java could have avoided the need to check this at runtime by disallowing the\r\ncast on the first line. It could make arrays ",(0,r.jsx)(n.em,{children:"invariant"})," such that an array of\r\nIntegers is ",(0,r.jsx)(n.em,{children:"not"})," an array of Objects. That's statically sound, but it prohibits\r\ncommon and safe patterns of code that only read from arrays. Covariance is safe\r\nif you never ",(0,r.jsx)(n.em,{children:"write"})," to the array. Those patterns were particularly important\r\nfor usability in Java 1.0 before it supported generics. James Gosling and the\r\nother Java designers traded off a little static safety and performance -- those\r\narray store checks take time -- in return for some flexibility."]}),"\n",(0,r.jsxs)(n.p,{children:["There are few modern statically typed languages that don't make that trade-off\r\n",(0,r.jsx)(n.em,{children:"somewhere"}),". Even Haskell will let you run code with non-exhaustive matches. If\r\nyou find yourself designing a statically typed language, keep in mind that you\r\ncan sometimes give users more flexibility without sacrificing ",(0,r.jsx)(n.em,{children:"too"})," many of the\r\nbenefits of static safety by deferring some type checks until runtime."]}),"\n",(0,r.jsxs)(n.p,{children:["On the other hand, a key reason users choose statically typed languages is\r\nbecause of the confidence the language gives them that certain kinds of errors\r\ncan ",(0,r.jsx)(n.em,{children:"never"})," occur when their program is run. Defer too many type checks until\r\nruntime, and you erode that confidence."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);