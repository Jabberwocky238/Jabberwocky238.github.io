"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[2441],{5188:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=n(4848),i=n(8453);const s={},a=void 0,o={id:"Craftinginterpreters/not-translated-yet/a-virtual-machine",title:"a-virtual-machine",description:"Magicians protect their secrets not because the secrets are large and",source:"@site/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/a-virtual-machine",permalink:"/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"a-tree-walk-interpreter",permalink:"/docs/Craftinginterpreters/not-translated-yet/a-tree-walk-interpreter"},next:{title:"acknowledgements",permalink:"/docs/Craftinginterpreters/not-translated-yet/acknowledgements"}},h={},c=[{value:"An Instruction Execution Machine",id:"an-instruction-execution-machine",level:2},{value:"Executing instructions",id:"executing-instructions",level:3},{value:"Execution tracing",id:"execution-tracing",level:3},{value:"A Value Stack Manipulator",id:"a-value-stack-manipulator",level:2},{value:"The VM&#39;s Stack",id:"the-vms-stack",level:3},{value:"Stack tracing",id:"stack-tracing",level:3},{value:"An Arithmetic Calculator",id:"an-arithmetic-calculator",level:2},{value:"Binary operators",id:"binary-operators",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Register-Based Bytecode",id:"design-note-register-based-bytecode",level:2}];function l(e){const t={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{children:"Magicians protect their secrets not because the secrets are large and\r\nimportant, but because they are so small and trivial. The wonderful effects\r\ncreated on stage are often the result of a secret so absurd that the magician\r\nwould be embarrassed to admit that that was how it was done."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.cite,{children:["Christopher Priest, ",(0,r.jsx)(t.em,{children:"The Prestige"})]})}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["We've spent a lot of time talking about how to represent a program as a sequence\r\nof bytecode instructions, but it feels like learning biology using only stuffed,\r\ndead animals. We know what instructions are in theory, but we've never seen them\r\nin action, so it's hard to really understand what they ",(0,r.jsx)(t.em,{children:"do"}),". It would be hard to\r\nwrite a compiler that outputs bytecode when we don't have a good understanding\r\nof how that bytecode behaves."]}),"\n",(0,r.jsx)(t.p,{children:"So, before we go and build the front end of our new interpreter, we will begin\r\nwith the back end -- the virtual machine that executes instructions. It breathes\r\nlife into the bytecode. Watching the instructions prance around gives us a\r\nclearer picture of how a compiler might translate the user's source code into a\r\nseries of them."}),"\n",(0,r.jsx)(t.h2,{id:"an-instruction-execution-machine",children:"An Instruction Execution Machine"}),"\n",(0,r.jsx)(t.p,{children:"The virtual machine is one part of our interpreter's internal architecture. You\r\nhand it a chunk of code -- literally a Chunk -- and it runs it. The code and\r\ndata structures for the VM reside in a new module."}),"\n",(0,r.jsx)(t.p,{children:"^code vm-h"}),"\n",(0,r.jsx)(t.p,{children:"As usual, we start simple. The VM will gradually acquire a whole pile of state\r\nit needs to keep track of, so we define a struct now to stuff that all in.\r\nCurrently, all we store is the chunk that it executes."}),"\n",(0,r.jsx)(t.p,{children:"Like we do with most of the data structures we create, we also define functions\r\nto create and tear down a VM. Here's the implementation:"}),"\n",(0,r.jsx)(t.p,{children:"^code vm-c"}),"\n",(0,r.jsx)(t.p,{children:"OK, calling those functions \"implementations\" is a stretch. We don't have any\r\ninteresting state to initialize or free yet, so the functions are empty. Trust\r\nme, we'll get there."}),"\n",(0,r.jsxs)(t.p,{children:["The slightly more interesting line here is that declaration of ",(0,r.jsx)(t.code,{children:"vm"}),". This module\r\nis eventually going to have a slew of functions and it would be a chore to pass\r\naround a pointer to the VM to all of them. Instead, we declare a single global\r\nVM object. We need only one anyway, and this keeps the code in the book a little\r\nlighter on the page."]}),"\n",(0,r.jsxs)(t.aside,{name:"one",children:["\n",(0,r.jsxs)(t.p,{children:["The choice to have a static VM instance is a concession for the book, but not\r\nnecessarily a sound engineering choice for a real language implementation. If\r\nyou're building a VM that's designed to be embedded in other host applications,\r\nit gives the host more flexibility if you ",(0,r.jsx)(t.em,{children:"do"})," explicitly take a VM pointer\r\nand pass it around."]}),"\n",(0,r.jsx)(t.p,{children:"That way, the host app can control when and where memory for the VM is\r\nallocated, run multiple VMs in parallel, etc."}),"\n",(0,r.jsxs)(t.p,{children:["What I'm doing here is a global variable, and ",(0,r.jsx)(t.a,{href:"http://gameprogrammingpatterns.com/singleton.html",children:"everything bad you've heard about\r\nglobal variables"})," is still true when programming in the large. But when\r\nkeeping things small for a book..."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Before we start pumping fun code into our VM, let's go ahead and wire it up to\r\nthe interpreter's main entrypoint."}),"\n",(0,r.jsx)(t.p,{children:"^code main-init-vm (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"We spin up the VM when the interpreter first starts. Then when we're about to\r\nexit, we wind it down."}),"\n",(0,r.jsx)(t.p,{children:"^code main-free-vm (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"One last ceremonial obligation:"}),"\n",(0,r.jsx)(t.p,{children:"^code main-include-vm (1 before, 2 after)"}),"\n",(0,r.jsxs)(t.p,{children:["Now when you run clox, it starts up the VM before it creates that hand-authored\r\nchunk from the ",(0,r.jsx)(t.a,{href:"chunks-of-bytecode.html#disassembling-chunks",children:"last chapter"}),". The VM is ready and waiting, so let's teach it\r\nto do something."]}),"\n",(0,r.jsx)(t.h3,{id:"executing-instructions",children:"Executing instructions"}),"\n",(0,r.jsx)(t.p,{children:"The VM springs into action when we command it to interpret a chunk of bytecode."}),"\n",(0,r.jsx)(t.p,{children:"^code main-interpret (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"This function is the main entrypoint into the VM. It's declared like so:"}),"\n",(0,r.jsx)(t.p,{children:"^code interpret-h (1 before, 2 after)"}),"\n",(0,r.jsx)(t.p,{children:"The VM runs the chunk and then responds with a value from this enum:"}),"\n",(0,r.jsx)(t.p,{children:"^code interpret-result (2 before, 2 after)"}),"\n",(0,r.jsx)(t.p,{children:"We aren't using the result yet, but when we have a compiler that reports static\r\nerrors and a VM that detects runtime errors, the interpreter will use this to\r\nknow how to set the exit code of the process."}),"\n",(0,r.jsx)(t.p,{children:"We're inching towards some actual implementation."}),"\n",(0,r.jsx)(t.p,{children:"^code interpret"}),"\n",(0,r.jsxs)(t.p,{children:["First, we store the chunk being executed in the VM. Then we call ",(0,r.jsx)(t.code,{children:"run()"}),", an\r\ninternal helper function that actually runs the bytecode instructions. Between\r\nthose two parts is an intriguing line. What is this ",(0,r.jsx)(t.code,{children:"ip"})," business?"]}),"\n",(0,r.jsxs)(t.p,{children:["As the VM works its way through the bytecode, it keeps track of where it is --\r\nthe location of the instruction currently being executed. We don't use a ",(0,r.jsx)(t.span,{name:"local",children:"local"})," variable inside ",(0,r.jsx)(t.code,{children:"run()"})," for this because eventually\r\nother functions will need to access it. Instead, we store it as a field in VM."]}),"\n",(0,r.jsxs)(t.aside,{name:"local",children:["\n",(0,r.jsxs)(t.p,{children:["If we were trying to squeeze every ounce of speed out of our bytecode\r\ninterpreter, we would store ",(0,r.jsx)(t.code,{children:"ip"})," in a local variable. It gets modified so often\r\nduring execution that we want the C compiler to keep it in a register."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"^code ip (2 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"Its type is a byte pointer. We use an actual real C pointer pointing right into\r\nthe middle of the bytecode array instead of something like an integer index\r\nbecause it's faster to dereference a pointer than look up an element in an array\r\nby index."}),"\n",(0,r.jsxs)(t.p,{children:['The name "IP" is traditional, and -- unlike many traditional names in CS --\r\nactually makes sense: it\'s an ',(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Program_counter",children:"instruction pointer"})}),". Almost every\r\ninstruction set in the ",(0,r.jsx)(t.span,{name:"ip",children:"world"}),", real and virtual, has a\r\nregister or variable like this."]}),"\n",(0,r.jsxs)(t.aside,{name:"ip",children:["\n",(0,r.jsxs)(t.p,{children:['x86, x64, and the CLR call it "IP". 68k, PowerPC, ARM, p-code, and the JVM call\r\nit "PC", for ',(0,r.jsx)(t.strong,{children:"program counter"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["We initialize ",(0,r.jsx)(t.code,{children:"ip"})," by pointing it at the first byte of code in the chunk. We\r\nhaven't executed that instruction yet, so ",(0,r.jsx)(t.code,{children:"ip"})," points to the instruction ",(0,r.jsx)(t.em,{children:"about\r\nto be executed"}),". This will be true during the entire time the VM is running: the\r\nIP always points to the next instruction, not the one currently being handled."]}),"\n",(0,r.jsxs)(t.p,{children:["The real fun happens in ",(0,r.jsx)(t.code,{children:"run"}),"()."]}),"\n",(0,r.jsx)(t.p,{children:"^code run"}),"\n",(0,r.jsxs)(t.p,{children:["This is the single most ",(0,r.jsx)(t.span,{name:"important",children:"important"})," function in all\r\nof clox, by far. When the interpreter executes a user's program, it will spend\r\nsomething like 90% of its time inside ",(0,r.jsx)(t.code,{children:"run()"}),". It is the beating heart of the\r\nVM."]}),"\n",(0,r.jsxs)(t.aside,{name:"important",children:["\n",(0,r.jsxs)(t.p,{children:["Or, at least, it ",(0,r.jsx)(t.em,{children:"will"})," be in a few chapters when it has enough content to be\r\nuseful. Right now, it's not exactly a wonder of software wizardry."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Despite that dramatic intro, it's conceptually pretty simple. We have an outer\r\nloop that goes and goes. Each turn through that loop, we read and execute a\r\nsingle bytecode instruction."}),"\n",(0,r.jsxs)(t.p,{children:["To process an instruction, we first figure out what kind of instruction we're\r\ndealing with. The ",(0,r.jsx)(t.code,{children:"READ_BYTE"})," macro reads the byte currently pointed at by ",(0,r.jsx)(t.code,{children:"ip"}),"\r\nand then ",(0,r.jsx)(t.span,{name:"next",children:"advances"})," the instruction pointer. The first\r\nbyte of any instruction is the opcode. Given a numeric opcode, we need to get to\r\nthe right C code that implements that instruction's semantics. This process is\r\ncalled ",(0,r.jsx)(t.strong,{children:"decoding"})," or ",(0,r.jsx)(t.strong,{children:"dispatching"})," the instruction."]}),"\n",(0,r.jsxs)(t.aside,{name:"next",children:["\n",(0,r.jsxs)(t.p,{children:["Note that ",(0,r.jsx)(t.code,{children:"ip"})," advances as soon as we read the opcode, before we've actually\r\nstarted executing the instruction. So, again, ",(0,r.jsx)(t.code,{children:"ip"})," points to the ",(0,r.jsx)(t.em,{children:"next"}),"\r\nbyte of code to be used."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["We do that process for every single instruction, every single time one is\r\nexecuted, so this is the most performance critical part of the entire virtual\r\nmachine. Programming language lore is filled with ",(0,r.jsx)(t.span,{name:"dispatch",children:"clever"})," techniques to do bytecode dispatch efficiently,\r\ngoing all the way back to the early days of computers."]}),"\n",(0,r.jsxs)(t.aside,{name:"dispatch",children:["\n",(0,r.jsx)(t.p,{children:'If you want to learn some of these techniques, look up "direct threaded code",\r\n"jump table", and "computed goto".'}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Alas, the fastest solutions require either non-standard extensions to C, or\r\nhandwritten assembly code. For clox, we'll keep it simple. Just like our\r\ndisassembler, we have a single giant ",(0,r.jsx)(t.code,{children:"switch"})," statement with a case for each\r\nopcode. The body of each case implements that opcode's behavior."]}),"\n",(0,r.jsxs)(t.p,{children:["So far, we handle only a single instruction, ",(0,r.jsx)(t.code,{children:"OP_RETURN"}),", and the only thing it\r\ndoes is exit the loop entirely. Eventually, that instruction will be used to\r\nreturn from the current Lox function, but we don't have functions yet, so we'll\r\nrepurpose it temporarily to end the execution."]}),"\n",(0,r.jsx)(t.p,{children:"Let's go ahead and support our one other instruction."}),"\n",(0,r.jsx)(t.p,{children:"^code op-constant (1 before, 1 after)"}),"\n",(0,r.jsxs)(t.p,{children:["We don't have enough machinery in place yet to do anything useful with a\r\nconstant. For now, we'll just print it out so we interpreter hackers can see\r\nwhat's going on inside our VM. That call to ",(0,r.jsx)(t.code,{children:"printf()"})," necessitates an include."]}),"\n",(0,r.jsx)(t.p,{children:"^code vm-include-stdio (1 after)"}),"\n",(0,r.jsx)(t.p,{children:"We also have a new macro to define."}),"\n",(0,r.jsx)(t.p,{children:"^code read-constant (1 before, 2 after)"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"READ_CONSTANT()"})," reads the next byte from the bytecode, treats the resulting\r\nnumber as an index, and looks up the corresponding Value in the chunk's constant\r\ntable. In later chapters, we'll add a few more instructions with operands that\r\nrefer to constants, so we're setting up this helper macro now."]}),"\n",(0,r.jsxs)(t.p,{children:["Like the previous ",(0,r.jsx)(t.code,{children:"READ_BYTE"})," macro, ",(0,r.jsx)(t.code,{children:"READ_CONSTANT"})," is only used inside\r\n",(0,r.jsx)(t.code,{children:"run()"}),". To make that scoping more explicit, the macro definitions themselves\r\nare confined to that function. We ",(0,r.jsx)(t.span,{name:"macro",children:"define"})," them at the\r\nbeginning and -- because we care -- undefine them at the end."]}),"\n",(0,r.jsx)(t.p,{children:"^code undef-read-constant (1 before, 1 after)"}),"\n",(0,r.jsxs)(t.aside,{name:"macro",children:["\n",(0,r.jsx)(t.p,{children:"Undefining these macros explicitly might seem needlessly fastidious, but C tends\r\nto punish sloppy users, and the C preprocessor doubly so."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"execution-tracing",children:"Execution tracing"}),"\n",(0,r.jsxs)(t.p,{children:["If you run clox now, it executes the chunk we hand-authored in the last chapter\r\nand spits out ",(0,r.jsx)(t.code,{children:"1.2"})," to your terminal. We can see that it's working, but that's\r\nonly because our implementation of ",(0,r.jsx)(t.code,{children:"OP_CONSTANT"})," has temporary code to log the\r\nvalue. Once that instruction is doing what it's supposed to do and plumbing that\r\nconstant along to other operations that want to consume it, the VM will become a\r\nblack box. That makes our lives as VM implementers harder."]}),"\n",(0,r.jsx)(t.p,{children:"To help ourselves out, now is a good time to add some diagnostic logging to the\r\nVM like we did with chunks themselves. In fact, we'll even reuse the same code.\r\nWe don't want this logging enabled all the time -- it's just for us VM hackers,\r\nnot Lox users -- so first we create a flag to hide it behind."}),"\n",(0,r.jsx)(t.p,{children:"^code define-debug-trace (1 before, 2 after)"}),"\n",(0,r.jsx)(t.p,{children:"When this flag is defined, the VM disassembles and prints each instruction right\r\nbefore executing it. Where our previous disassembler walked an entire chunk\r\nonce, statically, this disassembles instructions dynamically, on the fly."}),"\n",(0,r.jsx)(t.p,{children:"^code trace-execution (1 before, 1 after)"}),"\n",(0,r.jsxs)(t.p,{children:["Since ",(0,r.jsx)(t.code,{children:"disassembleInstruction()"})," takes an integer byte ",(0,r.jsx)(t.em,{children:"offset"})," and we store the\r\ncurrent instruction reference as a direct pointer, we first do a little pointer\r\nmath to convert ",(0,r.jsx)(t.code,{children:"ip"})," back to a relative offset from the beginning of the\r\nbytecode. Then we disassemble the instruction that begins at that byte."]}),"\n",(0,r.jsx)(t.p,{children:"As ever, we need to bring in the declaration of the function before we can call\r\nit."}),"\n",(0,r.jsx)(t.p,{children:"^code vm-include-debug (1 before, 1 after)"}),"\n",(0,r.jsxs)(t.p,{children:["I know this code isn't super impressive so far -- it's literally a switch\r\nstatement wrapped in a ",(0,r.jsx)(t.code,{children:"for"})," loop but, believe it or not, this is one of the two\r\nmajor components of our VM. With this, we can imperatively execute instructions.\r\nIts simplicity is a virtue -- the less work it does, the faster it can do it.\r\nContrast this with all of the complexity and overhead we had in jlox with the\r\nVisitor pattern for walking the AST."]}),"\n",(0,r.jsx)(t.h2,{id:"a-value-stack-manipulator",children:"A Value Stack Manipulator"}),"\n",(0,r.jsx)(t.p,{children:"In addition to imperative side effects, Lox has expressions that produce,\r\nmodify, and consume values. Thus, our compiled bytecode needs a way to shuttle\r\nvalues around between the different instructions that need them. For example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"print 3 - 2;\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We obviously need instructions for the constants 3 and 2, the ",(0,r.jsx)(t.code,{children:"print"})," statement,\r\nand the subtraction. But how does the subtraction instruction know that 3 is\r\nthe ",(0,r.jsx)(t.span,{name:"word",children:"minuend"})," and 2 is the subtrahend? How does the print\r\ninstruction know to print the result of that?"]}),"\n",(0,r.jsxs)(t.aside,{name:"word",children:["\n",(0,r.jsx)(t.p,{children:'Yes, I did have to look up "subtrahend" and "minuend" in a dictionary. But\r\naren\'t they delightful words? "Minuend" sounds like a kind of Elizabethan dance\r\nand "subtrahend" might be some sort of underground Paleolithic monument.'}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"To put a finer point on it, look at this thing right here:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"fun echo(n) {\r\n  print n;\r\n  return n;\r\n}\r\n\r\nprint echo(echo(1) + echo(2)) + echo(echo(4) + echo(5));\n"})}),"\n",(0,r.jsxs)(t.p,{children:["I wrapped each subexpression in a call to ",(0,r.jsx)(t.code,{children:"echo()"})," that prints and returns its\r\nargument. That side effect means we can see the exact order of operations."]}),"\n",(0,r.jsxs)(t.p,{children:["Don't worry about the VM for a minute. Think about just the semantics of Lox\r\nitself. The operands to an arithmetic operator obviously need to be evaluated\r\nbefore we can perform the operation itself. (It's pretty hard to add ",(0,r.jsx)(t.code,{children:"a + b"})," if\r\nyou don't know what ",(0,r.jsx)(t.code,{children:"a"})," and ",(0,r.jsx)(t.code,{children:"b"})," are.) Also, when we implemented expressions in\r\njlox, we ",(0,r.jsx)(t.span,{name:"undefined",children:"decided"})," that the left operand must be\r\nevaluated before the right."]}),"\n",(0,r.jsxs)(t.aside,{name:"undefined",children:["\n",(0,r.jsx)(t.p,{children:"We could have left evaluation order unspecified and let each implementation\r\ndecide. That leaves the door open for optimizing compilers to reorder arithmetic\r\nexpressions for efficiency, even in cases where the operands have visible side\r\neffects. C and Scheme leave evaluation order unspecified. Java specifies\r\nleft-to-right evaluation like we do for Lox."}),"\n",(0,r.jsx)(t.p,{children:"I think nailing down stuff like this is generally better for users. When\r\nexpressions are not evaluated in the order users intuit -- possibly in different\r\norders across different implementations! -- it can be a burning hellscape of\r\npain to figure out what's going on."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Here is the syntax tree for the ",(0,r.jsx)(t.code,{children:"print"})," statement:"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/ast.png",alt:"The AST for the example\nstatement, with numbers marking the order that the nodes are evaluated."})}),"\n",(0,r.jsxs)(t.p,{children:["Given left-to-right evaluation, and the way the expressions are nested, any\r\ncorrect Lox implementation ",(0,r.jsx)(t.em,{children:"must"})," print these numbers in this order:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-text",children:"1  // from echo(1)\r\n2  // from echo(2)\r\n3  // from echo(1 + 2)\r\n4  // from echo(4)\r\n5  // from echo(5)\r\n9  // from echo(4 + 5)\r\n12 // from print 3 + 9\n"})}),"\n",(0,r.jsx)(t.p,{children:"Our old jlox interpreter accomplishes this by recursively traversing the AST. It\r\ndoes a postorder traversal. First it recurses down the left operand branch,\r\nthen the right operand, then finally it evaluates the node itself."}),"\n",(0,r.jsx)(t.p,{children:"After evaluating the left operand, jlox needs to store that result somewhere\r\ntemporarily while it's busy traversing down through the right operand tree. We\r\nuse a local variable in Java for that. Our recursive tree-walk interpreter\r\ncreates a unique Java call frame for each node being evaluated, so we could have\r\nas many of these local variables as we needed."}),"\n",(0,r.jsxs)(t.p,{children:["In clox, our ",(0,r.jsx)(t.code,{children:"run()"})," function is not recursive -- the nested expression tree is\r\nflattened out into a linear series of instructions. We don't have the luxury of\r\nusing C local variables, so how and where should we store these temporary\r\nvalues? You can probably ",(0,r.jsx)(t.span,{name:"guess",children:"guess"})," already, but I want to\r\nreally drill into this because it's an aspect of programming that we take for\r\ngranted, but we rarely learn ",(0,r.jsx)(t.em,{children:"why"})," computers are architected this way."]}),"\n",(0,r.jsxs)(t.aside,{name:"guess",children:["\n",(0,r.jsx)(t.p,{children:"Hint: it's in the name of this section, and it's how Java and C manage recursive\r\ncalls to functions."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Let's do a weird exercise. We'll walk through the execution of the above program\r\na step at a time:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/bars.png",alt:"The series of instructions with\nbars showing which numbers need to be preserved across which instructions."})}),"\n",(0,r.jsx)(t.p,{children:"On the left are the steps of code. On the right are the values we're tracking.\r\nEach bar represents a number. It starts when the value is first produced --\r\neither a constant or the result of an addition. The length of the bar tracks\r\nwhen a previously produced value needs to be kept around, and it ends when that\r\nvalue finally gets consumed by an operation."}),"\n",(0,r.jsx)(t.p,{children:"As you step through, you see values appear and then later get eaten. The\r\nlongest-lived ones are the values produced from the left-hand side of an\r\naddition. Those stick around while we work through the right-hand operand\r\nexpression."}),"\n",(0,r.jsx)(t.p,{children:"In the above diagram, I gave each unique number its own visual column. Let's be\r\na little more parsimonious. Once a number is consumed, we allow its column to be\r\nreused for another later value. In other words, we take all of those gaps\r\nup there and fill them in, pushing in numbers from the right:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/bars-stacked.png",alt:"Like the previous\ndiagram, but with number bars pushed to the left, forming a stack."})}),"\n",(0,r.jsxs)(t.p,{children:["There's some interesting stuff going on here. When we shift everything over,\r\neach number still manages to stay in a single column for its entire life. Also,\r\nthere are no gaps left. In other words, whenever a number appears earlier than\r\nanother, then it will live at least as long as that second one. The first number\r\nto appear is the last to be consumed. Hmm... last-in, first-out... why, that's a\r\n",(0,r.jsx)(t.span,{name:"pancakes",children:"stack"}),"!"]}),"\n",(0,r.jsxs)(t.aside,{name:"pancakes",children:["\n",(0,r.jsx)(t.p,{children:"This is also a stack:"}),"\n",(0,r.jsx)(t.img,{src:"image/a-virtual-machine/pancakes.png",alt:"A stack... of pancakes."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"In the second diagram, each time we introduce a number, we push it onto the\r\nstack from the right. When numbers are consumed, they are always popped off from\r\nrightmost to left."}),"\n",(0,r.jsx)(t.p,{children:'Since the temporary values we need to track naturally have stack-like behavior,\r\nour VM will use a stack to manage them. When an instruction "produces" a value,\r\nit pushes it onto the stack. When it needs to consume one or more values, it\r\ngets them by popping them off the stack.'}),"\n",(0,r.jsx)(t.h3,{id:"the-vms-stack",children:"The VM's Stack"}),"\n",(0,r.jsxs)(t.p,{children:["Maybe this doesn't seem like a revelation, but I ",(0,r.jsx)(t.em,{children:"love"})," stack-based VMs. When\r\nyou first see a magic trick, it feels like something actually magical. But then\r\nyou learn how it works -- usually some mechanical gimmick or misdirection -- and\r\nthe sense of wonder evaporates. There are a ",(0,r.jsx)(t.span,{name:"wonder",children:"couple"})," of\r\nideas in computer science where even after I pulled them apart and learned all\r\nthe ins and outs, some of the initial sparkle remained. Stack-based VMs are one\r\nof those."]}),"\n",(0,r.jsxs)(t.aside,{name:"wonder",children:["\n",(0,r.jsxs)(t.p,{children:["Heaps -- ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Heap_(data_structure)",children:"the data structure"}),", not ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Memory_management#HEAP",children:"the memory management thing"}),"\r\n-- are another. And Vaughan Pratt's top-down operator precedence parsing scheme,\r\nwhich we'll learn about ",(0,r.jsx)(t.a,{href:"compiling-expressions.html",children:"in due time"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["As you'll see in this chapter, executing instructions in a stack-based VM is\r\ndead ",(0,r.jsx)(t.span,{name:"cheat",children:"simple"}),". In later chapters, you'll also discover\r\nthat compiling a source language to a stack-based instruction set is a piece of\r\ncake. And yet, this architecture is fast enough to be used by production\r\nlanguage implementations. It almost feels like cheating at the programming\r\nlanguage game."]}),"\n",(0,r.jsxs)(t.aside,{name:"cheat",children:["\n",(0,r.jsxs)(t.p,{children:["To take a bit of the sheen off: stack-based interpreters aren't a silver bullet.\r\nThey're often ",(0,r.jsx)(t.em,{children:"adequate"}),", but modern implementations of the JVM, the CLR, and\r\nJavaScript all use sophisticated ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Just-in-time_compilation",children:"just-in-time compilation"})," pipelines to\r\ngenerate ",(0,r.jsx)(t.em,{children:"much"})," faster native code on the fly."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Alrighty, it's codin' time! Here's the stack:"}),"\n",(0,r.jsx)(t.p,{children:"^code vm-stack (3 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:'We implement the stack semantics ourselves on top of a raw C array. The bottom\r\nof the stack -- the first value pushed and the last to be popped -- is at\r\nelement zero in the array, and later pushed values follow it. If we push the\r\nletters of "crepe" -- my favorite stackable breakfast item -- onto the stack, in\r\norder, the resulting C array looks like this:'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/array.png",alt:"An array containing the\nletters in 'crepe' in order starting at element 0."})}),"\n",(0,r.jsxs)(t.p,{children:["Since the stack grows and shrinks as values are pushed and popped, we need to\r\ntrack where the top of the stack is in the array. As with ",(0,r.jsx)(t.code,{children:"ip"}),", we use a direct\r\npointer instead of an integer index since it's faster to dereference the pointer\r\nthan calculate the offset from the index each time we need it."]}),"\n",(0,r.jsxs)(t.p,{children:["The pointer points at the array element just ",(0,r.jsx)(t.em,{children:"past"})," the element containing the\r\ntop value on the stack. That seems a little odd, but almost every implementation\r\ndoes this. It means we can indicate that the stack is empty by pointing at\r\nelement zero in the array."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/stack-empty.png",alt:"An empty array with\nstackTop pointing at the first element."})}),"\n",(0,r.jsxs)(t.p,{children:["If we pointed to the top element, then for an empty stack we'd need to point at\r\nelement -1. That's ",(0,r.jsx)(t.span,{name:"defined",children:"undefined"})," in C. As we push values\r\nonto the stack..."]}),"\n",(0,r.jsxs)(t.aside,{name:"defined",children:["\n",(0,r.jsxs)(t.p,{children:["What about when the stack is ",(0,r.jsx)(t.em,{children:"full"}),", you ask, Clever Reader? The C standard is\r\none step ahead of you. It ",(0,r.jsx)(t.em,{children:"is"})," allowed and well-specified to have an array\r\npointer that points just past the end of an array."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/stack-c.png",alt:"An array with 'c' at element\nzero."})}),"\n",(0,r.jsxs)(t.p,{children:["...",(0,r.jsx)(t.code,{children:"stackTop"})," always points just past the last item."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/stack-crepe.png",alt:"An array with 'c', 'r',\n'e', 'p', and 'e' in the first five elements."})}),"\n",(0,r.jsxs)(t.p,{children:["I remember it like this: ",(0,r.jsx)(t.code,{children:"stackTop"})," points to where the next value to be pushed\r\nwill go. The maximum number of values we can store on the stack (for now, at\r\nleast) is:"]}),"\n",(0,r.jsx)(t.p,{children:"^code stack-max (1 before, 2 after)"}),"\n",(0,r.jsx)(t.p,{children:"Giving our VM a fixed stack size means it's possible for some sequence of\r\ninstructions to push too many values and run out of stack space -- the classic\r\n\"stack overflow\". We could grow the stack dynamically as needed, but for now\r\nwe'll keep it simple. Since VM uses Value, we need to include its declaration."}),"\n",(0,r.jsx)(t.p,{children:"^code vm-include-value (1 before, 2 after)"}),"\n",(0,r.jsx)(t.p,{children:"Now that VM has some interesting state, we get to initialize it."}),"\n",(0,r.jsx)(t.p,{children:"^code call-reset-stack (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"That uses this helper function:"}),"\n",(0,r.jsx)(t.p,{children:"^code reset-stack"}),"\n",(0,r.jsxs)(t.p,{children:["Since the stack array is declared directly inline in the VM struct, we don't\r\nneed to allocate it. We don't even need to clear the unused cells in the\r\narray -- we simply won't access them until after values have been stored in\r\nthem. The only initialization we need is to set ",(0,r.jsx)(t.code,{children:"stackTop"})," to point to the\r\nbeginning of the array to indicate that the stack is empty."]}),"\n",(0,r.jsx)(t.p,{children:"The stack protocol supports two operations:"}),"\n",(0,r.jsx)(t.p,{children:"^code push-pop (1 before, 2 after)"}),"\n",(0,r.jsx)(t.p,{children:"You can push a new value onto the top of the stack, and you can pop the most\r\nrecently pushed value back off. Here's the first function:"}),"\n",(0,r.jsx)(t.p,{children:"^code push"}),"\n",(0,r.jsxs)(t.p,{children:["If you're rusty on your C pointer syntax and operations, this is a good warm-up.\r\nThe first line stores ",(0,r.jsx)(t.code,{children:"value"})," in the array element at the top of the stack.\r\nRemember, ",(0,r.jsx)(t.code,{children:"stackTop"})," points just ",(0,r.jsx)(t.em,{children:"past"})," the last used element, at the next\r\navailable one. This stores the value in that slot. Then we increment the pointer\r\nitself to point to the next unused slot in the array now that the previous slot\r\nis occupied."]}),"\n",(0,r.jsx)(t.p,{children:"Popping is the mirror image."}),"\n",(0,r.jsx)(t.p,{children:"^code pop"}),"\n",(0,r.jsxs)(t.p,{children:["First, we move the stack pointer ",(0,r.jsx)(t.em,{children:"back"}),' to get to the most recent used slot in\r\nthe array. Then we look up the value at that index and return it. We don\'t need\r\nto explicitly "remove" it from the array -- moving ',(0,r.jsx)(t.code,{children:"stackTop"})," down is enough to\r\nmark that slot as no longer in use."]}),"\n",(0,r.jsx)(t.h3,{id:"stack-tracing",children:"Stack tracing"}),"\n",(0,r.jsxs)(t.p,{children:["We have a working stack, but it's hard to ",(0,r.jsx)(t.em,{children:"see"})," that it's working. When we start\r\nimplementing more complex instructions and compiling and running larger pieces\r\nof code, we'll end up with a lot of values crammed into that array. It would\r\nmake our lives as VM hackers easier if we had some visibility into the stack."]}),"\n",(0,r.jsx)(t.p,{children:"To that end, whenever we're tracing execution, we'll also show the current\r\ncontents of the stack before we interpret each instruction."}),"\n",(0,r.jsx)(t.p,{children:"^code trace-stack (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"We loop, printing each value in the array, starting at the first (bottom of the\r\nstack) and ending when we reach the top. This lets us observe the effect of each\r\ninstruction on the stack. The output is pretty verbose, but it's useful when\r\nwe're surgically extracting a nasty bug from the bowels of the interpreter."}),"\n",(0,r.jsx)(t.p,{children:"Stack in hand, let's revisit our two instructions. First up:"}),"\n",(0,r.jsx)(t.p,{children:"^code push-constant (2 before, 1 after)"}),"\n",(0,r.jsxs)(t.p,{children:["In the last chapter, I was hand-wavey about how the ",(0,r.jsx)(t.code,{children:"OP_CONSTANT"}),' instruction\r\n"loads" a constant. Now that we have a stack you know what it means to actually\r\nproduce a value: it gets pushed onto the stack.']}),"\n",(0,r.jsx)(t.p,{children:"^code print-return (1 before, 1 after)"}),"\n",(0,r.jsxs)(t.p,{children:["Then we make ",(0,r.jsx)(t.code,{children:"OP_RETURN"})," pop the stack and print the top value before exiting.\r\nWhen we add support for real functions to clox, we'll change this code. But, for\r\nnow, it gives us a way to get the VM executing simple instruction sequences and\r\ndisplaying the result."]}),"\n",(0,r.jsx)(t.h2,{id:"an-arithmetic-calculator",children:"An Arithmetic Calculator"}),"\n",(0,r.jsx)(t.p,{children:"The heart and soul of our VM are in place now. The bytecode loop dispatches and\r\nexecutes instructions. The stack grows and shrinks as values flow through it.\r\nThe two halves work, but it's hard to get a feel for how cleverly they interact\r\nwith only the two rudimentary instructions we have so far. So let's teach our\r\ninterpreter to do arithmetic."}),"\n",(0,r.jsx)(t.p,{children:"We'll start with the simplest arithmetic operation, unary negation."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"var a = 1.2;\r\nprint -a; // -1.2.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The prefix ",(0,r.jsx)(t.code,{children:"-"})," operator takes one operand, the value to negate. It produces a\r\nsingle result. We aren't fussing with a parser yet, but we can add the\r\nbytecode instruction that the above syntax will compile to."]}),"\n",(0,r.jsx)(t.p,{children:"^code negate-op (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"We execute it like so:"}),"\n",(0,r.jsx)(t.p,{children:"^code op-negate (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"The instruction needs a value to operate on, which it gets by popping from the\r\nstack. It negates that, then pushes the result back on for later instructions to\r\nuse. Doesn't get much easier than that. We can disassemble it too."}),"\n",(0,r.jsx)(t.p,{children:"^code disassemble-negate (2 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"And we can try it out in our test chunk."}),"\n",(0,r.jsx)(t.p,{children:"^code main-negate (1 before, 2 after)"}),"\n",(0,r.jsx)(t.p,{children:"After loading the constant, but before returning, we execute the negate\r\ninstruction. That replaces the constant on the stack with its negation. Then the\r\nreturn instruction prints that out:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-text",children:"-1.2\n"})}),"\n",(0,r.jsx)(t.p,{children:"Magical!"}),"\n",(0,r.jsx)(t.h3,{id:"binary-operators",children:"Binary operators"}),"\n",(0,r.jsxs)(t.p,{children:["OK, unary operators aren't ",(0,r.jsx)(t.em,{children:"that"})," impressive. We still only ever have a single\r\nvalue on the stack. To really see some depth, we need binary operators. Lox has\r\nfour binary ",(0,r.jsx)(t.span,{name:"ops",children:"arithmetic"})," operators: addition, subtraction,\r\nmultiplication, and division. We'll go ahead and implement them all at the same\r\ntime."]}),"\n",(0,r.jsxs)(t.aside,{name:"ops",children:["\n",(0,r.jsx)(t.p,{children:"Lox has some other binary operators -- comparison and equality -- but those\r\ndon't produce numbers as a result, so we aren't ready for them yet."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"^code binary-ops (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"Back in the bytecode loop, they are executed like this:"}),"\n",(0,r.jsx)(t.p,{children:"^code op-binary (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"The only difference between these four instructions is which underlying C\r\noperator they ultimately use to combine the two operands. Surrounding that core\r\narithmetic expression is some boilerplate code to pull values off the stack and\r\npush the result. When we later add dynamic typing, that boilerplate will grow.\r\nTo avoid repeating that code four times, I wrapped it up in a macro."}),"\n",(0,r.jsx)(t.p,{children:"^code binary-op (1 before, 2 after)"}),"\n",(0,r.jsxs)(t.p,{children:["I admit this is a fairly ",(0,r.jsx)(t.span,{name:"operator",children:"adventurous"})," use of the C\r\npreprocessor. I hesitated to do this, but you'll be glad in later chapters when\r\nwe need to add the type checking for each operand and stuff. It would be a chore\r\nto walk you through the same code four times."]}),"\n",(0,r.jsxs)(t.aside,{name:"operator",children:["\n",(0,r.jsxs)(t.p,{children:["Did you even know you can pass an ",(0,r.jsx)(t.em,{children:"operator"})," as an argument to a macro? Now you\r\ndo. The preprocessor doesn't care that operators aren't first class in C. As far\r\nas it's concerned, it's all just text tokens."]}),"\n",(0,r.jsxs)(t.p,{children:["I know, you can just ",(0,r.jsx)(t.em,{children:"feel"})," the temptation to abuse this, can't you?"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["If you aren't familiar with the trick already, that outer ",(0,r.jsx)(t.code,{children:"do while"})," loop\r\nprobably looks really weird. This macro needs to expand to a series of\r\nstatements. To be careful macro authors, we want to ensure those statements all\r\nend up in the same scope when the macro is expanded. Imagine if you defined:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c",children:"#define WAKE_UP() makeCoffee(); drinkCoffee();\n"})}),"\n",(0,r.jsx)(t.p,{children:"And then used it like:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c",children:"if (morning) WAKE_UP();\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The intent is to execute both statements of the macro body only if ",(0,r.jsx)(t.code,{children:"morning"})," is\r\ntrue. But it expands to:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c",children:"if (morning) makeCoffee(); drinkCoffee();;\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Oops. The ",(0,r.jsx)(t.code,{children:"if"})," attaches only to the ",(0,r.jsx)(t.em,{children:"first"})," statement. You might think you could\r\nfix this using a block."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c",children:"#define WAKE_UP() { makeCoffee(); drinkCoffee(); }\n"})}),"\n",(0,r.jsx)(t.p,{children:"That's better, but you still risk:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c",children:"if (morning)\r\n  WAKE_UP();\r\nelse\r\n  sleepIn();\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now you get a compile error on the ",(0,r.jsx)(t.code,{children:"else"})," because of that trailing ",(0,r.jsx)(t.code,{children:";"})," after the\r\nmacro's block. Using a ",(0,r.jsx)(t.code,{children:"do while"})," loop in the macro looks funny, but it gives\r\nyou a way to contain multiple statements inside a block that ",(0,r.jsx)(t.em,{children:"also"})," permits a\r\nsemicolon at the end."]}),"\n",(0,r.jsx)(t.p,{children:"Where were we? Right, so what the body of that macro does is straightforward. A\r\nbinary operator takes two operands, so it pops twice. It performs the operation\r\non those two values and then pushes the result."}),"\n",(0,r.jsxs)(t.p,{children:["Pay close attention to the ",(0,r.jsx)(t.em,{children:"order"})," of the two pops. Note that we assign the\r\nfirst popped operand to ",(0,r.jsx)(t.code,{children:"b"}),", not ",(0,r.jsx)(t.code,{children:"a"}),". It looks backwards. When the operands\r\nthemselves are calculated, the left is evaluated first, then the right. That\r\nmeans the left operand gets pushed before the right operand. So the right\r\noperand will be on top of the stack. Thus, the first value we pop is ",(0,r.jsx)(t.code,{children:"b"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["For example, if we compile ",(0,r.jsx)(t.code,{children:"3 - 1"}),", the data flow between the instructions looks\r\nlike so:"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/reverse.png",alt:"A sequence of instructions\nwith the stack for each showing how pushing and then popping values reverses\ntheir order."})}),"\n",(0,r.jsxs)(t.p,{children:["As we did with the other macros inside ",(0,r.jsx)(t.code,{children:"run()"}),", we clean up after ourselves at\r\nthe end of the function."]}),"\n",(0,r.jsx)(t.p,{children:"^code undef-binary-op (1 before, 1 after)"}),"\n",(0,r.jsx)(t.p,{children:"Last is disassembler support."}),"\n",(0,r.jsx)(t.p,{children:"^code disassemble-binary (2 before, 1 after)"}),"\n",(0,r.jsxs)(t.p,{children:["The arithmetic instruction formats are simple, like ",(0,r.jsx)(t.code,{children:"OP_RETURN"}),". Even though the\r\narithmetic ",(0,r.jsx)(t.em,{children:"operators"})," take operands -- which are found on the stack -- the\r\narithmetic ",(0,r.jsx)(t.em,{children:"bytecode instructions"})," do not."]}),"\n",(0,r.jsx)(t.p,{children:"Let's put some of our new instructions through their paces by evaluating a\r\nlarger expression:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"image/a-virtual-machine/chunk.png",alt:"The expression being\nevaluated: -((1.2 + 3.4) / 5.6)"})}),"\n",(0,r.jsx)(t.p,{children:"Building on our existing example chunk, here's the additional instructions we\r\nneed to hand-compile that AST to bytecode."}),"\n",(0,r.jsx)(t.p,{children:"^code main-chunk (3 before, 3 after)"}),"\n",(0,r.jsxs)(t.p,{children:["The addition goes first. The instruction for the left constant, 1.2, is already\r\nthere, so we add another for 3.4. Then we add those two using ",(0,r.jsx)(t.code,{children:"OP_ADD"}),", leaving\r\nit on the stack. That covers the left side of the division. Next we push the\r\n5.6, and divide the result of the addition by it. Finally, we negate the result\r\nof that."]}),"\n",(0,r.jsxs)(t.p,{children:["Note how the output of the ",(0,r.jsx)(t.code,{children:"OP_ADD"})," implicitly flows into being an operand of\r\n",(0,r.jsx)(t.code,{children:"OP_DIVIDE"})," without either instruction being directly coupled to each other.\r\nThat's the magic of the stack. It lets us freely compose instructions without\r\nthem needing any complexity or awareness of the data flow. The stack acts like a\r\nshared workspace that they all read from and write to."]}),"\n",(0,r.jsx)(t.p,{children:"In this tiny example chunk, the stack still only gets two values tall, but when\r\nwe start compiling Lox source to bytecode, we'll have chunks that use much more\r\nof the stack. In the meantime, try playing around with this hand-authored chunk\r\nto calculate different nested arithmetic expressions and see how values flow\r\nthrough the instructions and stack."}),"\n",(0,r.jsx)(t.p,{children:"You may as well get it out of your system now. This is the last chunk we'll\r\nbuild by hand. When we next revisit bytecode, we will be writing a compiler to\r\ngenerate it for us."}),"\n",(0,r.jsxs)(t.div,{className:"challenges",children:["\n",(0,r.jsx)(t.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"What bytecode instruction sequences would you generate for the following\r\nexpressions:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"1 * 2 + 3\r\n1 + 2 * 3\r\n3 - 2 - 1\r\n1 + 2 * 3 - 4 / -5\n"})}),"\n",(0,r.jsxs)(t.p,{children:["(Remember that Lox does not have a syntax for negative number literals, so\r\nthe ",(0,r.jsx)(t.code,{children:"-5"})," is negating the number 5.)"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["If we really wanted a minimal instruction set, we could eliminate either\r\n",(0,r.jsx)(t.code,{children:"OP_NEGATE"})," or ",(0,r.jsx)(t.code,{children:"OP_SUBTRACT"}),". Show the bytecode instruction sequence you\r\nwould generate for:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"4 - 3 * -2\n"})}),"\n",(0,r.jsxs)(t.p,{children:["First, without using ",(0,r.jsx)(t.code,{children:"OP_NEGATE"}),". Then, without using ",(0,r.jsx)(t.code,{children:"OP_SUBTRACT"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Given the above, do you think it makes sense to have both instructions? Why\r\nor why not? Are there any other redundant instructions you would consider\r\nincluding?"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Our VM's stack has a fixed size, and we don't check if pushing a value\r\noverflows it. This means the wrong series of instructions could cause our\r\ninterpreter to crash or go into undefined behavior. Avoid that by\r\ndynamically growing the stack as needed."}),"\n",(0,r.jsx)(t.p,{children:"What are the costs and benefits of doing so?"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["To interpret ",(0,r.jsx)(t.code,{children:"OP_NEGATE"}),", we pop the operand, negate the value, and then\r\npush the result. That's a simple implementation, but it increments and\r\ndecrements ",(0,r.jsx)(t.code,{children:"stackTop"})," unnecessarily, since the stack ends up the same height\r\nin the end. It might be faster to simply negate the value in place on the\r\nstack and leave ",(0,r.jsx)(t.code,{children:"stackTop"})," alone. Try that and see if you can measure a\r\nperformance difference."]}),"\n",(0,r.jsx)(t.p,{children:"Are there other instructions where you can do a similar optimization?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.div,{className:"design-note",children:["\n",(0,r.jsx)(t.h2,{id:"design-note-register-based-bytecode",children:"Design Note: Register-Based Bytecode"}),"\n",(0,r.jsxs)(t.p,{children:["For the remainder of this book, we'll meticulously implement an interpreter\r\naround a stack-based bytecode instruction set. There's another family of\r\nbytecode architectures out there -- ",(0,r.jsx)(t.em,{children:"register-based"}),". Despite the name, these\r\nbytecode instructions aren't quite as difficult to work with as the registers in\r\nan actual chip like ",(0,r.jsx)(t.span,{name:"x64",children:"x64"}),". With real hardware registers,\r\nyou usually have only a handful for the entire program, so you spend a lot of\r\neffort ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Register_allocation",children:"trying to use them efficiently and shuttling stuff in and out of\r\nthem"}),"."]}),"\n",(0,r.jsxs)(t.aside,{name:"x64",children:["\n",(0,r.jsxs)(t.p,{children:["Register-based bytecode is a little closer to the ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Register_window",children:(0,r.jsx)(t.em,{children:"register windows"})}),"\r\nsupported by SPARC chips."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"In a register-based VM, you still have a stack. Temporary values still get\r\npushed onto it and popped when no longer needed. The main difference is that\r\ninstructions can read their inputs from anywhere in the stack and can store\r\ntheir outputs into specific stack slots."}),"\n",(0,r.jsx)(t.p,{children:"Take this little Lox script:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"var a = 1;\r\nvar b = 2;\r\nvar c = a + b;\n"})}),"\n",(0,r.jsx)(t.p,{children:"In our stack-based VM, the last statement will get compiled to something like:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"load <a>  // Read local variable a and push onto stack.\r\nload <b>  // Read local variable b and push onto stack.\r\nadd       // Pop two values, add, push result.\r\nstore <c> // Pop value and store in local variable c.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["(Don't worry if you don't fully understand the load and store instructions yet.\r\nWe'll go over them in much greater detail ",(0,r.jsx)(t.a,{href:"global-variables.html",children:"when we implement\r\nvariables"}),".) We have four separate instructions. That means four\r\ntimes through the bytecode interpret loop, four instructions to decode and\r\ndispatch. It's at least seven bytes of code -- four for the opcodes and another\r\nthree for the operands identifying which locals to load and store. Three pushes\r\nand three pops. A lot of work!"]}),"\n",(0,r.jsx)(t.p,{children:"In a register-based instruction set, instructions can read from and store\r\ndirectly into local variables. The bytecode for the last statement above looks\r\nlike:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lox",children:"add <a> <b> <c> // Read values from a and b, add, store in c.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The add instruction is bigger -- it has three instruction operands that define\r\nwhere in the stack it reads its inputs from and writes the result to. But since\r\nlocal variables live on the stack, it can read directly from ",(0,r.jsx)(t.code,{children:"a"})," and ",(0,r.jsx)(t.code,{children:"b"})," and\r\nthen store the result right into ",(0,r.jsx)(t.code,{children:"c"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"There's only a single instruction to decode and dispatch, and the whole thing\r\nfits in four bytes. Decoding is more complex because of the additional operands,\r\nbut it's still a net win. There's no pushing and popping or other stack\r\nmanipulation."}),"\n",(0,r.jsxs)(t.p,{children:["The main implementation of Lua used to be stack-based. For ",(0,r.jsx)(t.span,{name:"lua",children:"Lua\r\n5.0"}),", the implementers switched to a register instruction set and noted a\r\nspeed improvement. The amount of improvement, naturally, depends heavily on the\r\ndetails of the language semantics, specific instruction set, and compiler\r\nsophistication, but that should get your attention."]}),"\n",(0,r.jsxs)(t.aside,{name:"lua",children:["\n",(0,r.jsxs)(t.p,{children:["The Lua dev team -- Roberto Ierusalimschy, Waldemar Celes, and Luiz Henrique de\r\nFigueiredo -- wrote a ",(0,r.jsx)(t.em,{children:"fantastic"}),' paper on this, one of my all time favorite\r\ncomputer science papers, "',(0,r.jsx)(t.a,{href:"https://www.lua.org/doc/jucs05.pdf",children:"The Implementation of Lua 5.0"}),'" (PDF).']}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"That raises the obvious question of why I'm going to spend the rest of the book\r\ndoing a stack-based bytecode. Register VMs are neat, but they are quite a bit\r\nharder to write a compiler for. For what is likely to be your very first\r\ncompiler, I wanted to stick with an instruction set that's easy to generate and\r\neasy to execute. Stack-based bytecode is marvelously simple."}),"\n",(0,r.jsxs)(t.p,{children:["It's also ",(0,r.jsx)(t.em,{children:"much"})," better known in the literature and the community. Even though\r\nyou may eventually move to something more advanced, it's a good common ground to\r\nshare with the rest of your language hacker peers."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(6540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);