"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[3121],{2197:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var s=t(4848),r=t(8453);const a={},i=void 0,o={id:"Craftinginterpreters/not-translated-yet/classes",title:"classes",description:"One has no right to love or hate anything if one has not acquired a thorough",source:"@site/docs/Craftinginterpreters/not-translated-yet/classes.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/classes",permalink:"/docs/Craftinginterpreters/not-translated-yet/classes",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/classes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"classes-and-instances",permalink:"/docs/Craftinginterpreters/not-translated-yet/classes-and-instances"},next:{title:"closures",permalink:"/docs/Craftinginterpreters/not-translated-yet/closures"}},l={},h=[{value:"OOP and Classes",id:"oop-and-classes",level:2},{value:"Class Declarations",id:"class-declarations",level:2},{value:"Creating Instances",id:"creating-instances",level:2},{value:"Properties on Instances",id:"properties-on-instances",level:2},{value:"Get expressions",id:"get-expressions",level:3},{value:"Set expressions",id:"set-expressions",level:3},{value:"Methods on Classes",id:"methods-on-classes",level:2},{value:"This",id:"this",level:2},{value:"Invalid uses of this",id:"invalid-uses-of-this",level:3},{value:"Constructors and Initializers",id:"constructors-and-initializers",level:2},{value:"Invoking init() directly",id:"invoking-init-directly",level:3},{value:"Returning from init()",id:"returning-from-init",level:3},{value:"Challenges",id:"challenges",level:2},{value:"Design Note: Prototypes and Power",id:"design-note-prototypes-and-power",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"One has no right to love or hate anything if one has not acquired a thorough\r\nknowledge of its nature. Great love springs from great knowledge of the\r\nbeloved object, and if you know it but little you will be able to love it only\r\na little or not at all."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.cite,{children:"Leonardo da Vinci"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We're eleven chapters in, and the interpreter sitting on your machine is nearly\r\na complete scripting language. It could use a couple of built-in data structures\r\nlike lists and maps, and it certainly needs a core library for file I/O, user\r\ninput, etc. But the language itself is sufficient. We've got a little procedural\r\nlanguage in the same vein as BASIC, Tcl, Scheme (minus macros), and early\r\nversions of Python and Lua."}),"\n",(0,s.jsxs)(n.p,{children:["If this were the '80s, we'd stop here. But today, many popular languages support\r\n\"object-oriented programming\". Adding that to Lox will give users a familiar set\r\nof tools for writing larger programs. Even if you personally don't ",(0,s.jsx)(n.span,{name:"hate",children:"like"})," OOP, this chapter and ",(0,s.jsx)(n.a,{href:"inheritance.html",children:"the next"})," will help\r\nyou understand how others design and build object systems."]}),"\n",(0,s.jsxs)(n.aside,{name:"hate",children:["\n",(0,s.jsxs)(n.p,{children:["If you ",(0,s.jsx)(n.em,{children:"really"})," hate classes, though, you can skip these two chapters. They are\r\nfairly isolated from the rest of the book. Personally, I find it's good to learn\r\nmore about the things I dislike. Things look simple at a distance, but as I get\r\ncloser, details emerge and I gain a more nuanced perspective."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"oop-and-classes",children:"OOP and Classes"}),"\n",(0,s.jsxs)(n.p,{children:["There are three broad paths to object-oriented programming: classes,\r\n",(0,s.jsx)(n.a,{href:"http://gameprogrammingpatterns.com/prototype.html",children:"prototypes"}),", and ",(0,s.jsx)(n.span,{name:"multimethods",children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Multiple_dispatch",children:"multimethods"})}),". Classes\r\ncame first and are the most popular style. With the rise of JavaScript (and to a\r\nlesser extent ",(0,s.jsx)(n.a,{href:"https://www.lua.org/pil/13.4.1.html",children:"Lua"}),"), prototypes are more widely known than they used to be.\r\nI'll talk more about those ",(0,s.jsx)(n.a,{href:"#design-note",children:"later"}),". For Lox, we're taking the, ahem, classic\r\napproach."]}),"\n",(0,s.jsxs)(n.aside,{name:"multimethods",children:["\n",(0,s.jsxs)(n.p,{children:["Multimethods are the approach you're least likely to be familiar with. I'd love\r\nto talk more about them -- I designed ",(0,s.jsx)(n.a,{href:"http://magpie-lang.org/",children:"a hobby language"})," around them\r\nonce and they are ",(0,s.jsx)(n.em,{children:"super rad"})," -- but there are only so many pages I can fit in.\r\nIf you'd like to learn more, take a look at ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Common_Lisp_Object_System",children:"CLOS"})," (the object system in\r\nCommon Lisp), ",(0,s.jsx)(n.a,{href:"https://opendylan.org/",children:"Dylan"}),", ",(0,s.jsx)(n.a,{href:"https://julialang.org/",children:"Julia"}),", or ",(0,s.jsx)(n.a,{href:"https://docs.raku.org/language/functions#Multi-dispatch",children:"Raku"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Since you've written about a thousand lines of Java code with me already, I'm\r\nassuming you don't need a detailed introduction to object orientation. The main\r\ngoal is to bundle data with the code that acts on it. Users do that by declaring\r\na ",(0,s.jsx)(n.em,{children:"class"})," that:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.span,{name:"circle"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Exposes a ",(0,s.jsx)(n.em,{children:"constructor"})," to create and initialize new ",(0,s.jsx)(n.em,{children:"instances"})," of the\r\nclass"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Provides a way to store and access ",(0,s.jsx)(n.em,{children:"fields"})," on instances"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Defines a set of ",(0,s.jsx)(n.em,{children:"methods"})," shared by all instances of the class that\r\noperate on each instances' state."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["That's about as minimal as it gets. Most object-oriented languages, all the way\r\nback to Simula, also do inheritance to reuse behavior across classes. We'll add\r\nthat in the ",(0,s.jsx)(n.a,{href:"inheritance.html",children:"next chapter"}),". Even kicking that out, we still have a\r\nlot to get through. This is a big chapter and everything doesn't quite come\r\ntogether until we have all of the above pieces, so gather your stamina."]}),"\n",(0,s.jsxs)(n.aside,{name:"circle",children:["\n",(0,s.jsx)(n.img,{src:"image/classes/circle.png",alt:"The relationships between classes, methods, instances, constructors, and fields."}),"\n",(0,s.jsxs)(n.p,{children:["It's like the circle of life, ",(0,s.jsx)(n.em,{children:"sans"})," Sir Elton John."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"class-declarations",children:"Class Declarations"}),"\n",(0,s.jsxs)(n.p,{children:["Like we do, we're gonna start with syntax. A ",(0,s.jsx)(n.code,{children:"class"})," statement introduces a new\r\nname, so it lives in the ",(0,s.jsx)(n.code,{children:"declaration"})," grammar rule."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'declaration    \u2192 classDecl\r\n               | funDecl\r\n               | varDecl\r\n               | statement ;\r\n\r\nclassDecl      \u2192 "class" IDENTIFIER "{" function* "}" ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The new ",(0,s.jsx)(n.code,{children:"classDecl"})," rule relies on the ",(0,s.jsx)(n.code,{children:"function"})," rule we defined\r\n",(0,s.jsx)(n.a,{href:"functions.html#function-declarations",children:"earlier"}),". To refresh your memory:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'function       \u2192 IDENTIFIER "(" parameters? ")" block ;\r\nparameters     \u2192 IDENTIFIER ( "," IDENTIFIER )* ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In plain English, a class declaration is the ",(0,s.jsx)(n.code,{children:"class"})," keyword, followed by the\r\nclass's name, then a curly-braced body. Inside that body is a list of method\r\ndeclarations. Unlike function declarations, methods don't have a leading ",(0,s.jsx)(n.span,{name:"fun",children:(0,s.jsx)(n.code,{children:"fun"})})," keyword. Each method is a name, parameter list, and\r\nbody. Here's an example:"]}),"\n",(0,s.jsxs)(n.aside,{name:"fun",children:["\n",(0,s.jsx)(n.p,{children:"Not that I'm trying to say methods aren't fun or anything."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Breakfast {\r\n  cook() {\r\n    print "Eggs a-fryin\'!";\r\n  }\r\n\r\n  serve(who) {\r\n    print "Enjoy your breakfast, " + who + ".";\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Like most dynamically typed languages, fields are not explicitly listed in the\r\nclass declaration. Instances are loose bags of data and you can freely add\r\nfields to them as you see fit using normal imperative code."}),"\n",(0,s.jsxs)(n.p,{children:["Over in our AST generator, the ",(0,s.jsx)(n.code,{children:"classDecl"})," grammar rule gets its own statement\r\n",(0,s.jsx)(n.span,{name:"class-ast",children:"node"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"^code class-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"class-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#class-statement",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It stores the class's name and the methods inside its body. Methods are\r\nrepresented by the existing Stmt.Function class that we use for function\r\ndeclaration AST nodes. That gives us all the bits of state that we need for a\r\nmethod: name, parameter list, and body."}),"\n",(0,s.jsxs)(n.p,{children:["A class can appear anywhere a named declaration is allowed, triggered by the\r\nleading ",(0,s.jsx)(n.code,{children:"class"})," keyword."]}),"\n",(0,s.jsx)(n.p,{children:"^code match-class (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"That calls out to:"}),"\n",(0,s.jsx)(n.p,{children:"^code parse-class-declaration"}),"\n",(0,s.jsxs)(n.p,{children:["There's more meat to this than most of the other parsing methods, but it roughly\r\nfollows the grammar. We've already consumed the ",(0,s.jsx)(n.code,{children:"class"})," keyword, so we look for\r\nthe expected class name next, followed by the opening curly brace. Once inside\r\nthe body, we keep parsing method declarations until we hit the closing brace.\r\nEach method declaration is parsed by a call to ",(0,s.jsx)(n.code,{children:"function()"}),", which we defined\r\nback in the ",(0,s.jsx)(n.a,{href:"functions.html",children:"chapter where functions were introduced"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Like we do in any open-ended loop in the parser, we also check for hitting the\r\nend of the file. That won't happen in correct code since a class should have a\r\nclosing brace at the end, but it ensures the parser doesn't get stuck in an\r\ninfinite loop if the user has a syntax error and forgets to correctly end the\r\nclass body."}),"\n",(0,s.jsx)(n.p,{children:"We wrap the name and list of methods into a Stmt.Class node and we're done.\r\nPreviously, we would jump straight into the interpreter, but now we need to\r\nplumb the node through the resolver first."}),"\n",(0,s.jsx)(n.p,{children:"^code resolver-visit-class"}),"\n",(0,s.jsx)(n.p,{children:"We aren't going to worry about resolving the methods themselves yet, so for now\r\nall we need to do is declare the class using its name. It's not common to\r\ndeclare a class as a local variable, but Lox permits it, so we need to handle it\r\ncorrectly."}),"\n",(0,s.jsx)(n.p,{children:"Now we interpret the class declaration."}),"\n",(0,s.jsx)(n.p,{children:"^code interpreter-visit-class"}),"\n",(0,s.jsxs)(n.p,{children:["This looks similar to how we execute function declarations. We declare the\r\nclass's name in the current environment. Then we turn the class ",(0,s.jsx)(n.em,{children:"syntax node"}),"\r\ninto a LoxClass, the ",(0,s.jsx)(n.em,{children:"runtime"})," representation of a class. We circle back and\r\nstore the class object in the variable we previously declared. That two-stage\r\nvariable binding process allows references to the class inside its own methods."]}),"\n",(0,s.jsx)(n.p,{children:"We will refine it throughout the chapter, but the first draft of LoxClass looks\r\nlike this:"}),"\n",(0,s.jsx)(n.p,{children:"^code lox-class"}),"\n",(0,s.jsxs)(n.p,{children:["Literally a wrapper around a name. We don't even store the methods yet. Not\r\nsuper useful, but it does have a ",(0,s.jsx)(n.code,{children:"toString()"})," method so we can write a trivial\r\nscript and test that class objects are actually being parsed and executed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class DevonshireCream {\r\n  serveOn() {\r\n    return "Scones";\r\n  }\r\n}\r\n\r\nprint DevonshireCream; // Prints "DevonshireCream".\n'})}),"\n",(0,s.jsx)(n.h2,{id:"creating-instances",children:"Creating Instances"}),"\n",(0,s.jsx)(n.p,{children:"We have classes, but they don't do anything yet. Lox doesn't have \"static\"\r\nmethods that you can call right on the class itself, so without actual\r\ninstances, classes are useless. Thus instances are the next step."}),"\n",(0,s.jsxs)(n.p,{children:["While some syntax and semantics are fairly standard across OOP languages, the\r\nway you create new instances isn't. Ruby, following Smalltalk, creates instances\r\nby calling a method on the class object itself, a ",(0,s.jsx)(n.span,{name:"turtles",children:"recursively"})," graceful approach. Some, like C++ and Java,\r\nhave a ",(0,s.jsx)(n.code,{children:"new"}),' keyword dedicated to birthing a new object. Python has you "call"\r\nthe class itself like a function. (JavaScript, ever weird, sort of does both.)']}),"\n",(0,s.jsxs)(n.aside,{name:"turtles",children:["\n",(0,s.jsxs)(n.p,{children:["In Smalltalk, even ",(0,s.jsx)(n.em,{children:"classes"})," are created by calling methods on an existing\r\nobject, usually the desired superclass. It's sort of a turtles-all-the-way-down\r\nthing. It ultimately bottoms out on a few magical classes like Object and\r\nMetaclass that the runtime conjures into being ",(0,s.jsx)(n.em,{children:"ex nihilo"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["I took a minimal approach with Lox. We already have class objects, and we\r\nalready have function calls, so we'll use call expressions on class objects to\r\ncreate new instances. It's as if a class is a factory function that generates\r\ninstances of itself. This feels elegant to me, and also spares us the need to\r\nintroduce syntax like ",(0,s.jsx)(n.code,{children:"new"}),". Therefore, we can skip past the front end straight\r\ninto the runtime."]}),"\n",(0,s.jsx)(n.p,{children:"Right now, if you try this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Bagel {}\r\nBagel();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You get a runtime error. ",(0,s.jsx)(n.code,{children:"visitCallExpr()"})," checks to see if the called object\r\nimplements ",(0,s.jsx)(n.code,{children:"LoxCallable"})," and reports an error since LoxClass doesn't. Not ",(0,s.jsx)(n.em,{children:"yet"}),",\r\nthat is."]}),"\n",(0,s.jsx)(n.p,{children:"^code lox-class-callable (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"Implementing that interface requires two methods."}),"\n",(0,s.jsx)(n.p,{children:"^code lox-class-call-arity"}),"\n",(0,s.jsxs)(n.p,{children:["The interesting one is ",(0,s.jsx)(n.code,{children:"call()"}),'. When you "call" a class, it instantiates a new\r\nLoxInstance for the called class and returns it. The ',(0,s.jsx)(n.code,{children:"arity()"})," method is how the\r\ninterpreter validates that you passed the right number of arguments to a\r\ncallable. For now, we'll say you can't pass any. When we get to user-defined\r\nconstructors, we'll revisit this."]}),"\n",(0,s.jsx)(n.p,{children:"That leads us to LoxInstance, the runtime representation of an instance of a Lox\r\nclass. Again, our first implementation starts small."}),"\n",(0,s.jsx)(n.p,{children:"^code lox-instance"}),"\n",(0,s.jsx)(n.p,{children:"Like LoxClass, it's pretty bare bones, but we're only getting started. If you\r\nwant to give it a try, here's a script to run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Bagel {}\r\nvar bagel = Bagel();\r\nprint bagel; // Prints "Bagel instance".\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This program doesn't do much, but it's starting to do ",(0,s.jsx)(n.em,{children:"something"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"properties-on-instances",children:"Properties on Instances"}),"\n",(0,s.jsx)(n.p,{children:"We have instances, so we should make them useful. We're at a fork in the road.\r\nWe could add behavior first -- methods -- or we could start with state --\r\nproperties. We're going to take the latter because, as we'll see, the two get\r\nentangled in an interesting way and it will be easier to make sense of them if\r\nwe get properties working first."}),"\n",(0,s.jsxs)(n.p,{children:["Lox follows JavaScript and Python in how it handles state. Every instance is an\r\nopen collection of named values. Methods on the instance's class can access and\r\nmodify properties, but so can ",(0,s.jsx)(n.span,{name:"outside",children:"outside"})," code.\r\nProperties are accessed using a ",(0,s.jsx)(n.code,{children:"."})," syntax."]}),"\n",(0,s.jsxs)(n.aside,{name:"outside",children:["\n",(0,s.jsxs)(n.p,{children:["Allowing code outside of the class to directly modify an object's fields goes\r\nagainst the object-oriented credo that a class ",(0,s.jsx)(n.em,{children:"encapsulates"})," state. Some\r\nlanguages take a more principled stance. In Smalltalk, fields are accessed using\r\nsimple identifiers -- essentially, variables that are only in scope inside a\r\nclass's methods. Ruby uses ",(0,s.jsx)(n.code,{children:"@"})," followed by a name to access a field in an\r\nobject. That syntax is only meaningful inside a method and always accesses state\r\non the current object."]}),"\n",(0,s.jsx)(n.p,{children:"Lox, for better or worse, isn't quite so pious about its OOP faith."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"someObject.someProperty\n"})}),"\n",(0,s.jsxs)(n.p,{children:["An expression followed by ",(0,s.jsx)(n.code,{children:"."})," and an identifier reads the property with that\r\nname from the object the expression evaluates to. That dot has the same\r\nprecedence as the parentheses in a function call expression, so we slot it into\r\nthe grammar by replacing the existing ",(0,s.jsx)(n.code,{children:"call"})," rule with:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'call           \u2192 primary ( "(" arguments? ")" | "." IDENTIFIER )* ;\n'})}),"\n",(0,s.jsx)(n.p,{children:'After a primary expression, we allow a series of any mixture of parenthesized\r\ncalls and dotted property accesses. "Property access" is a mouthful, so from\r\nhere on out, we\'ll call these "get expressions".'}),"\n",(0,s.jsx)(n.h3,{id:"get-expressions",children:"Get expressions"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.span,{name:"get-ast",children:"syntax tree node"})," is:"]}),"\n",(0,s.jsx)(n.p,{children:"^code get-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"get-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#get-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Following the grammar, the new parsing code goes in our existing ",(0,s.jsx)(n.code,{children:"call()"}),"\r\nmethod."]}),"\n",(0,s.jsx)(n.p,{children:"^code parse-property (3 before, 4 after)"}),"\n",(0,s.jsxs)(n.p,{children:["The outer ",(0,s.jsx)(n.code,{children:"while"})," loop there corresponds to the ",(0,s.jsx)(n.code,{children:"*"})," in the grammar rule. We zip\r\nalong the tokens building up a chain of calls and gets as we find parentheses\r\nand dots, like so:"]}),"\n",(0,s.jsx)(n.img,{src:"image/classes/zip.png",alt:"Parsing a series of '.' and '()' expressions to an AST."}),"\n",(0,s.jsx)(n.p,{children:"Instances of the new Expr.Get node feed into the resolver."}),"\n",(0,s.jsx)(n.p,{children:"^code resolver-visit-get"}),"\n",(0,s.jsxs)(n.p,{children:["OK, not much to that. Since properties are looked up ",(0,s.jsx)(n.span,{name:"dispatch",children:"dynamically"}),", they don't get resolved. During resolution,\r\nwe recurse only into the expression to the left of the dot. The actual property\r\naccess happens in the interpreter."]}),"\n",(0,s.jsxs)(n.aside,{name:"dispatch",children:["\n",(0,s.jsx)(n.p,{children:"You can literally see that property dispatch in Lox is dynamic since we don't\r\nprocess the property name during the static resolution pass."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code interpreter-visit-get"}),"\n",(0,s.jsx)(n.p,{children:"First, we evaluate the expression whose property is being accessed. In Lox, only\r\ninstances of classes have properties. If the object is some other type like a\r\nnumber, invoking a getter on it is a runtime error."}),"\n",(0,s.jsx)(n.p,{children:"If the object is a LoxInstance, then we ask it to look up the property. It must\r\nbe time to give LoxInstance some actual state. A map will do fine."}),"\n",(0,s.jsx)(n.p,{children:"^code lox-instance-fields (1 before, 2 after)"}),"\n",(0,s.jsx)(n.p,{children:"Each key in the map is a property name and the corresponding value is the\r\nproperty's value. To look up a property on an instance:"}),"\n",(0,s.jsx)(n.p,{children:"^code lox-instance-get-property"}),"\n",(0,s.jsxs)(n.aside,{name:"hidden",children:["\n",(0,s.jsxs)(n.p,{children:['Doing a hash table lookup for every field access is fast enough for many\r\nlanguage implementations, but not ideal. High performance VMs for languages like\r\nJavaScript use sophisticated optimizations like "',(0,s.jsx)(n.a,{href:"http://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html",children:"hidden classes"}),'" to avoid\r\nthat overhead.']}),"\n",(0,s.jsx)(n.p,{children:"Paradoxically, many of the optimizations invented to make dynamic languages fast\r\nrest on the observation that -- even in those languages -- most code is fairly\r\nstatic in terms of the types of objects it works with and their fields."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An interesting edge case we need to handle is what happens if the instance\r\ndoesn't ",(0,s.jsx)(n.em,{children:"have"})," a property with the given name. We could silently return some\r\ndummy value like ",(0,s.jsx)(n.code,{children:"nil"}),", but my experience with languages like JavaScript is that\r\nthis behavior masks bugs more often than it does anything useful. Instead, we'll\r\nmake it a runtime error."]}),"\n",(0,s.jsx)(n.p,{children:"So the first thing we do is see if the instance actually has a field with the\r\ngiven name. Only then do we return it. Otherwise, we raise an error."}),"\n",(0,s.jsxs)(n.p,{children:['Note how I switched from talking about "properties" to "fields". There is a\r\nsubtle difference between the two. Fields are named bits of state stored\r\ndirectly in an instance. Properties are the named, uh, ',(0,s.jsx)(n.em,{children:"things"}),", that a get\r\nexpression may return. Every field is a property, but as we'll see ",(0,s.jsx)(n.span,{name:"foreshadowing",children:"later"}),", not every property is a field."]}),"\n",(0,s.jsxs)(n.aside,{name:"foreshadowing",children:["\n",(0,s.jsx)(n.p,{children:"Ooh, foreshadowing. Spooky!"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In theory, we can now read properties on objects. But since there's no way to\r\nactually stuff any state into an instance, there are no fields to access. Before\r\nwe can test out reading, we must support writing."}),"\n",(0,s.jsx)(n.h3,{id:"set-expressions",children:"Set expressions"}),"\n",(0,s.jsx)(n.p,{children:"Setters use the same syntax as getters, except they appear on the left side of\r\nan assignment."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"someObject.someProperty = value;\n"})}),"\n",(0,s.jsx)(n.p,{children:"In grammar land, we extend the rule for assignment to allow dotted identifiers\r\non the left-hand side."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ebnf",children:'assignment     \u2192 ( call "." )? IDENTIFIER "=" assignment\r\n               | logic_or ;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Unlike getters, setters don't chain. However, the reference to ",(0,s.jsx)(n.code,{children:"call"})," allows any\r\nhigh-precedence expression before the last dot, including any number of\r\n",(0,s.jsx)(n.em,{children:"getters"}),", as in:"]}),"\n",(0,s.jsx)(n.img,{src:"image/classes/setter.png",alt:"breakfast.omelette.filling.meat = ham"}),"\n",(0,s.jsxs)(n.p,{children:["Note here that only the ",(0,s.jsx)(n.em,{children:"last"})," part, the ",(0,s.jsx)(n.code,{children:".meat"})," is the ",(0,s.jsx)(n.em,{children:"setter"}),". The\r\n",(0,s.jsx)(n.code,{children:".omelette"})," and ",(0,s.jsx)(n.code,{children:".filling"})," parts are both ",(0,s.jsx)(n.em,{children:"get"})," expressions."]}),"\n",(0,s.jsxs)(n.p,{children:["Just as we have two separate AST nodes for variable access and variable\r\nassignment, we need a ",(0,s.jsx)(n.span,{name:"set-ast",children:"second setter node"})," to\r\ncomplement our getter node."]}),"\n",(0,s.jsx)(n.p,{children:"^code set-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"set-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#set-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In case you don't remember, the way we handle assignment in the parser is a\r\nlittle funny. We can't easily tell that a series of tokens is the left-hand side\r\nof an assignment until we reach the ",(0,s.jsx)(n.code,{children:"="}),". Now that our assignment grammar rule\r\nhas ",(0,s.jsx)(n.code,{children:"call"})," on the left side, which can expand to arbitrarily large expressions,\r\nthat final ",(0,s.jsx)(n.code,{children:"="})," may be many tokens away from the point where we need to know\r\nwe're parsing an assignment."]}),"\n",(0,s.jsx)(n.p,{children:"Instead, the trick we do is parse the left-hand side as a normal expression.\r\nThen, when we stumble onto the equal sign after it, we take the expression we\r\nalready parsed and transform it into the correct syntax tree node for the\r\nassignment."}),"\n",(0,s.jsx)(n.p,{children:"We add another clause to that transformation to handle turning an Expr.Get\r\nexpression on the left into the corresponding Expr.Set."}),"\n",(0,s.jsx)(n.p,{children:"^code assign-set (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"That's parsing our syntax. We push that node through into the resolver."}),"\n",(0,s.jsx)(n.p,{children:"^code resolver-visit-set"}),"\n",(0,s.jsx)(n.p,{children:"Again, like Expr.Get, the property itself is dynamically evaluated, so there's\r\nnothing to resolve there. All we need to do is recurse into the two\r\nsubexpressions of Expr.Set, the object whose property is being set, and the\r\nvalue it's being set to."}),"\n",(0,s.jsx)(n.p,{children:"That leads us to the interpreter."}),"\n",(0,s.jsx)(n.p,{children:"^code interpreter-visit-set"}),"\n",(0,s.jsx)(n.p,{children:"We evaluate the object whose property is being set and check to see if it's a\r\nLoxInstance. If not, that's a runtime error. Otherwise, we evaluate the value\r\nbeing set and store it on the instance. That relies on a new method in\r\nLoxInstance."}),"\n",(0,s.jsxs)(n.aside,{name:"order",children:["\n",(0,s.jsx)(n.p,{children:"This is another semantic edge case. There are three distinct operations:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Evaluate the object."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Raise a runtime error if it's not an instance of a class."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Evaluate the value."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The order that those are performed in could be user visible, which means we need\r\nto carefully specify it and ensure our implementations do these in the same\r\norder."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code lox-instance-set-property"}),"\n",(0,s.jsx)(n.p,{children:"No real magic here. We stuff the values straight into the Java map where fields\r\nlive. Since Lox allows freely creating new fields on instances, there's no need\r\nto see if the key is already present."}),"\n",(0,s.jsx)(n.h2,{id:"methods-on-classes",children:"Methods on Classes"}),"\n",(0,s.jsxs)(n.p,{children:["You can create instances of classes and stuff data into them, but the class\r\nitself doesn't really ",(0,s.jsx)(n.em,{children:"do"})," anything. Instances are just maps and all instances\r\nare more or less the same. To make them feel like instances ",(0,s.jsx)(n.em,{children:"of classes"}),", we\r\nneed behavior -- methods."]}),"\n",(0,s.jsxs)(n.p,{children:["Our helpful parser already parses method declarations, so we're good there. We\r\nalso don't need to add any new parser support for method ",(0,s.jsx)(n.em,{children:"calls"}),". We already\r\nhave ",(0,s.jsx)(n.code,{children:"."})," (getters) and ",(0,s.jsx)(n.code,{children:"()"}),' (function calls). A "method call" simply chains\r\nthose together.']}),"\n",(0,s.jsx)(n.img,{src:"image/classes/method.png",alt:"The syntax tree for 'object.method(argument)"}),"\n",(0,s.jsxs)(n.p,{children:["That raises an interesting question. What happens when those two expressions are\r\npulled apart? Assuming that ",(0,s.jsx)(n.code,{children:"method"})," in this example is a method on the class of\r\n",(0,s.jsx)(n.code,{children:"object"})," and not a field on the instance, what should the following piece of\r\ncode do?"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var m = object.method;\r\nm(argument);\n"})}),"\n",(0,s.jsx)(n.p,{children:'This program "looks up" the method and stores the result -- whatever that is --\r\nin a variable and then calls that object later. Is this allowed? Can you treat a\r\nmethod like it\'s a function on the instance?'}),"\n",(0,s.jsx)(n.p,{children:"What about the other direction?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Box {}\r\n\r\nfun notMethod(argument) {\r\n  print "called function with " + argument;\r\n}\r\n\r\nvar box = Box();\r\nbox.function = notMethod;\r\nbox.function("argument");\n'})}),"\n",(0,s.jsx)(n.p,{children:"This program creates an instance and then stores a function in a field on it.\r\nThen it calls that function using the same syntax as a method call. Does that\r\nwork?"}),"\n",(0,s.jsx)(n.p,{children:"Different languages have different answers to these questions. One could write a\r\ntreatise on it. For Lox, we'll say the answer to both of these is yes, it does\r\nwork. We have a couple of reasons to justify that. For the second example --\r\ncalling a function stored in a field -- we want to support that because\r\nfirst-class functions are useful and storing them in fields is a perfectly\r\nnormal thing to do."}),"\n",(0,s.jsx)(n.p,{children:"The first example is more obscure. One motivation is that users generally expect\r\nto be able to hoist a subexpression out into a local variable without changing\r\nthe meaning of the program. You can take this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"breakfast(omelette.filledWith(cheese), sausage);\n"})}),"\n",(0,s.jsx)(n.p,{children:"And turn it into this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"var eggs = omelette.filledWith(cheese);\r\nbreakfast(eggs, sausage);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And it does the same thing. Likewise, since the ",(0,s.jsx)(n.code,{children:"."})," and the ",(0,s.jsx)(n.code,{children:"()"})," in a method\r\ncall ",(0,s.jsx)(n.em,{children:"are"})," two separate expressions, it seems you should be able to hoist the\r\n",(0,s.jsx)(n.em,{children:"lookup"})," part into a variable and then call it ",(0,s.jsx)(n.span,{name:"callback",children:"later"}),". We need to think carefully about what the ",(0,s.jsx)(n.em,{children:"thing"}),"\r\nyou get when you look up a method is, and how it behaves, even in weird cases\r\nlike:"]}),"\n",(0,s.jsxs)(n.aside,{name:"callback",children:["\n",(0,s.jsx)(n.p,{children:"A motivating use for this is callbacks. Often, you want to pass a callback whose\r\nbody simply invokes a method on some object. Being able to look up the method and\r\npass it directly saves you the chore of manually declaring a function to wrap\r\nit. Compare this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"fun callback(a, b, c) {\r\n  object.method(a, b, c);\r\n}\r\n\r\ntakeCallback(callback);\n"})}),"\n",(0,s.jsx)(n.p,{children:"With this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"takeCallback(object.method);\n"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Person {\r\n  sayName() {\r\n    print this.name;\r\n  }\r\n}\r\n\r\nvar jane = Person();\r\njane.name = "Jane";\r\n\r\nvar method = jane.sayName;\r\nmethod(); // ?\n'})}),"\n",(0,s.jsxs)(n.p,{children:['If you grab a handle to a method on some instance and call it later, does it\r\n"remember" the instance it was pulled off from? Does ',(0,s.jsx)(n.code,{children:"this"})," inside the method\r\nstill refer to that original object?"]}),"\n",(0,s.jsx)(n.p,{children:"Here's a more pathological example to bend your brain:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Person {\r\n  sayName() {\r\n    print this.name;\r\n  }\r\n}\r\n\r\nvar jane = Person();\r\njane.name = "Jane";\r\n\r\nvar bill = Person();\r\nbill.name = "Bill";\r\n\r\nbill.sayName = jane.sayName;\r\nbill.sayName(); // ?\n'})}),"\n",(0,s.jsxs)(n.p,{children:['Does that last line print "Bill" because that\'s the instance that we ',(0,s.jsx)(n.em,{children:"called"}),'\r\nthe method through, or "Jane" because it\'s the instance where we first grabbed\r\nthe method?']}),"\n",(0,s.jsxs)(n.p,{children:['Equivalent code in Lua and JavaScript would print "Bill". Those languages don\'t\r\nreally have a notion of "methods". Everything is sort of functions-in-fields, so\r\nit\'s not clear that ',(0,s.jsx)(n.code,{children:"jane"}),' "owns" ',(0,s.jsx)(n.code,{children:"sayName"})," any more than ",(0,s.jsx)(n.code,{children:"bill"})," does."]}),"\n",(0,s.jsxs)(n.p,{children:['Lox, though, has real class syntax so we do know which callable things are\r\nmethods and which are functions. Thus, like Python, C#, and others, we will have\r\nmethods "bind" ',(0,s.jsx)(n.code,{children:"this"})," to the original instance when the method is first grabbed.\r\nPython calls ",(0,s.jsx)(n.span,{name:"bound",children:"these"})," ",(0,s.jsx)(n.strong,{children:"bound methods"}),"."]}),"\n",(0,s.jsxs)(n.aside,{name:"bound",children:["\n",(0,s.jsx)(n.p,{children:"I know, imaginative name, right?"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In practice, that's usually what you want. If you take a reference to a method\r\non some object so you can use it as a callback later, you want to remember the\r\ninstance it belonged to, even if that callback happens to be stored in a field\r\non some other object."}),"\n",(0,s.jsx)(n.p,{children:"OK, that's a lot of semantics to load into your head. Forget about the edge\r\ncases for a bit. We'll get back to those. For now, let's get basic method calls\r\nworking. We're already parsing the method declarations inside the class body, so\r\nthe next step is to resolve them."}),"\n",(0,s.jsx)(n.p,{children:"^code resolve-methods (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"local",children:["\n",(0,s.jsx)(n.p,{children:"Storing the function type in a local variable is pointless right now, but we'll\r\nexpand this code before too long and it will make more sense."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We iterate through the methods in the class body and call the\r\n",(0,s.jsx)(n.code,{children:"resolveFunction()"})," method we wrote for handling function declarations already.\r\nThe only difference is that we pass in a new FunctionType enum value."]}),"\n",(0,s.jsx)(n.p,{children:"^code function-type-method (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["That's going to be important when we resolve ",(0,s.jsx)(n.code,{children:"this"})," expressions. For now, don't\r\nworry about it. The interesting stuff is in the interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"^code interpret-methods (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"When we interpret a class declaration statement, we turn the syntactic\r\nrepresentation of the class -- its AST node -- into its runtime representation.\r\nNow, we need to do that for the methods contained in the class as well. Each\r\nmethod declaration blossoms into a LoxFunction object."}),"\n",(0,s.jsx)(n.p,{children:"We take all of those and wrap them up into a map, keyed by the method names.\r\nThat gets stored in LoxClass."}),"\n",(0,s.jsx)(n.p,{children:"^code lox-class-methods (1 before, 3 after)"}),"\n",(0,s.jsx)(n.p,{children:"Where an instance stores state, the class stores behavior. LoxInstance has its\r\nmap of fields, and LoxClass gets a map of methods. Even though methods are\r\nowned by the class, they are still accessed through instances of that class."}),"\n",(0,s.jsx)(n.p,{children:"^code lox-instance-get-method (5 before, 2 after)"}),"\n",(0,s.jsxs)(n.p,{children:["When looking up a property on an instance, if we don't ",(0,s.jsx)(n.span,{name:"shadow",children:"find"}),' a matching field, we look for a method with that name\r\non the instance\'s class. If found, we return that. This is where the distinction\r\nbetween "field" and "property" becomes meaningful. When accessing a property,\r\nyou might get a field -- a bit of state stored on the instance -- or you could\r\nhit a method defined on the instance\'s class.']}),"\n",(0,s.jsx)(n.p,{children:"The method is looked up using this:"}),"\n",(0,s.jsxs)(n.aside,{name:"shadow",children:["\n",(0,s.jsx)(n.p,{children:"Looking for a field first implies that fields shadow methods, a subtle but\r\nimportant semantic point."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code lox-class-find-method"}),"\n",(0,s.jsx)(n.p,{children:"You can probably guess this method is going to get more interesting later. For\r\nnow, a simple map lookup on the class's method table is enough to get us\r\nstarted. Give it a try:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.span,{name:"crunch"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Bacon {\r\n  eat() {\r\n    print "Crunch crunch crunch!";\r\n  }\r\n}\r\n\r\nBacon().eat(); // Prints "Crunch crunch crunch!".\n'})}),"\n",(0,s.jsxs)(n.aside,{name:"crunch",children:["\n",(0,s.jsx)(n.p,{children:"Apologies if you prefer chewy bacon over crunchy. Feel free to adjust the script\r\nto your taste."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"this",children:"This"}),"\n",(0,s.jsx)(n.p,{children:'We can define both behavior and state on objects, but they aren\'t tied together\r\nyet. Inside a method, we have no way to access the fields of the "current"\r\nobject -- the instance that the method was called on -- nor can we call other\r\nmethods on that same object.'}),"\n",(0,s.jsxs)(n.p,{children:["To get at that instance, it needs a ",(0,s.jsx)(n.span,{name:"i",children:"name"}),'. Smalltalk,\r\nRuby, and Swift use "self". Simula, C++, Java, and others use "this". Python\r\nuses "self" by convention, but you can technically call it whatever you like.']}),"\n",(0,s.jsxs)(n.aside,{name:"i",children:["\n",(0,s.jsx)(n.p,{children:'"I" would have been a great choice, but using "i" for loop variables predates\r\nOOP and goes all the way back to Fortran. We are victims of the incidental\r\nchoices of our forebears.'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['For Lox, since we generally hew to Java-ish style, we\'ll go with "this". Inside\r\na method body, a ',(0,s.jsx)(n.code,{children:"this"})," expression evaluates to the instance that the method was\r\ncalled on. Or, more specifically, since methods are accessed and then invoked as\r\ntwo steps, it will refer to the object that the method was ",(0,s.jsx)(n.em,{children:"accessed"})," from."]}),"\n",(0,s.jsx)(n.p,{children:"That makes our job harder. Peep at:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Egotist {\r\n  speak() {\r\n    print this;\r\n  }\r\n}\r\n\r\nvar method = Egotist().speak;\r\nmethod();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["On the second-to-last line, we grab a reference to the ",(0,s.jsx)(n.code,{children:"speak()"})," method off an\r\ninstance of the class. That returns a function, and that function needs to\r\nremember the instance it was pulled off of so that ",(0,s.jsx)(n.em,{children:"later"}),", on the last line, it\r\ncan still find it when the function is called."]}),"\n",(0,s.jsxs)(n.p,{children:["We need to take ",(0,s.jsx)(n.code,{children:"this"})," at the point that the method is accessed and attach it to\r\nthe function somehow so that it stays around as long as we need it to. Hmm... a\r\nway to store some extra data that hangs around a function, eh? That sounds an\r\nawful lot like a ",(0,s.jsx)(n.em,{children:"closure"}),", doesn't it?"]}),"\n",(0,s.jsxs)(n.p,{children:["If we defined ",(0,s.jsx)(n.code,{children:"this"})," as a sort of hidden variable in an environment that\r\nsurrounds the function returned when looking up a method, then uses of ",(0,s.jsx)(n.code,{children:"this"})," in\r\nthe body would be able to find it later. LoxFunction already has the ability to\r\nhold on to a surrounding environment, so we have the machinery we need."]}),"\n",(0,s.jsx)(n.p,{children:"Let's walk through an example to see how it works:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Cake {\r\n  taste() {\r\n    var adjective = "delicious";\r\n    print "The " + this.flavor + " cake is " + adjective + "!";\r\n  }\r\n}\r\n\r\nvar cake = Cake();\r\ncake.flavor = "German chocolate";\r\ncake.taste(); // Prints "The German chocolate cake is delicious!".\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When we first evaluate the class definition, we create a LoxFunction for\r\n",(0,s.jsx)(n.code,{children:"taste()"}),". Its closure is the environment surrounding the class, in this case\r\nthe global one. So the LoxFunction we store in the class's method map looks\r\nlike so:"]}),"\n",(0,s.jsx)(n.img,{src:"image/classes/closure.png",alt:"The initial closure for the method."}),"\n",(0,s.jsxs)(n.p,{children:["When we evaluate the ",(0,s.jsx)(n.code,{children:"cake.taste"})," get expression, we create a new environment\r\nthat binds ",(0,s.jsx)(n.code,{children:"this"})," to the object the method is accessed from (here, ",(0,s.jsx)(n.code,{children:"cake"}),"). Then\r\nwe make a ",(0,s.jsx)(n.em,{children:"new"})," LoxFunction with the same code as the original one but using\r\nthat new environment as its closure."]}),"\n",(0,s.jsx)(n.img,{src:"image/classes/bound-method.png",alt:"The new closure that binds 'this'."}),"\n",(0,s.jsxs)(n.p,{children:["This is the LoxFunction that gets returned when evaluating the get expression\r\nfor the method name. When that function is later called by a ",(0,s.jsx)(n.code,{children:"()"})," expression,\r\nwe create an environment for the method body as usual."]}),"\n",(0,s.jsx)(n.img,{src:"image/classes/call.png",alt:"Calling the bound method and creating a new environment for the method body."}),"\n",(0,s.jsxs)(n.p,{children:["The parent of the body environment is the environment we created earlier to bind\r\n",(0,s.jsx)(n.code,{children:"this"})," to the current object. Thus any use of ",(0,s.jsx)(n.code,{children:"this"})," inside the body\r\nsuccessfully resolves to that instance."]}),"\n",(0,s.jsxs)(n.p,{children:["Reusing our environment code for implementing ",(0,s.jsx)(n.code,{children:"this"})," also takes care of\r\ninteresting cases where methods and functions interact, like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Thing {\r\n  getCallback() {\r\n    fun localFunction() {\r\n      print this;\r\n    }\r\n\r\n    return localFunction;\r\n  }\r\n}\r\n\r\nvar callback = Thing().getCallback();\r\ncallback();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In, say, JavaScript, it's common to return a callback from inside a method. That\r\ncallback may want to hang on to and retain access to the original object -- the\r\n",(0,s.jsx)(n.code,{children:"this"})," value -- that the method was associated with. Our existing support for\r\nclosures and environment chains should do all this correctly."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's code it up. The first step is adding ",(0,s.jsx)(n.span,{name:"this-ast",children:"new\r\nsyntax"})," for ",(0,s.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"^code this-ast (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.aside,{name:"this-ast",children:["\n",(0,s.jsxs)(n.p,{children:["The generated code for the new node is in ",(0,s.jsx)(n.a,{href:"appendix-ii.html#this-expression",children:"Appendix II"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Parsing is simple since it's a single token which our lexer already\r\nrecognizes as a reserved word."}),"\n",(0,s.jsx)(n.p,{children:"^code parse-this (2 before, 2 after)"}),"\n",(0,s.jsxs)(n.p,{children:["You can start to see how ",(0,s.jsx)(n.code,{children:"this"})," works like a variable when we get to the\r\nresolver."]}),"\n",(0,s.jsx)(n.p,{children:"^code resolver-visit-this"}),"\n",(0,s.jsxs)(n.p,{children:['We resolve it exactly like any other local variable using "this" as the name for\r\nthe "variable". Of course, that\'s not going to work right now, because "this"\r\n',(0,s.jsx)(n.em,{children:"isn't"})," declared in any scope. Let's fix that over in ",(0,s.jsx)(n.code,{children:"visitClassStmt()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"^code resolver-begin-this-scope (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:'Before we step in and start resolving the method bodies, we push a new scope and\r\ndefine "this" in it as if it were a variable. Then, when we\'re done, we discard\r\nthat surrounding scope.'}),"\n",(0,s.jsx)(n.p,{children:"^code resolver-end-this-scope (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["Now, whenever a ",(0,s.jsx)(n.code,{children:"this"}),' expression is encountered (at least inside a method) it\r\nwill resolve to a "local variable" defined in an implicit scope just outside of\r\nthe block for the method body.']}),"\n",(0,s.jsxs)(n.p,{children:["The resolver has a new ",(0,s.jsx)(n.em,{children:"scope"})," for ",(0,s.jsx)(n.code,{children:"this"}),", so the interpreter needs to create a\r\ncorresponding ",(0,s.jsx)(n.em,{children:"environment"})," for it. Remember, we always have to keep the\r\nresolver's scope chains and the interpreter's linked environments in sync with\r\neach other. At runtime, we create the environment after we find the method on\r\nthe instance. We replace the previous line of code that simply returned the\r\nmethod's LoxFunction with this:"]}),"\n",(0,s.jsx)(n.p,{children:"^code lox-instance-bind-method (1 before, 3 after)"}),"\n",(0,s.jsxs)(n.p,{children:["Note the new call to ",(0,s.jsx)(n.code,{children:"bind()"}),". That looks like so:"]}),"\n",(0,s.jsx)(n.p,{children:"^code bind-instance"}),"\n",(0,s.jsx)(n.p,{children:"There isn't much to it. We create a new environment nestled inside the method's\r\noriginal closure. Sort of a closure-within-a-closure. When the method is called,\r\nthat will become the parent of the method body's environment."}),"\n",(0,s.jsxs)(n.p,{children:['We declare "this" as a variable in that environment and bind it to the given\r\ninstance, the instance that the method is being accessed from. ',(0,s.jsx)(n.em,{children:"Et voil\xe0"}),', the\r\nreturned LoxFunction now carries around its own little persistent world where\r\n"this" is bound to the object.']}),"\n",(0,s.jsxs)(n.p,{children:["The remaining task is interpreting those ",(0,s.jsx)(n.code,{children:"this"})," expressions. Similar to the\r\nresolver, it is the same as interpreting a variable expression."]}),"\n",(0,s.jsx)(n.p,{children:"^code interpreter-visit-this"}),"\n",(0,s.jsxs)(n.p,{children:["Go ahead and give it a try using that cake example from earlier. With less than\r\ntwenty lines of code, our interpreter handles ",(0,s.jsx)(n.code,{children:"this"})," inside methods even in all\r\nof the weird ways it can interact with nested classes, functions inside methods,\r\nhandles to methods, etc."]}),"\n",(0,s.jsx)(n.h3,{id:"invalid-uses-of-this",children:"Invalid uses of this"}),"\n",(0,s.jsxs)(n.p,{children:["Wait a minute. What happens if you try to use ",(0,s.jsx)(n.code,{children:"this"})," ",(0,s.jsx)(n.em,{children:"outside"})," of a method? What\r\nabout:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"print this;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"fun notAMethod() {\r\n  print this;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There is no instance for ",(0,s.jsx)(n.code,{children:"this"})," to point to if you're not in a method. We could\r\ngive it some default value like ",(0,s.jsx)(n.code,{children:"nil"})," or make it a runtime error, but the user\r\nhas clearly made a mistake. The sooner they find and fix that mistake, the\r\nhappier they'll be."]}),"\n",(0,s.jsxs)(n.p,{children:["Our resolution pass is a fine place to detect this error statically. It already\r\ndetects ",(0,s.jsx)(n.code,{children:"return"})," statements outside of functions. We'll do something similar for\r\n",(0,s.jsx)(n.code,{children:"this"}),". In the vein of our existing FunctionType enum, we define a new ClassType\r\none."]}),"\n",(0,s.jsx)(n.p,{children:"^code class-type (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["Yes, it could be a Boolean. When we get to inheritance, it will get a third\r\nvalue, hence the enum right now. We also add a corresponding field,\r\n",(0,s.jsx)(n.code,{children:"currentClass"}),". Its value tells us if we are currently inside a class\r\ndeclaration while traversing the syntax tree. It starts out ",(0,s.jsx)(n.code,{children:"NONE"})," which means\r\nwe aren't in one."]}),"\n",(0,s.jsx)(n.p,{children:"When we begin to resolve a class declaration, we change that."}),"\n",(0,s.jsx)(n.p,{children:"^code set-current-class (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["As with ",(0,s.jsx)(n.code,{children:"currentFunction"}),", we store the previous value of the field in a local\r\nvariable. This lets us piggyback onto the JVM to keep a stack of ",(0,s.jsx)(n.code,{children:"currentClass"}),"\r\nvalues. That way we don't lose track of the previous value if one class nests\r\ninside another."]}),"\n",(0,s.jsx)(n.p,{children:'Once the methods have been resolved, we "pop" that stack by restoring the old\r\nvalue.'}),"\n",(0,s.jsx)(n.p,{children:"^code restore-current-class (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["When we resolve a ",(0,s.jsx)(n.code,{children:"this"})," expression, the ",(0,s.jsx)(n.code,{children:"currentClass"})," field gives us the bit\r\nof data we need to report an error if the expression doesn't occur nestled\r\ninside a method body."]}),"\n",(0,s.jsx)(n.p,{children:"^code this-outside-of-class (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["That should help users use ",(0,s.jsx)(n.code,{children:"this"})," correctly, and it saves us from having to\r\nhandle misuse at runtime in the interpreter."]}),"\n",(0,s.jsx)(n.h2,{id:"constructors-and-initializers",children:"Constructors and Initializers"}),"\n",(0,s.jsxs)(n.p,{children:["We can do almost everything with classes now, and as we near the end of the\r\nchapter we find ourselves strangely focused on a beginning. Methods and fields\r\nlet us encapsulate state and behavior together so that an object always ",(0,s.jsx)(n.em,{children:"stays"}),"\r\nin a valid configuration. But how do we ensure a brand new object ",(0,s.jsx)(n.em,{children:"starts"})," in a\r\ngood state?"]}),"\n",(0,s.jsxs)(n.p,{children:["For that, we need constructors. I find them one of the trickiest parts of a\r\nlanguage to design, and if you peer closely at most other languages, you'll see\r\n",(0,s.jsx)(n.span,{name:"cracks",children:"cracks"})," around object construction where the seams of\r\nthe design don't quite fit together perfectly. Maybe there's something\r\nintrinsically messy about the moment of birth."]}),"\n",(0,s.jsxs)(n.aside,{name:"cracks",children:["\n",(0,s.jsxs)(n.p,{children:["A few examples: In Java, even though final fields must be initialized, it is\r\nstill possible to read one ",(0,s.jsx)(n.em,{children:"before"})," it has been. Exceptions -- a huge, complex\r\nfeature -- were added to C++ mainly as a way to emit errors from constructors."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'"Constructing" an object is actually a pair of operations:'}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The runtime ",(0,s.jsx)(n.span,{name:"allocate",children:(0,s.jsx)(n.em,{children:"allocates"})})," the memory required for\r\na fresh instance. In most languages, this operation is at a fundamental\r\nlevel beneath what user code is able to access."]}),"\n",(0,s.jsxs)(n.aside,{name:"allocate",children:["\n",(0,s.jsxs)(n.p,{children:["C++'s \"",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Placement_syntax",children:"placement new"}),'" is a rare example where the bowels of allocation\r\nare laid bare for the programmer to prod.']}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Then, a user-provided chunk of code is called which ",(0,s.jsx)(n.em,{children:"initializes"})," the\r\nunformed object."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'The latter is what we tend to think of when we hear "constructor", but the\r\nlanguage itself has usually done some groundwork for us before we get to that\r\npoint. In fact, our Lox interpreter already has that covered when it creates a\r\nnew LoxInstance object.'}),"\n",(0,s.jsxs)(n.p,{children:["We'll do the remaining part -- user-defined initialization -- now. Languages\r\nhave a variety of notations for the chunk of code that sets up a new object for\r\na class. C++, Java, and C# use a method whose name matches the class name. Ruby\r\nand Python call it ",(0,s.jsx)(n.code,{children:"init()"}),". The latter is nice and short, so we'll do that."]}),"\n",(0,s.jsx)(n.p,{children:"In LoxClass's implementation of LoxCallable, we add a few more lines."}),"\n",(0,s.jsx)(n.p,{children:"^code lox-class-call-initializer (2 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:'When a class is called, after the LoxInstance is created, we look for an "init"\r\nmethod. If we find one, we immediately bind and invoke it just like a normal\r\nmethod call. The argument list is forwarded along.'}),"\n",(0,s.jsx)(n.p,{children:"That argument list means we also need to tweak how a class declares its arity."}),"\n",(0,s.jsx)(n.p,{children:"^code lox-initializer-arity (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["If there is an initializer, that method's arity determines how many arguments\r\nyou must pass when you call the class itself. We don't ",(0,s.jsx)(n.em,{children:"require"})," a class to\r\ndefine an initializer, though, as a convenience. If you don't have an\r\ninitializer, the arity is still zero."]}),"\n",(0,s.jsxs)(n.p,{children:["That's basically it. Since we bind the ",(0,s.jsx)(n.code,{children:"init()"})," method before we call it, it has\r\naccess to ",(0,s.jsx)(n.code,{children:"this"})," inside its body. That, along with the arguments passed to the\r\nclass, are all you need to be able to set up the new instance however you\r\ndesire."]}),"\n",(0,s.jsx)(n.h3,{id:"invoking-init-directly",children:"Invoking init() directly"}),"\n",(0,s.jsx)(n.p,{children:"As usual, exploring this new semantic territory rustles up a few weird\r\ncreatures. Consider:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Foo {\r\n  init() {\r\n    print this;\r\n  }\r\n}\r\n\r\nvar foo = Foo();\r\nprint foo.init();\n"})}),"\n",(0,s.jsxs)(n.p,{children:['Can you "re-initialize" an object by directly calling its ',(0,s.jsx)(n.code,{children:"init()"})," method? If\r\nyou do, what does it return? A ",(0,s.jsx)(n.span,{name:"compromise",children:"reasonable"})," answer\r\nwould be ",(0,s.jsx)(n.code,{children:"nil"})," since that's what it appears the body returns."]}),"\n",(0,s.jsxs)(n.p,{children:["However -- and I generally dislike compromising to satisfy the\r\nimplementation -- it will make clox's implementation of constructors much\r\neasier if we say that ",(0,s.jsx)(n.code,{children:"init()"})," methods always return ",(0,s.jsx)(n.code,{children:"this"}),", even when\r\ndirectly called. In order to keep jlox compatible with that, we add a little\r\nspecial case code in LoxFunction."]}),"\n",(0,s.jsxs)(n.aside,{name:"compromise",children:["\n",(0,s.jsxs)(n.p,{children:['Maybe "dislike" is too strong a claim. It\'s reasonable to have the constraints\r\nand resources of your implementation affect the design of the language. There\r\nare only so many hours in the day, and if a cut corner here or there lets you get\r\nmore features to users in less time, it may very well be a net win for their\r\nhappiness and productivity. The trick is figuring out ',(0,s.jsx)(n.em,{children:"which"})," corners to cut\r\nthat won't cause your users and future self to curse your shortsightedness."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"^code return-this (2 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["If the function is an initializer, we override the actual return value and\r\nforcibly return ",(0,s.jsx)(n.code,{children:"this"}),". That relies on a new ",(0,s.jsx)(n.code,{children:"isInitializer"})," field."]}),"\n",(0,s.jsx)(n.p,{children:"^code is-initializer-field (2 before, 2 after)"}),"\n",(0,s.jsxs)(n.p,{children:['We can\'t simply see if the name of the LoxFunction is "init" because the user\r\ncould have defined a ',(0,s.jsx)(n.em,{children:"function"})," with that name. In that case, there ",(0,s.jsx)(n.em,{children:"is"})," no\r\n",(0,s.jsx)(n.code,{children:"this"})," to return. To avoid ",(0,s.jsx)(n.em,{children:"that"})," weird edge case, we'll directly store whether\r\nthe LoxFunction represents an initializer method. That means we need to go back\r\nand fix the few places where we create LoxFunctions."]}),"\n",(0,s.jsx)(n.p,{children:"^code construct-function (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["For actual function declarations, ",(0,s.jsx)(n.code,{children:"isInitializer"})," is always false. For methods,\r\nwe check the name."]}),"\n",(0,s.jsx)(n.p,{children:"^code interpreter-method-initializer (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["And then in ",(0,s.jsx)(n.code,{children:"bind()"})," where we create the closure that binds ",(0,s.jsx)(n.code,{children:"this"})," to a method,\r\nwe pass along the original method's value."]}),"\n",(0,s.jsx)(n.p,{children:"^code lox-function-bind-with-initializer (1 before, 1 after)"}),"\n",(0,s.jsx)(n.h3,{id:"returning-from-init",children:"Returning from init()"}),"\n",(0,s.jsx)(n.p,{children:"We aren't out of the woods yet. We've been assuming that a user-written\r\ninitializer doesn't explicitly return a value because most constructors don't.\r\nWhat should happen if a user tries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Foo {\r\n  init() {\r\n    return "something else";\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"It's definitely not going to do what they want, so we may as well make it a\r\nstatic error. Back in the resolver, we add another case to FunctionType."}),"\n",(0,s.jsx)(n.p,{children:"^code function-type-initializer (1 before, 1 after)"}),"\n",(0,s.jsx)(n.p,{children:"We use the visited method's name to determine if we're resolving an initializer\r\nor not."}),"\n",(0,s.jsx)(n.p,{children:"^code resolver-initializer-type (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["When we later traverse into a ",(0,s.jsx)(n.code,{children:"return"})," statement, we check that field and make\r\nit an error to return a value from inside an ",(0,s.jsx)(n.code,{children:"init()"})," method."]}),"\n",(0,s.jsx)(n.p,{children:"^code return-in-initializer (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["We're ",(0,s.jsx)(n.em,{children:"still"})," not done. We statically disallow returning a ",(0,s.jsx)(n.em,{children:"value"})," from an\r\ninitializer, but you can still use an empty early ",(0,s.jsx)(n.code,{children:"return"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:"class Foo {\r\n  init() {\r\n    return;\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["That is actually kind of useful sometimes, so we don't want to disallow it\r\nentirely. Instead, it should return ",(0,s.jsx)(n.code,{children:"this"})," instead of ",(0,s.jsx)(n.code,{children:"nil"}),". That's an easy fix\r\nover in LoxFunction."]}),"\n",(0,s.jsx)(n.p,{children:"^code early-return-this (1 before, 1 after)"}),"\n",(0,s.jsxs)(n.p,{children:["If we're in an initializer and execute a ",(0,s.jsx)(n.code,{children:"return"})," statement, instead of\r\nreturning the value (which will always be ",(0,s.jsx)(n.code,{children:"nil"}),"), we again return ",(0,s.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Phew! That was a whole list of tasks but our reward is that our little\r\ninterpreter has grown an entire programming paradigm. Classes, methods, fields,\r\n",(0,s.jsx)(n.code,{children:"this"}),", and constructors. Our baby language is looking awfully grown-up."]}),"\n",(0,s.jsxs)(n.div,{className:"challenges",children:["\n",(0,s.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['We have methods on instances, but there is no way to define "static" methods\r\nthat can be called directly on the class object itself. Add support for\r\nthem. Use a ',(0,s.jsx)(n.code,{children:"class"})," keyword preceding the method to indicate a static method\r\nthat hangs off the class object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Math {\r\n  class square(n) {\r\n    return n * n;\r\n  }\r\n}\r\n\r\nprint Math.square(3); // Prints "9".\n'})}),"\n",(0,s.jsxs)(n.p,{children:['You can solve this however you like, but the "',(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Metaclass",children:"metaclasses"}),'" used by\r\nSmalltalk and Ruby are a particularly elegant approach. ',(0,s.jsx)(n.em,{children:"Hint: Make LoxClass\r\nextend LoxInstance and go from there."})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'Most modern languages support "getters" and "setters" -- members on a class\r\nthat look like field reads and writes but that actually execute user-defined\r\ncode. Extend Lox to support getter methods. These are declared without a\r\nparameter list. The body of the getter is executed when a property with that\r\nname is accessed.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lox",children:'class Circle {\r\n  init(radius) {\r\n    this.radius = radius;\r\n  }\r\n\r\n  area {\r\n    return 3.141592653 * this.radius * this.radius;\r\n  }\r\n}\r\n\r\nvar circle = Circle(4);\r\nprint circle.area; // Prints roughly "50.2655".\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Python and JavaScript allow you to freely access an object's fields from\r\noutside of its own methods. Ruby and Smalltalk encapsulate instance state.\r\nOnly methods on the class can access the raw fields, and it is up to the\r\nclass to decide which state is exposed. Most statically typed languages\r\noffer modifiers like ",(0,s.jsx)(n.code,{children:"private"})," and ",(0,s.jsx)(n.code,{children:"public"})," to control which parts of a\r\nclass are externally accessible on a per-member basis."]}),"\n",(0,s.jsx)(n.p,{children:"What are the trade-offs between these approaches and why might a language\r\nprefer one or the other?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.div,{className:"design-note",children:["\n",(0,s.jsx)(n.h2,{id:"design-note-prototypes-and-power",children:"Design Note: Prototypes and Power"}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, we introduced two new runtime entities, LoxClass and\r\nLoxInstance. The former is where behavior for objects lives, and the latter is\r\nfor state. What if you could define methods right on a single object, inside\r\nLoxInstance? In that case, we wouldn't need LoxClass at all. LoxInstance would\r\nbe a complete package for defining the behavior and state of an object."}),"\n",(0,s.jsxs)(n.p,{children:["We'd still want some way, without classes, to reuse behavior across multiple\r\ninstances. We could let a LoxInstance ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Prototype-based_programming#Delegation",children:(0,s.jsx)(n.em,{children:"delegate"})})," directly to another\r\nLoxInstance to reuse its fields and methods, sort of like inheritance."]}),"\n",(0,s.jsx)(n.p,{children:'Users would model their program as a constellation of objects, some of which\r\ndelegate to each other to reflect commonality. Objects used as delegates\r\nrepresent "canonical" or "prototypical" objects that others refine. The result\r\nis a simpler runtime with only a single internal construct, LoxInstance.'}),"\n",(0,s.jsxs)(n.p,{children:["That's where the name ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Prototype-based_programming",children:"prototypes"})})," comes from for this paradigm. It\r\nwas invented by David Ungar and Randall Smith in a language called ",(0,s.jsx)(n.a,{href:"http://www.selflanguage.org/",children:"Self"}),".\r\nThey came up with it by starting with Smalltalk and following the above mental\r\nexercise to see how much they could pare it down."]}),"\n",(0,s.jsxs)(n.p,{children:["Prototypes were an academic curiosity for a long time, a fascinating one that\r\ngenerated interesting research but didn't make a dent in the larger world of\r\nprogramming. That is, until Brendan Eich crammed prototypes into JavaScript,\r\nwhich then promptly took over the world. Many (many) ",(0,s.jsx)(n.span,{name:"words",children:"words"})," have been written about prototypes in JavaScript.\r\nWhether that shows that prototypes are brilliant or confusing -- or both! -- is\r\nan open question."]}),"\n",(0,s.jsxs)(n.aside,{name:"words",children:["\n",(0,s.jsxs)(n.p,{children:["Including ",(0,s.jsx)(n.a,{href:"http://gameprogrammingpatterns.com/prototype.html",children:"more than a handful"})," by yours truly."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["I won't get into whether or not I think prototypes are a good idea for a\r\nlanguage. I've made languages that are ",(0,s.jsx)(n.a,{href:"http://finch.stuffwithstuff.com/",children:"prototypal"})," and\r\n",(0,s.jsx)(n.a,{href:"http://wren.io/",children:"class-based"}),", and my opinions of both are complex. What I want to discuss\r\nis the role of ",(0,s.jsx)(n.em,{children:"simplicity"})," in a language."]}),"\n",(0,s.jsxs)(n.p,{children:["Prototypes are simpler than classes -- less code for the language implementer to\r\nwrite, and fewer concepts for the user to learn and understand. Does that make\r\nthem better? We language nerds have a tendency to fetishize minimalism.\r\nPersonally, I think simplicity is only part of the equation. What we really want\r\nto give the user is ",(0,s.jsx)(n.em,{children:"power"}),", which I define as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"power = breadth \xd7 ease \xf7 complexity\n"})}),"\n",(0,s.jsx)(n.p,{children:"None of these are precise numeric measures. I'm using math as analogy here, not\r\nactual quantification."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Breadth"})," is the range of different things the language lets you express.\r\nC has a lot of breadth -- it's been used for everything from operating\r\nsystems to user applications to games. Domain-specific languages like\r\nAppleScript and Matlab have less breadth."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Ease"}),' is how little effort it takes to make the language do what you\r\nwant. "Usability" might be another term, though it carries more baggage than\r\nI want to bring in. "Higher-level" languages tend to have more ease than\r\n"lower-level" ones. Most languages have a "grain" to them where some things\r\nfeel easier to express than others.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complexity"})," is how big the language (including its runtime, core libraries,\r\ntools, ecosystem, etc.) is. People talk about how many pages are in a\r\nlanguage's spec, or how many keywords it has. It's how much the user has to\r\nload into their wetware before they can be productive in the system. It is\r\nthe antonym of simplicity."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Reducing complexity ",(0,s.jsx)(n.em,{children:"does"})," increase power. The smaller the denominator, the\r\nlarger the resulting value, so our intuition that simplicity is good is valid.\r\nHowever, when reducing complexity, we must take care not to sacrifice breadth or\r\nease in the process, or the total power may go down. Java would be a strictly\r\n",(0,s.jsx)(n.em,{children:"simpler"})," language if it removed strings, but it probably wouldn't handle text\r\nmanipulation tasks well, nor would it be as easy to get things done."]}),"\n",(0,s.jsxs)(n.p,{children:["The art, then, is finding ",(0,s.jsx)(n.em,{children:"accidental"})," complexity that can be omitted --\r\nlanguage features and interactions that don't carry their weight by increasing\r\nthe breadth or ease of using the language."]}),"\n",(0,s.jsx)(n.p,{children:"If users want to express their program in terms of categories of objects, then\r\nbaking classes into the language increases the ease of doing that, hopefully by\r\na large enough margin to pay for the added complexity. But if that isn't how\r\nusers are using your language, then by all means leave classes out."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);