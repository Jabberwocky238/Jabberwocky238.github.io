"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[7777],{8746:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>h});var r=t(4848),i=t(8453);const s={},a=void 0,o={id:"Craftinginterpreters/not-translated-yet/resolving-and-binding",title:"resolving-and-binding",description:"Once in a while you find yourself in an odd situation. You get into it by",source:"@site/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/resolving-and-binding",permalink:"/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"representing-code",permalink:"/docs/Craftinginterpreters/not-translated-yet/representing-code"},next:{title:"scanning-on-demand",permalink:"/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand"}},l={},h=[{value:"Static Scope",id:"static-scope",level:2},{value:"Scopes and mutable environments",id:"scopes-and-mutable-environments",level:3},{value:"Persistent environments",id:"persistent-environments",level:3},{value:"Semantic Analysis",id:"semantic-analysis",level:2},{value:"A variable resolution pass",id:"a-variable-resolution-pass",level:3},{value:"A Resolver Class",id:"a-resolver-class",level:2},{value:"Resolving blocks",id:"resolving-blocks",level:3},{value:"Resolving variable declarations",id:"resolving-variable-declarations",level:3},{value:"Resolving variable expressions",id:"resolving-variable-expressions",level:3},{value:"Resolving assignment expressions",id:"resolving-assignment-expressions",level:3},{value:"Resolving function declarations",id:"resolving-function-declarations",level:3},{value:"Resolving the other syntax tree nodes",id:"resolving-the-other-syntax-tree-nodes",level:3},{value:"Interpreting Resolved Variables",id:"interpreting-resolved-variables",level:2},{value:"Accessing a resolved variable",id:"accessing-a-resolved-variable",level:3},{value:"Assigning to a resolved variable",id:"assigning-to-a-resolved-variable",level:3},{value:"Running the resolver",id:"running-the-resolver",level:3},{value:"Resolution Errors",id:"resolution-errors",level:2},{value:"Invalid return errors",id:"invalid-return-errors",level:3},{value:"Challenges",id:"challenges",level:2}];function c(e){const n={a:"a",aside:"aside",blockquote:"blockquote",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Once in a while you find yourself in an odd situation. You get into it by\r\ndegrees and in the most natural way but, when you are right in the midst of\r\nit, you are suddenly astonished and ask yourself how in the world it all came\r\nabout."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.cite,{children:["Thor Heyerdahl, ",(0,r.jsx)(n.em,{children:"Kon-Tiki"})]})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Oh, no! Our language implementation is taking on water! Way back when we ",(0,r.jsx)(n.a,{href:"statements-and-state.html",children:"added\r\nvariables and blocks"}),", we had scoping nice and tight. But when we\r\n",(0,r.jsx)(n.a,{href:"functions.html",children:"later added closures"}),", a hole opened in our formerly waterproof\r\ninterpreter. Most real programs are unlikely to slip through this hole, but as\r\nlanguage implementers, we take a sacred vow to care about correctness even in\r\nthe deepest, dampest corners of the semantics."]}),"\n",(0,r.jsxs)(n.p,{children:["We will spend this entire chapter exploring that leak, and then carefully\r\npatching it up. In the process, we will gain a more rigorous understanding of\r\nlexical scoping as used by Lox and other languages in the C tradition. We'll\r\nalso get a chance to learn about ",(0,r.jsx)(n.em,{children:"semantic analysis"})," -- a powerful technique for\r\nextracting meaning from the user's source code without having to run it."]}),"\n",(0,r.jsx)(n.h2,{id:"static-scope",children:"Static Scope"}),"\n",(0,r.jsxs)(n.p,{children:["A quick refresher: Lox, like most modern languages, uses ",(0,r.jsx)(n.em,{children:"lexical"})," scoping. This\r\nmeans that you can figure out which declaration a variable name refers to just\r\nby reading the text of the program. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var a = "outer";\r\n{\r\n  var a = "inner";\r\n  print a;\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, we know that the ",(0,r.jsx)(n.code,{children:"a"})," being printed is the variable declared on the\r\nprevious line, and not the global one. Running the program doesn't -- ",(0,r.jsx)(n.em,{children:"can't"})," --\r\naffect this. The scope rules are part of the ",(0,r.jsx)(n.em,{children:"static"})," semantics of the language,\r\nwhich is why they're also called ",(0,r.jsx)(n.em,{children:"static scope"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["I haven't spelled out those scope rules, but now is the time for ",(0,r.jsx)(n.span,{name:"precise",children:"precision"}),":"]}),"\n",(0,r.jsxs)(n.aside,{name:"precise",children:["\n",(0,r.jsx)(n.p,{children:"This is still nowhere near as precise as a real language specification. Those\r\ndocs must be so explicit that even a Martian or an outright malicious programmer\r\nwould be forced to implement the correct semantics provided they followed the\r\nletter of the spec."}),"\n",(0,r.jsx)(n.p,{children:"That exactitude is important when a language may be implemented by competing\r\ncompanies who want their product to be incompatible with the others to lock\r\ncustomers onto their platform. For this book, we can thankfully ignore those\r\nkinds of shady shenanigans."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"A variable usage refers to the preceding declaration with the same name in the\r\ninnermost scope that encloses the expression where the variable is used."})}),"\n",(0,r.jsx)(n.p,{children:"There's a lot to unpack in that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'I say "variable usage" instead of "variable expression" to cover both\r\nvariable expressions and assignments. Likewise with "expression where the\r\nvariable is used".'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:['"Preceding" means appearing before ',(0,r.jsx)(n.em,{children:"in the program text"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var a = "outer";\r\n{\r\n  print a;\r\n  var a = "inner";\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the ",(0,r.jsx)(n.code,{children:"a"})," being printed is the outer one since it appears ",(0,r.jsx)(n.span,{name:"hoisting",children:"before"})," the ",(0,r.jsx)(n.code,{children:"print"})," statement that uses it. In most\r\ncases, in straight line code, the declaration preceding in ",(0,r.jsx)(n.em,{children:"text"})," will also\r\nprecede the usage in ",(0,r.jsx)(n.em,{children:"time"}),". But that's not always true. As we'll see,\r\nfunctions may defer a chunk of code such that its ",(0,r.jsx)(n.em,{children:"dynamic temporal"}),"\r\nexecution no longer mirrors the ",(0,r.jsx)(n.em,{children:"static textual"})," ordering."]}),"\n",(0,r.jsxs)(n.aside,{name:"hoisting",children:["\n",(0,r.jsxs)(n.p,{children:["In JavaScript, variables declared using ",(0,r.jsx)(n.code,{children:"var"}),' are implicitly "hoisted" to\r\nthe beginning of the block. Any use of that name in the block will refer to\r\nthat variable, even if the use appears before the declaration. When you\r\nwrite this in JavaScript:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'{\r\n  console.log(a);\r\n  var a = "value";\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"It behaves like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'{\r\n  var a; // Hoist.\r\n  console.log(a);\r\n  a = "value";\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["That means that in some cases you can read a variable before its initializer\r\nhas run -- an annoying source of bugs. The alternate ",(0,r.jsx)(n.code,{children:"let"})," syntax for\r\ndeclaring variables was added later to address this problem."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'"Innermost" is there because of our good friend shadowing. There may be more\r\nthan one variable with the given name in enclosing scopes, as in:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var a = "outer";\r\n{\r\n  var a = "inner";\r\n  print a;\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Our rule disambiguates this case by saying the innermost scope wins."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Since this rule makes no mention of any runtime behavior, it implies that a\r\nvariable expression always refers to the same declaration through the entire\r\nexecution of the program. Our interpreter so far ",(0,r.jsx)(n.em,{children:"mostly"})," implements the rule\r\ncorrectly. But when we added closures, an error snuck in."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var a = "global";\r\n{\r\n  fun showA() {\r\n    print a;\r\n  }\r\n\r\n  showA();\r\n  var a = "block";\r\n  showA();\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.span,{name:"tricky",children:"Before"})," you type this in and run it, decide what you\r\nthink it ",(0,r.jsx)(n.em,{children:"should"})," print."]}),"\n",(0,r.jsxs)(n.aside,{name:"tricky",children:["\n",(0,r.jsxs)(n.p,{children:["I know, it's a totally pathological, contrived program. It's just ",(0,r.jsx)(n.em,{children:"weird"}),". No\r\nreasonable person would ever write code like this. Alas, more of your life than\r\nyou'd expect will be spent dealing with bizarro snippets of code like this if\r\nyou stay in the programming language game for long."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["OK... got it? If you're familiar with closures in other languages, you'll expect\r\nit to print \"global\" twice. The first call to ",(0,r.jsx)(n.code,{children:"showA()"}),' should definitely print\r\n"global" since we haven\'t even reached the declaration of the inner ',(0,r.jsx)(n.code,{children:"a"})," yet. And\r\nby our rule that a variable expression always resolves to the same variable,\r\nthat implies the second call to ",(0,r.jsx)(n.code,{children:"showA()"})," should print the same thing."]}),"\n",(0,r.jsx)(n.p,{children:"Alas, it prints:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"global\r\nblock\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Let me stress that this program never reassigns any variable and contains only a\r\nsingle ",(0,r.jsx)(n.code,{children:"print"})," statement. Yet, somehow, that ",(0,r.jsx)(n.code,{children:"print"})," statement for a\r\nnever-assigned variable prints two different values at different points in time.\r\nWe definitely broke something somewhere."]}),"\n",(0,r.jsx)(n.h3,{id:"scopes-and-mutable-environments",children:"Scopes and mutable environments"}),"\n",(0,r.jsx)(n.p,{children:"In our interpreter, environments are the dynamic manifestation of static scopes.\r\nThe two mostly stay in sync with each other -- we create a new environment when\r\nwe enter a new scope, and discard it when we leave the scope. There is one other\r\noperation we perform on environments: binding a variable in one. This is where\r\nour bug lies."}),"\n",(0,r.jsxs)(n.p,{children:["Let's walk through that problematic example and see what the environments look\r\nlike at each step. First, we declare ",(0,r.jsx)(n.code,{children:"a"})," in the global scope."]}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/environment-1.png",alt:"The global environment with 'a' defined in it."}),"\n",(0,r.jsxs)(n.p,{children:["That gives us a single environment with a single variable in it. Then we enter\r\nthe block and execute the declaration of ",(0,r.jsx)(n.code,{children:"showA()"}),"."]}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/environment-2.png",alt:"A block environment linking to the global one."}),"\n",(0,r.jsxs)(n.p,{children:["We get a new environment for the block. In that, we declare one name, ",(0,r.jsx)(n.code,{children:"showA"}),",\r\nwhich is bound to the LoxFunction object we create to represent the function.\r\nThat object has a ",(0,r.jsx)(n.code,{children:"closure"})," field that captures the environment where the\r\nfunction was declared, so it has a reference back to the environment for the\r\nblock."]}),"\n",(0,r.jsxs)(n.p,{children:["Now we call ",(0,r.jsx)(n.code,{children:"showA()"}),"."]}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/environment-3.png",alt:"An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the global environment."}),"\n",(0,r.jsxs)(n.p,{children:["The interpreter dynamically creates a new environment for the function body of\r\n",(0,r.jsx)(n.code,{children:"showA()"}),". It's empty since that function doesn't declare any variables. The\r\nparent of that environment is the function's closure -- the outer block\r\nenvironment."]}),"\n",(0,r.jsxs)(n.p,{children:["Inside the body of ",(0,r.jsx)(n.code,{children:"showA()"}),", we print the value of ",(0,r.jsx)(n.code,{children:"a"}),". The interpreter looks\r\nup this value by walking the chain of environments. It gets all the way\r\nto the global environment before finding it there and printing ",(0,r.jsx)(n.code,{children:'"global"'}),".\r\nGreat."]}),"\n",(0,r.jsxs)(n.p,{children:["Next, we declare the second ",(0,r.jsx)(n.code,{children:"a"}),", this time inside the block."]}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/environment-4.png",alt:"The block environment has both 'a' and 'showA' now."}),"\n",(0,r.jsxs)(n.p,{children:["It's in the same block -- the same scope -- as ",(0,r.jsx)(n.code,{children:"showA()"}),", so it goes into the\r\nsame environment, which is also the same environment ",(0,r.jsx)(n.code,{children:"showA()"}),"'s closure refers\r\nto. This is where it gets interesting. We call ",(0,r.jsx)(n.code,{children:"showA()"})," again."]}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/environment-5.png",alt:"An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the block environment."}),"\n",(0,r.jsxs)(n.p,{children:["We create a new empty environment for the body of ",(0,r.jsx)(n.code,{children:"showA()"})," again, wire it up to\r\nthat closure, and run the body. When the interpreter walks the chain of\r\nenvironments to find ",(0,r.jsx)(n.code,{children:"a"}),", it now discovers the ",(0,r.jsx)(n.em,{children:"new"})," ",(0,r.jsx)(n.code,{children:"a"})," in the block\r\nenvironment. Boo."]}),"\n",(0,r.jsx)(n.p,{children:"I chose to implement environments in a way that I hoped would agree with your\r\ninformal intuition around scopes. We tend to consider all of the code within a\r\nblock as being within the same scope, so our interpreter uses a single\r\nenvironment to represent that. Each environment is a mutable hash table. When a\r\nnew local variable is declared, it gets added to the existing environment for\r\nthat scope."}),"\n",(0,r.jsx)(n.p,{children:"That intuition, like many in life, isn't quite right. A block is not necessarily\r\nall the same scope. Consider:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"{\r\n  var a;\r\n  // 1.\r\n  var b;\r\n  // 2.\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["At the first marked line, only ",(0,r.jsx)(n.code,{children:"a"})," is in scope. At the second line, both ",(0,r.jsx)(n.code,{children:"a"})," and\r\n",(0,r.jsx)(n.code,{children:"b"})," are. If you define a \"scope\" to be a set of declarations, then those are\r\nclearly not the same scope -- they don't contain the same declarations. It's\r\nlike each ",(0,r.jsx)(n.code,{children:"var"})," statement ",(0,r.jsx)(n.span,{name:"split",children:"splits"})," the block into two\r\nseparate scopes, the scope before the variable is declared and the one after,\r\nwhich includes the new variable."]}),"\n",(0,r.jsxs)(n.aside,{name:"split",children:["\n",(0,r.jsxs)(n.p,{children:["Some languages make this split explicit. In Scheme and ML, when you declare a\r\nlocal variable using ",(0,r.jsx)(n.code,{children:"let"}),', you also delineate the subsequent code where the new\r\nvariable is in scope. There is no implicit "rest of the block".']}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["But in our implementation, environments do act like the entire block is one\r\nscope, just a scope that changes over time. Closures do not like that. When a\r\nfunction is declared, it captures a reference to the current environment. The\r\nfunction ",(0,r.jsx)(n.em,{children:"should"})," capture a frozen snapshot of the environment ",(0,r.jsx)(n.em,{children:"as it existed at\r\nthe moment the function was declared"}),". But instead, in the Java code, it has a\r\nreference to the actual mutable environment object. When a variable is later\r\ndeclared in the scope that environment corresponds to, the closure sees the new\r\nvariable, even though the declaration does ",(0,r.jsx)(n.em,{children:"not"})," precede the function."]}),"\n",(0,r.jsx)(n.h3,{id:"persistent-environments",children:"Persistent environments"}),"\n",(0,r.jsxs)(n.p,{children:["There is a style of programming that uses what are called ",(0,r.jsx)(n.strong,{children:"persistent data\r\nstructures"}),'. Unlike the squishy data structures you\'re familiar with in\r\nimperative programming, a persistent data structure can never be directly\r\nmodified. Instead, any "modification" to an existing structure produces a ',(0,r.jsx)(n.span,{name:"copy",children:"brand"})," new object that contains all of the original data and\r\nthe new modification. The original is left unchanged."]}),"\n",(0,r.jsxs)(n.aside,{name:"copy",children:["\n",(0,r.jsx)(n.p,{children:'This sounds like it might waste tons of memory and time copying the structure\r\nfor each operation. In practice, persistent data structures share most of their\r\ndata between the different "copies".'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If we were to apply that technique to Environment, then every time you declared\r\na variable it would return a ",(0,r.jsx)(n.em,{children:"new"}),' environment that contained all of the\r\npreviously declared variables along with the one new name. Declaring a variable\r\nwould do the implicit "split" where you have an environment before the variable\r\nis declared and one after:']}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/split.png",alt:"Separate environments before and after the variable is declared."}),"\n",(0,r.jsx)(n.p,{children:"A closure retains a reference to the Environment instance in play when the\r\nfunction was declared. Since any later declarations in that block would produce\r\nnew Environment objects, the closure wouldn't see the new variables and our bug\r\nwould be fixed."}),"\n",(0,r.jsx)(n.p,{children:"This is a legit way to solve the problem, and it's the classic way to implement\r\nenvironments in Scheme interpreters. We could do that for Lox, but it would mean\r\ngoing back and changing a pile of existing code."}),"\n",(0,r.jsxs)(n.p,{children:["I won't drag you through that. We'll keep the way we represent environments the\r\nsame. Instead of making the data more statically structured, we'll bake the\r\nstatic resolution into the access ",(0,r.jsx)(n.em,{children:"operation"})," itself."]}),"\n",(0,r.jsx)(n.h2,{id:"semantic-analysis",children:"Semantic Analysis"}),"\n",(0,r.jsxs)(n.p,{children:["Our interpreter ",(0,r.jsx)(n.strong,{children:"resolves"})," a variable -- tracks down which declaration it\r\nrefers to -- each and every time the variable expression is evaluated. If that\r\nvariable is swaddled inside a loop that runs a thousand times, that variable\r\ngets re-resolved a thousand times."]}),"\n",(0,r.jsx)(n.p,{children:"We know static scope means that a variable usage always resolves to the same\r\ndeclaration, which can be determined just by looking at the text. Given that,\r\nwhy are we doing it dynamically every time? Doing so doesn't just open the hole\r\nthat leads to our annoying bug, it's also needlessly slow."}),"\n",(0,r.jsxs)(n.p,{children:["A better solution is to resolve each variable use ",(0,r.jsx)(n.em,{children:"once"}),". Write a chunk of code\r\nthat inspects the user's program, finds every variable mentioned, and figures\r\nout which declaration each refers to. This process is an example of a ",(0,r.jsx)(n.strong,{children:"semantic\r\nanalysis"}),". Where a parser tells only if a program is grammatically correct (a\r\n",(0,r.jsx)(n.em,{children:"syntactic"})," analysis), semantic analysis goes farther and starts to figure out\r\nwhat pieces of the program actually mean. In this case, our analysis will\r\nresolve variable bindings. We'll know not just that an expression ",(0,r.jsx)(n.em,{children:"is"})," a\r\nvariable, but ",(0,r.jsx)(n.em,{children:"which"})," variable it is."]}),"\n",(0,r.jsxs)(n.p,{children:["There are a lot of ways we could store the binding between a variable and its\r\ndeclaration. When we get to the C interpreter for Lox, we'll have a ",(0,r.jsx)(n.em,{children:"much"})," more\r\nefficient way of storing and accessing local variables. But for jlox, I want to\r\nminimize the collateral damage we inflict on our existing codebase. I'd hate to\r\nthrow out a bunch of mostly fine code."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, we'll store the resolution in a way that makes the most out of our\r\nexisting Environment class. Recall how the accesses of ",(0,r.jsx)(n.code,{children:"a"})," are interpreted in\r\nthe problematic example."]}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/environment-3.png",alt:"An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the global environment."}),"\n",(0,r.jsxs)(n.p,{children:["In the first (correct) evaluation, we look at three environments in the chain\r\nbefore finding the global declaration of ",(0,r.jsx)(n.code,{children:"a"}),". Then, when the inner ",(0,r.jsx)(n.code,{children:"a"})," is later\r\ndeclared in a block scope, it shadows the global one."]}),"\n",(0,r.jsx)(n.img,{src:"image/resolving-and-binding/environment-5.png",alt:"An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the block environment."}),"\n",(0,r.jsxs)(n.p,{children:["The next lookup walks the chain, finds ",(0,r.jsx)(n.code,{children:"a"})," in the ",(0,r.jsx)(n.em,{children:"second"})," environment and\r\nstops there. Each environment corresponds to a single lexical scope where\r\nvariables are declared. If we could ensure a variable lookup always walked the\r\n",(0,r.jsx)(n.em,{children:"same"})," number of links in the environment chain, that would ensure that it\r\nfound the same variable in the same scope every time."]}),"\n",(0,r.jsxs)(n.p,{children:['To "resolve" a variable usage, we only need to calculate how many "hops" away\r\nthe declared variable will be in the environment chain. The interesting question\r\nis ',(0,r.jsx)(n.em,{children:"when"})," to do this calculation -- or, put differently, where in our\r\ninterpreter's implementation do we stuff the code for it?"]}),"\n",(0,r.jsx)(n.p,{children:"Since we're calculating a static property based on the structure of the source\r\ncode, the obvious answer is in the parser. That is the traditional home, and is\r\nwhere we'll put it later in clox. It would work here too, but I want an excuse to\r\nshow you another technique. We'll write our resolver as a separate pass."}),"\n",(0,r.jsx)(n.h3,{id:"a-variable-resolution-pass",children:"A variable resolution pass"}),"\n",(0,r.jsx)(n.p,{children:"After the parser produces the syntax tree, but before the interpreter starts\r\nexecuting it, we'll do a single walk over the tree to resolve all of the\r\nvariables it contains. Additional passes between parsing and execution are\r\ncommon. If Lox had static types, we could slide a type checker in there.\r\nOptimizations are often implemented in separate passes like this too. Basically,\r\nany work that doesn't rely on state that's only available at runtime can be done\r\nin this way."}),"\n",(0,r.jsx)(n.p,{children:"Our variable resolution pass works like a sort of mini-interpreter. It walks the\r\ntree, visiting each node, but a static analysis is different from a dynamic\r\nexecution:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"There are no side effects."})," When the static analysis visits a print\r\nstatement, it doesn't actually print anything. Calls to native functions or\r\nother operations that reach out to the outside world are stubbed out and\r\nhave no effect."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"There is no control flow."})," Loops are visited only ",(0,r.jsx)(n.span,{name:"fix",children:"once"}),". Both branches are visited in ",(0,r.jsx)(n.code,{children:"if"})," statements. Logic\r\noperators are not short-circuited."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.aside,{name:"fix",children:["\n",(0,r.jsxs)(n.p,{children:["Variable resolution touches each node once, so its performance is ",(0,r.jsx)(n.em,{children:"O(n)"})," where\r\n",(0,r.jsx)(n.em,{children:"n"})," is the number of syntax tree nodes. More sophisticated analyses may have\r\ngreater complexity, but most are carefully designed to be linear or not far from\r\nit. It's an embarrassing faux pas if your compiler gets exponentially slower as\r\nthe user's program grows."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"a-resolver-class",children:"A Resolver Class"}),"\n",(0,r.jsx)(n.p,{children:"Like everything in Java, our variable resolution pass is embodied in a class."}),"\n",(0,r.jsx)(n.p,{children:"^code resolver"}),"\n",(0,r.jsx)(n.p,{children:"Since the resolver needs to visit every node in the syntax tree, it implements\r\nthe visitor abstraction we already have in place. Only a few kinds of nodes are\r\ninteresting when it comes to resolving variables:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A block statement introduces a new scope for the statements it contains."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A function declaration introduces a new scope for its body and binds its\r\nparameters in that scope."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A variable declaration adds a new variable to the current scope."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Variable and assignment expressions need to have their variables resolved."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The rest of the nodes don't do anything special, but we still need to implement\r\nvisit methods for them that traverse into their subtrees. Even though a ",(0,r.jsx)(n.code,{children:"+"}),"\r\nexpression doesn't ",(0,r.jsx)(n.em,{children:"itself"})," have any variables to resolve, either of its\r\noperands might."]}),"\n",(0,r.jsx)(n.h3,{id:"resolving-blocks",children:"Resolving blocks"}),"\n",(0,r.jsx)(n.p,{children:"We start with blocks since they create the local scopes where all the magic\r\nhappens."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-block-stmt"}),"\n",(0,r.jsx)(n.p,{children:"This begins a new scope, traverses into the statements inside the block, and\r\nthen discards the scope. The fun stuff lives in those helper methods. We start\r\nwith the simple one."}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-statements"}),"\n",(0,r.jsx)(n.p,{children:"This walks a list of statements and resolves each one. It in turn calls:"}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-stmt"}),"\n",(0,r.jsx)(n.p,{children:"While we're at it, let's add another overload that we'll need later for\r\nresolving an expression."}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-expr"}),"\n",(0,r.jsxs)(n.p,{children:["These methods are similar to the ",(0,r.jsx)(n.code,{children:"evaluate()"})," and ",(0,r.jsx)(n.code,{children:"execute()"})," methods in\r\nInterpreter -- they turn around and apply the Visitor pattern to the given\r\nsyntax tree node."]}),"\n",(0,r.jsx)(n.p,{children:"The real interesting behavior is around scopes. A new block scope is created\r\nlike so:"}),"\n",(0,r.jsx)(n.p,{children:"^code begin-scope"}),"\n",(0,r.jsx)(n.p,{children:"Lexical scopes nest in both the interpreter and the resolver. They behave like a\r\nstack. The interpreter implements that stack using a linked list -- the chain of\r\nEnvironment objects. In the resolver, we use an actual Java Stack."}),"\n",(0,r.jsx)(n.p,{children:"^code scopes-field (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"This field keeps track of the stack of scopes currently, uh, in scope. Each\r\nelement in the stack is a Map representing a single block scope. Keys, as in\r\nEnvironment, are variable names. The values are Booleans, for a reason I'll\r\nexplain soon."}),"\n",(0,r.jsx)(n.p,{children:"The scope stack is only used for local block scopes. Variables declared at the\r\ntop level in the global scope are not tracked by the resolver since they are\r\nmore dynamic in Lox. When resolving a variable, if we can't find it in the stack\r\nof local scopes, we assume it must be global."}),"\n",(0,r.jsx)(n.p,{children:"Since scopes are stored in an explicit stack, exiting one is straightforward."}),"\n",(0,r.jsx)(n.p,{children:"^code end-scope"}),"\n",(0,r.jsx)(n.p,{children:"Now we can push and pop a stack of empty scopes. Let's put some things in them."}),"\n",(0,r.jsx)(n.h3,{id:"resolving-variable-declarations",children:"Resolving variable declarations"}),"\n",(0,r.jsx)(n.p,{children:"Resolving a variable declaration adds a new entry to the current innermost\r\nscope's map. That seems simple, but there's a little dance we need to do."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-var-stmt"}),"\n",(0,r.jsx)(n.p,{children:"We split binding into two steps, declaring then defining, in order to handle\r\nfunny edge cases like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var a = "outer";\r\n{\r\n  var a = a;\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"What happens when the initializer for a local variable refers to a variable with\r\nthe same name as the variable being declared? We have a few options:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Run the initializer, then put the new variable in scope."})," Here, the new\r\nlocal ",(0,r.jsx)(n.code,{children:"a"}),' would be initialized with "outer", the value of the ',(0,r.jsx)(n.em,{children:"global"})," one.\r\nIn other words, the previous declaration would desugar to:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"var temp = a; // Run the initializer.\r\nvar a;        // Declare the variable.\r\na = temp;     // Initialize it.\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Put the new variable in scope, then run the initializer."})," This means you\r\ncould observe a variable before it's initialized, so we would need to figure\r\nout what value it would have then. Probably ",(0,r.jsx)(n.code,{children:"nil"}),". That means the new local\r\n",(0,r.jsx)(n.code,{children:"a"})," would be re-initialized to its own implicitly initialized value, ",(0,r.jsx)(n.code,{children:"nil"}),".\r\nNow the desugaring would look like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:"var a; // Define the variable.\r\na = a; // Run the initializer.\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Make it an error to reference a variable in its initializer."})," Have the\r\ninterpreter fail either at compile time or runtime if an initializer\r\nmentions the variable being initialized."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Do either of those first two options look like something a user actually\r\n",(0,r.jsx)(n.em,{children:"wants"}),"? Shadowing is rare and often an error, so initializing a shadowing\r\nvariable based on the value of the shadowed one seems unlikely to be deliberate."]}),"\n",(0,r.jsxs)(n.p,{children:["The second option is even less useful. The new variable will ",(0,r.jsx)(n.em,{children:"always"})," have the\r\nvalue ",(0,r.jsx)(n.code,{children:"nil"}),". There is never any point in mentioning it by name. You could use an\r\nexplicit ",(0,r.jsx)(n.code,{children:"nil"})," instead."]}),"\n",(0,r.jsx)(n.p,{children:"Since the first two options are likely to mask user errors, we'll take the\r\nthird. Further, we'll make it a compile error instead of a runtime one. That\r\nway, the user is alerted to the problem before any code is run."}),"\n",(0,r.jsxs)(n.p,{children:["In order to do that, as we visit expressions, we need to know if we're inside\r\nthe initializer for some variable. We do that by splitting binding into two\r\nsteps. The first is ",(0,r.jsx)(n.strong,{children:"declaring"})," it."]}),"\n",(0,r.jsx)(n.p,{children:"^code declare"}),"\n",(0,r.jsxs)(n.p,{children:['Declaration adds the variable to the innermost scope so that it shadows any\r\nouter one and so that we know the variable exists. We mark it as "not ready yet"\r\nby binding its name to ',(0,r.jsx)(n.code,{children:"false"})," in the scope map. The value associated with a key\r\nin the scope map represents whether or not we have finished resolving that\r\nvariable's initializer."]}),"\n",(0,r.jsxs)(n.p,{children:["After declaring the variable, we resolve its initializer expression in that same\r\nscope where the new variable now exists but is unavailable. Once the initializer\r\nexpression is done, the variable is ready for prime time. We do that by\r\n",(0,r.jsx)(n.strong,{children:"defining"})," it."]}),"\n",(0,r.jsx)(n.p,{children:"^code define"}),"\n",(0,r.jsxs)(n.p,{children:["We set the variable's value in the scope map to ",(0,r.jsx)(n.code,{children:"true"})," to mark it as fully\r\ninitialized and available for use. It's alive!"]}),"\n",(0,r.jsx)(n.h3,{id:"resolving-variable-expressions",children:"Resolving variable expressions"}),"\n",(0,r.jsx)(n.p,{children:"Variable declarations -- and function declarations, which we'll get to -- write\r\nto the scope maps. Those maps are read when we resolve variable expressions."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-variable-expr"}),"\n",(0,r.jsxs)(n.p,{children:["First, we check to see if the variable is being accessed inside its own\r\ninitializer. This is where the values in the scope map come into play. If the\r\nvariable exists in the current scope but its value is ",(0,r.jsx)(n.code,{children:"false"}),", that means we\r\nhave declared it but not yet defined it. We report that error."]}),"\n",(0,r.jsx)(n.p,{children:"After that check, we actually resolve the variable itself using this helper:"}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-local"}),"\n",(0,r.jsx)(n.p,{children:"This looks, for good reason, a lot like the code in Environment for evaluating a\r\nvariable. We start at the innermost scope and work outwards, looking in each map\r\nfor a matching name. If we find the variable, we resolve it, passing in the\r\nnumber of scopes between the current innermost scope and the scope where the\r\nvariable was found. So, if the variable was found in the current scope, we\r\npass in 0. If it's in the immediately enclosing scope, 1. You get the idea."}),"\n",(0,r.jsxs)(n.p,{children:["If we walk through all of the block scopes and never find the variable, we leave\r\nit unresolved and assume it's global. We'll get to the implementation of that\r\n",(0,r.jsx)(n.code,{children:"resolve()"})," method a little later. For now, let's keep on cranking through the\r\nother syntax nodes."]}),"\n",(0,r.jsx)(n.h3,{id:"resolving-assignment-expressions",children:"Resolving assignment expressions"}),"\n",(0,r.jsx)(n.p,{children:"The other expression that references a variable is assignment. Resolving one\r\nlooks like this:"}),"\n",(0,r.jsx)(n.p,{children:"^code visit-assign-expr"}),"\n",(0,r.jsxs)(n.p,{children:["First, we resolve the expression for the assigned value in case it also contains\r\nreferences to other variables. Then we use our existing ",(0,r.jsx)(n.code,{children:"resolveLocal()"})," method\r\nto resolve the variable that's being assigned to."]}),"\n",(0,r.jsx)(n.h3,{id:"resolving-function-declarations",children:"Resolving function declarations"}),"\n",(0,r.jsx)(n.p,{children:"Finally, functions. Functions both bind names and introduce a scope. The name of\r\nthe function itself is bound in the surrounding scope where the function is\r\ndeclared. When we step into the function's body, we also bind its parameters\r\ninto that inner function scope."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-function-stmt"}),"\n",(0,r.jsxs)(n.p,{children:["Similar to ",(0,r.jsx)(n.code,{children:"visitVariableStmt()"}),", we declare and define the name of the function\r\nin the current scope. Unlike variables, though, we define the name eagerly,\r\nbefore resolving the function's body. This lets a function recursively refer to\r\nitself inside its own body."]}),"\n",(0,r.jsx)(n.p,{children:"Then we resolve the function's body using this:"}),"\n",(0,r.jsx)(n.p,{children:"^code resolve-function"}),"\n",(0,r.jsx)(n.p,{children:"It's a separate method since we will also use it for resolving Lox methods when\r\nwe add classes later. It creates a new scope for the body and then binds\r\nvariables for each of the function's parameters."}),"\n",(0,r.jsxs)(n.p,{children:["Once that's ready, it resolves the function body in that scope. This is\r\ndifferent from how the interpreter handles function declarations. At ",(0,r.jsx)(n.em,{children:"runtime"}),",\r\ndeclaring a function doesn't do anything with the function's body. The body\r\ndoesn't get touched until later when the function is called. In a ",(0,r.jsx)(n.em,{children:"static"}),"\r\nanalysis, we immediately traverse into the body right then and there."]}),"\n",(0,r.jsx)(n.h3,{id:"resolving-the-other-syntax-tree-nodes",children:"Resolving the other syntax tree nodes"}),"\n",(0,r.jsxs)(n.p,{children:["That covers the interesting corners of the grammars. We handle every place where\r\na variable is declared, read, or written, and every place where a scope is\r\ncreated or destroyed. Even though they aren't affected by variable resolution,\r\nwe also need visit methods for all of the other syntax tree nodes in order to\r\nrecurse into their subtrees. ",(0,r.jsx)(n.span,{name:"boring",children:"Sorry"}),' this bit is\r\nboring, but bear with me. We\'ll go kind of "top down" and start with statements.']}),"\n",(0,r.jsxs)(n.aside,{name:"boring",children:["\n",(0,r.jsx)(n.p,{children:"I did say the book would have every single line of code for these interpreters.\r\nI didn't say they'd all be exciting."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"An expression statement contains a single expression to traverse."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-expression-stmt"}),"\n",(0,r.jsx)(n.p,{children:"An if statement has an expression for its condition and one or two statements\r\nfor the branches."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-if-stmt"}),"\n",(0,r.jsxs)(n.p,{children:["Here, we see how resolution is different from interpretation. When we resolve an\r\n",(0,r.jsx)(n.code,{children:"if"})," statement, there is no control flow. We resolve the condition and ",(0,r.jsx)(n.em,{children:"both"}),"\r\nbranches. Where a dynamic execution steps only into the branch that ",(0,r.jsx)(n.em,{children:"is"})," run, a\r\nstatic analysis is conservative -- it analyzes any branch that ",(0,r.jsx)(n.em,{children:"could"})," be run.\r\nSince either one could be reached at runtime, we resolve both."]}),"\n",(0,r.jsxs)(n.p,{children:["Like expression statements, a ",(0,r.jsx)(n.code,{children:"print"})," statement contains a single subexpression."]}),"\n",(0,r.jsx)(n.p,{children:"^code visit-print-stmt"}),"\n",(0,r.jsx)(n.p,{children:"Same deal for return."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-return-stmt"}),"\n",(0,r.jsxs)(n.p,{children:["As in ",(0,r.jsx)(n.code,{children:"if"})," statements, with a ",(0,r.jsx)(n.code,{children:"while"})," statement, we resolve its condition and\r\nresolve the body exactly once."]}),"\n",(0,r.jsx)(n.p,{children:"^code visit-while-stmt"}),"\n",(0,r.jsx)(n.p,{children:"That covers all the statements. On to expressions..."}),"\n",(0,r.jsx)(n.p,{children:"Our old friend the binary expression. We traverse into and resolve both\r\noperands."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-binary-expr"}),"\n",(0,r.jsx)(n.p,{children:"Calls are similar -- we walk the argument list and resolve them all. The thing\r\nbeing called is also an expression (usually a variable expression), so that gets\r\nresolved too."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-call-expr"}),"\n",(0,r.jsx)(n.p,{children:"Parentheses are easy."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-grouping-expr"}),"\n",(0,r.jsx)(n.p,{children:"Literals are easiest of all."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-literal-expr"}),"\n",(0,r.jsx)(n.p,{children:"A literal expression doesn't mention any variables and doesn't contain any\r\nsubexpressions so there is no work to do."}),"\n",(0,r.jsx)(n.p,{children:"Since a static analysis does no control flow or short-circuiting, logical\r\nexpressions are exactly the same as other binary operators."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-logical-expr"}),"\n",(0,r.jsx)(n.p,{children:"And, finally, the last node. We resolve its one operand."}),"\n",(0,r.jsx)(n.p,{children:"^code visit-unary-expr"}),"\n",(0,r.jsx)(n.p,{children:"With all of these visit methods, the Java compiler should be satisfied that\r\nResolver fully implements Stmt.Visitor and Expr.Visitor. Now is a good time to\r\ntake a break, have a snack, maybe a little nap."}),"\n",(0,r.jsx)(n.h2,{id:"interpreting-resolved-variables",children:"Interpreting Resolved Variables"}),"\n",(0,r.jsxs)(n.p,{children:["Let's see what our resolver is good for. Each time it visits a variable, it\r\ntells the interpreter how many scopes there are between the current scope and\r\nthe scope where the variable is defined. At runtime, this corresponds exactly to\r\nthe number of ",(0,r.jsx)(n.em,{children:"environments"})," between the current one and the enclosing one where\r\nthe interpreter can find the variable's value. The resolver hands that number to\r\nthe interpreter by calling this:"]}),"\n",(0,r.jsx)(n.p,{children:"^code resolve"}),"\n",(0,r.jsx)(n.p,{children:"We want to store the resolution information somewhere so we can use it when the\r\nvariable or assignment expression is later executed, but where? One obvious\r\nplace is right in the syntax tree node itself. That's a fine approach, and\r\nthat's where many compilers store the results of analyses like this."}),"\n",(0,r.jsxs)(n.p,{children:["We could do that, but it would require mucking around with our syntax tree\r\ngenerator. Instead, we'll take another common approach and store it off to the\r\n",(0,r.jsx)(n.span,{name:"side",children:"side"})," in a map that associates each syntax tree node\r\nwith its resolved data."]}),"\n",(0,r.jsxs)(n.aside,{name:"side",children:["\n",(0,r.jsxs)(n.p,{children:["I ",(0,r.jsx)(n.em,{children:"think"})," I've heard this map called a \"side table\" since it's a tabular data\r\nstructure that stores data separately from the objects it relates to. But\r\nwhenever I try to Google for that term, I get pages about furniture."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Interactive tools like IDEs often incrementally reparse and re-resolve parts of\r\nthe user's program. It may be hard to find all of the bits of state that need\r\nrecalculating when they're hiding in the foliage of the syntax tree. A benefit\r\nof storing this data outside of the nodes is that it makes it easy to ",(0,r.jsx)(n.em,{children:"discard"}),"\r\nit -- simply clear the map."]}),"\n",(0,r.jsx)(n.p,{children:"^code locals-field (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"You might think we'd need some sort of nested tree structure to avoid getting\r\nconfused when there are multiple expressions that reference the same variable,\r\nbut each expression node is its own Java object with its own unique identity. A\r\nsingle monolithic map doesn't have any trouble keeping them separated."}),"\n",(0,r.jsx)(n.p,{children:"As usual, using a collection requires us to import a couple of names."}),"\n",(0,r.jsx)(n.p,{children:"^code import-hash-map (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"And:"}),"\n",(0,r.jsx)(n.p,{children:"^code import-map (1 before, 2 after)"}),"\n",(0,r.jsx)(n.h3,{id:"accessing-a-resolved-variable",children:"Accessing a resolved variable"}),"\n",(0,r.jsx)(n.p,{children:"Our interpreter now has access to each variable's resolved location. Finally, we\r\nget to make use of that. We replace the visit method for variable expressions\r\nwith this:"}),"\n",(0,r.jsx)(n.p,{children:"^code call-look-up-variable (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"That delegates to:"}),"\n",(0,r.jsx)(n.p,{children:"^code look-up-variable"}),"\n",(0,r.jsxs)(n.p,{children:["There are a couple of things going on here. First, we look up the resolved\r\ndistance in the map. Remember that we resolved only ",(0,r.jsx)(n.em,{children:"local"})," variables. Globals\r\nare treated specially and don't end up in the map (hence the name ",(0,r.jsx)(n.code,{children:"locals"}),"). So,\r\nif we don't find a distance in the map, it must be global. In that case, we\r\nlook it up, dynamically, directly in the global environment. That throws a\r\nruntime error if the variable isn't defined."]}),"\n",(0,r.jsxs)(n.p,{children:["If we ",(0,r.jsx)(n.em,{children:"do"})," get a distance, we have a local variable, and we get to take\r\nadvantage of the results of our static analysis. Instead of calling ",(0,r.jsx)(n.code,{children:"get()"}),", we\r\ncall this new method on Environment:"]}),"\n",(0,r.jsx)(n.p,{children:"^code get-at"}),"\n",(0,r.jsxs)(n.p,{children:["The old ",(0,r.jsx)(n.code,{children:"get()"})," method dynamically walks the chain of enclosing environments,\r\nscouring each one to see if the variable might be hiding in there somewhere. But\r\nnow we know exactly which environment in the chain will have the variable. We\r\nreach it using this helper method:"]}),"\n",(0,r.jsx)(n.p,{children:"^code ancestor"}),"\n",(0,r.jsxs)(n.p,{children:["This walks a fixed number of hops up the parent chain and returns the\r\nenvironment there. Once we have that, ",(0,r.jsx)(n.code,{children:"getAt()"})," simply returns the value of the\r\nvariable in that environment's map. It doesn't even have to check to see if the\r\nvariable is there -- we know it will be because the resolver already found it\r\nbefore."]}),"\n",(0,r.jsxs)(n.aside,{name:"coupled",children:["\n",(0,r.jsx)(n.p,{children:"The way the interpreter assumes the variable is in that map feels like flying\r\nblind. The interpreter code trusts that the resolver did its job and resolved\r\nthe variable correctly. This implies a deep coupling between these two classes.\r\nIn the resolver, each line of code that touches a scope must have its exact\r\nmatch in the interpreter for modifying an environment."}),"\n",(0,r.jsx)(n.p,{children:"I felt that coupling firsthand because as I wrote the code for the book, I\r\nran into a couple of subtle bugs where the resolver and interpreter code were\r\nslightly out of sync. Tracking those down was difficult. One tool to make that\r\neasier is to have the interpreter explicitly assert -- using Java's assert\r\nstatements or some other validation tool -- the contract it expects the resolver\r\nto have already upheld."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"assigning-to-a-resolved-variable",children:"Assigning to a resolved variable"}),"\n",(0,r.jsx)(n.p,{children:"We can also use a variable by assigning to it. The changes to visiting an\r\nassignment expression are similar."}),"\n",(0,r.jsx)(n.p,{children:"^code resolved-assign (2 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Again, we look up the variable's scope distance. If not found, we assume it's\r\nglobal and handle it the same way as before. Otherwise, we call this new method:"}),"\n",(0,r.jsx)(n.p,{children:"^code assign-at"}),"\n",(0,r.jsxs)(n.p,{children:["As ",(0,r.jsx)(n.code,{children:"getAt()"})," is to ",(0,r.jsx)(n.code,{children:"get()"}),", ",(0,r.jsx)(n.code,{children:"assignAt()"})," is to ",(0,r.jsx)(n.code,{children:"assign()"}),". It walks a fixed\r\nnumber of environments, and then stuffs the new value in that map."]}),"\n",(0,r.jsx)(n.p,{children:"Those are the only changes to Interpreter. This is why I chose a representation\r\nfor our resolved data that was minimally invasive. All of the rest of the nodes\r\ncontinue working as they did before. Even the code for modifying environments is\r\nunchanged."}),"\n",(0,r.jsx)(n.h3,{id:"running-the-resolver",children:"Running the resolver"}),"\n",(0,r.jsxs)(n.p,{children:["We do need to actually ",(0,r.jsx)(n.em,{children:"run"})," the resolver, though. We insert the new pass after\r\nthe parser does its magic."]}),"\n",(0,r.jsx)(n.p,{children:"^code create-resolver (3 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"We don't run the resolver if there are any parse errors. If the code has a\r\nsyntax error, it's never going to run, so there's little value in resolving it.\r\nIf the syntax is clean, we tell the resolver to do its thing. The resolver has a\r\nreference to the interpreter and pokes the resolution data directly into it as\r\nit walks over variables. When the interpreter runs next, it has everything it\r\nneeds."}),"\n",(0,r.jsxs)(n.p,{children:["At least, that's true if the resolver ",(0,r.jsx)(n.em,{children:"succeeds"}),". But what about errors during\r\nresolution?"]}),"\n",(0,r.jsx)(n.h2,{id:"resolution-errors",children:"Resolution Errors"}),"\n",(0,r.jsx)(n.p,{children:"Since we are doing a semantic analysis pass, we have an opportunity to make\r\nLox's semantics more precise, and to help users catch bugs early before running\r\ntheir code. Take a look at this bad boy:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'fun bad() {\r\n  var a = "first";\r\n  var a = "second";\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We do allow declaring multiple variables with the same name in the ",(0,r.jsx)(n.em,{children:"global"}),"\r\nscope, but doing so in a local scope is probably a mistake. If they knew the\r\nvariable already existed, they would have assigned to it instead of using ",(0,r.jsx)(n.code,{children:"var"}),".\r\nAnd if they ",(0,r.jsx)(n.em,{children:"didn't"})," know it existed, they probably didn't intend to overwrite\r\nthe previous one."]}),"\n",(0,r.jsx)(n.p,{children:"We can detect this mistake statically while resolving."}),"\n",(0,r.jsx)(n.p,{children:"^code duplicate-variable (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"When we declare a variable in a local scope, we already know the names of every\r\nvariable previously declared in that same scope. If we see a collision, we\r\nreport an error."}),"\n",(0,r.jsx)(n.h3,{id:"invalid-return-errors",children:"Invalid return errors"}),"\n",(0,r.jsx)(n.p,{children:"Here's another nasty little script:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'return "at top level";\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This executes a ",(0,r.jsx)(n.code,{children:"return"})," statement, but it's not even inside a function at all.\r\nIt's top-level code. I don't know what the user ",(0,r.jsx)(n.em,{children:"thinks"})," is going to happen, but\r\nI don't think we want Lox to allow this."]}),"\n",(0,r.jsx)(n.p,{children:"We can extend the resolver to detect this statically. Much like we track scopes\r\nas we walk the tree, we can track whether or not the code we are currently\r\nvisiting is inside a function declaration."}),"\n",(0,r.jsx)(n.p,{children:"^code function-type-field (1 before, 2 after)"}),"\n",(0,r.jsx)(n.p,{children:"Instead of a bare Boolean, we use this funny enum:"}),"\n",(0,r.jsx)(n.p,{children:"^code function-type"}),"\n",(0,r.jsx)(n.p,{children:"It seems kind of dumb now, but we'll add a couple more cases to it later and\r\nthen it will make more sense. When we resolve a function declaration, we pass\r\nthat in."}),"\n",(0,r.jsx)(n.p,{children:"^code pass-function-type (2 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Over in ",(0,r.jsx)(n.code,{children:"resolveFunction()"}),", we take that parameter and store it in the field\r\nbefore resolving the body."]}),"\n",(0,r.jsx)(n.p,{children:"^code set-current-function (1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["We stash the previous value of the field in a local variable first. Remember,\r\nLox has local functions, so you can nest function declarations arbitrarily\r\ndeeply. We need to track not just that we're in a function, but ",(0,r.jsx)(n.em,{children:"how many"})," we're\r\nin."]}),"\n",(0,r.jsx)(n.p,{children:"We could use an explicit stack of FunctionType values for that, but instead\r\nwe'll piggyback on the JVM. We store the previous value in a local on the Java\r\nstack. When we're done resolving the function body, we restore the field to that\r\nvalue."}),"\n",(0,r.jsx)(n.p,{children:"^code restore-current-function (1 before, 1 after)"}),"\n",(0,r.jsxs)(n.p,{children:["Now that we can always tell whether or not we're inside a function declaration,\r\nwe check that when resolving a ",(0,r.jsx)(n.code,{children:"return"})," statement."]}),"\n",(0,r.jsx)(n.p,{children:"^code return-from-top (1 before, 1 after)"}),"\n",(0,r.jsx)(n.p,{children:"Neat, right?"}),"\n",(0,r.jsxs)(n.p,{children:["There's one more piece. Back in the main Lox class that stitches everything\r\ntogether, we are careful to not run the interpreter if any parse errors are\r\nencountered. That check runs ",(0,r.jsx)(n.em,{children:"before"})," the resolver so that we don't try to\r\nresolve syntactically invalid code."]}),"\n",(0,r.jsxs)(n.p,{children:["But we also need to skip the interpreter if there are resolution errors, so we\r\nadd ",(0,r.jsx)(n.em,{children:"another"})," check."]}),"\n",(0,r.jsx)(n.p,{children:"^code resolution-error (1 before, 2 after)"}),"\n",(0,r.jsxs)(n.p,{children:["You could imagine doing lots of other analysis in here. For example, if we added\r\n",(0,r.jsx)(n.code,{children:"break"})," statements to Lox, we would probably want to ensure they are only used\r\ninside loops."]}),"\n",(0,r.jsxs)(n.p,{children:["We could go farther and report warnings for code that isn't necessarily ",(0,r.jsx)(n.em,{children:"wrong"}),"\r\nbut probably isn't useful. For example, many IDEs will warn if you have\r\nunreachable code after a ",(0,r.jsx)(n.code,{children:"return"})," statement, or a local variable whose value is\r\nnever read. All of that would be pretty easy to add to our static visiting pass,\r\nor as ",(0,r.jsx)(n.span,{name:"separate",children:"separate"})," passes."]}),"\n",(0,r.jsxs)(n.aside,{name:"separate",children:["\n",(0,r.jsx)(n.p,{children:"The choice of how many different analyses to lump into a single pass is\r\ndifficult. Many small isolated passes, each with their own responsibility, are\r\nsimpler to implement and maintain. However, there is a real runtime cost to\r\ntraversing the syntax tree itself, so bundling multiple analyses into a single\r\npass is usually faster."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"But, for now, we'll stick with that limited amount of analysis. The important\r\npart is that we fixed that one weird annoying edge case bug, though it might be\r\nsurprising that it took this much work to do it."}),"\n",(0,r.jsxs)(n.div,{className:"challenges",children:["\n",(0,r.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Why is it safe to eagerly define the variable bound to a function's name\r\nwhen other variables must wait until after they are initialized before they\r\ncan be used?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"How do other languages you know handle local variables that refer to the\r\nsame name in their initializer, like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lox",children:'var a = "outer";\r\n{\r\n  var a = a;\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Is it a runtime error? Compile error? Allowed? Do they treat global\r\nvariables differently? Do you agree with their choices? Justify your answer."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Extend the resolver to report an error if a local variable is never used."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Our resolver calculates ",(0,r.jsx)(n.em,{children:"which"})," environment the variable is found in, but\r\nit's still looked up by name in that map. A more efficient environment\r\nrepresentation would store local variables in an array and look them up by\r\nindex."]}),"\n",(0,r.jsx)(n.p,{children:"Extend the resolver to associate a unique index for each local variable\r\ndeclared in a scope. When resolving a variable access, look up both the\r\nscope the variable is in and its index and store that. In the interpreter,\r\nuse that to quickly access a variable by its index instead of using a map."}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);