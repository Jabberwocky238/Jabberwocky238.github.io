"use strict";(self.webpackChunkmybooks=self.webpackChunkmybooks||[]).push([[70],{2950:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=t(4848),r=t(8453);const i={},s=void 0,o={id:"Craftinginterpreters/not-translated-yet/local-variables",title:"local-variables",description:"And as imagination bodies forth",source:"@site/docs/Craftinginterpreters/not-translated-yet/local-variables.md",sourceDirName:"Craftinginterpreters/not-translated-yet",slug:"/Craftinginterpreters/not-translated-yet/local-variables",permalink:"/docs/Craftinginterpreters/not-translated-yet/local-variables",draft:!1,unlisted:!1,editUrl:"https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/local-variables.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"jumping-back-and-forth",permalink:"/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth"},next:{title:"methods-and-initializers",permalink:"/docs/Craftinginterpreters/not-translated-yet/methods-and-initializers"}},l={},c=[{value:"Representing Local Variables",id:"representing-local-variables",level:2},{value:"Block Statements",id:"block-statements",level:2},{value:"Declaring Local Variables",id:"declaring-local-variables",level:2},{value:"Using Locals",id:"using-locals",level:2},{value:"Interpreting local variables",id:"interpreting-local-variables",level:3},{value:"Another scope edge case",id:"another-scope-edge-case",level:3},{value:"Challenges",id:"challenges",level:2}];function h(e){const n={a:"a",aside:"aside",blockquote:"blockquote",br:"br",cite:"cite",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["And as imagination bodies forth",(0,a.jsx)(n.br,{}),"\r\nThe forms of things unknown, the poet's pen",(0,a.jsx)(n.br,{}),"\r\nTurns them to shapes and gives to airy nothing",(0,a.jsx)(n.br,{}),"\r\nA local habitation and a name."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.cite,{children:["William Shakespeare, ",(0,a.jsx)(n.em,{children:"A Midsummer Night's Dream"})]})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"global-variables.html",children:"last chapter"})," introduced variables to clox, but only of the ",(0,a.jsx)(n.span,{name:"global",children:"global"})," variety. In this chapter, we'll extend that to\r\nsupport blocks, block scope, and local variables. In jlox, we managed to pack\r\nall of that and globals into one chapter. For clox, that's two chapters worth of\r\nwork partially because, frankly, everything takes more effort in C."]}),"\n",(0,a.jsxs)(n.aside,{name:"global",children:["\n",(0,a.jsx)(n.p,{children:"There's probably some dumb \"think globally, act locally\" joke here, but I'm\r\nstruggling to find it."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:['But an even more important reason is that our approach to local variables will\r\nbe quite different from how we implemented globals. Global variables are late\r\nbound in Lox. "Late" in this context means "resolved after compile time". That\'s\r\ngood for keeping the compiler simple, but not great for performance. Local\r\nvariables are one of the most-used ',(0,a.jsx)(n.span,{name:"params",children:"parts"})," of a\r\nlanguage. If locals are slow, ",(0,a.jsx)(n.em,{children:"everything"})," is slow. So we want a strategy for\r\nlocal variables that's as efficient as possible."]}),"\n",(0,a.jsxs)(n.aside,{name:"params",children:["\n",(0,a.jsx)(n.p,{children:"Function parameters are also heavily used. They work like local variables too,\r\nso we'll use the same implementation technique for them."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Fortunately, lexical scoping is here to help us. As the name implies, lexical\r\nscope means we can resolve a local variable just by looking at the text of the\r\nprogram -- locals are ",(0,a.jsx)(n.em,{children:"not"})," late bound. Any processing work we do in the\r\ncompiler is work we ",(0,a.jsx)(n.em,{children:"don't"})," have to do at runtime, so our implementation of\r\nlocal variables will lean heavily on the compiler."]}),"\n",(0,a.jsx)(n.h2,{id:"representing-local-variables",children:"Representing Local Variables"}),"\n",(0,a.jsx)(n.p,{children:"The nice thing about hacking on a programming language in modern times is\r\nthere's a long lineage of other languages to learn from. So how do C and Java\r\nmanage their local variables? Why, on the stack, of course! They typically use\r\nthe native stack mechanisms supported by the chip and OS. That's a little too\r\nlow level for us, but inside the virtual world of clox, we have our own stack we\r\ncan use."}),"\n",(0,a.jsxs)(n.p,{children:["Right now, we only use it for holding on to ",(0,a.jsx)(n.strong,{children:"temporaries"})," -- short-lived blobs\r\nof data that we need to remember while computing an expression. As long as we\r\ndon't get in the way of those, we can stuff our local variables onto the stack\r\ntoo. This is great for performance. Allocating space for a new local requires\r\nonly incrementing the ",(0,a.jsx)(n.code,{children:"stackTop"})," pointer, and freeing is likewise a decrement.\r\nAccessing a variable from a known stack slot is an indexed array lookup."]}),"\n",(0,a.jsx)(n.p,{children:"We do need to be careful, though. The VM expects the stack to behave like, well,\r\na stack. We have to be OK with allocating new locals only on the top of the\r\nstack, and we have to accept that we can discard a local only when nothing is\r\nabove it on the stack. Also, we need to make sure temporaries don't interfere."}),"\n",(0,a.jsxs)(n.p,{children:["Conveniently, the design of Lox is in ",(0,a.jsx)(n.span,{name:"harmony",children:"harmony"})," with\r\nthese constraints. New locals are always created by declaration statements.\r\nStatements don't nest inside expressions, so there are never any temporaries on\r\nthe stack when a statement begins executing. Blocks are strictly nested. When a\r\nblock ends, it always takes the innermost, most recently declared locals with\r\nit. Since those are also the locals that came into scope last, they should be on\r\ntop of the stack where we need them."]}),"\n",(0,a.jsxs)(n.aside,{name:"harmony",children:["\n",(0,a.jsx)(n.p,{children:"This alignment obviously isn't coincidental. I designed Lox to be amenable to\r\nsingle-pass compilation to stack-based bytecode. But I didn't have to tweak the\r\nlanguage too much to fit in those restrictions. Most of its design should feel\r\npretty natural."}),"\n",(0,a.jsx)(n.p,{children:"This is in large part because the history of languages is deeply tied to\r\nsingle-pass compilation and -- to a lesser degree -- stack-based architectures.\r\nLox's block scoping follows a tradition stretching back to BCPL. As programmers,\r\nour intuition of what's \"normal\" in a language is informed even today by the\r\nhardware limitations of yesteryear."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Step through this example program and watch how the local variables come in and\r\ngo out of scope:"}),"\n",(0,a.jsx)(n.img,{src:"image/local-variables/scopes.png",alt:"A series of local variables come into and out of scope in a stack-like fashion."}),"\n",(0,a.jsxs)(n.p,{children:["See how they fit a stack perfectly? It seems that the stack will work for\r\nstoring locals at runtime. But we can go further than that. Not only do we know\r\n",(0,a.jsx)(n.em,{children:"that"})," they will be on the stack, but we can even pin down precisely ",(0,a.jsx)(n.em,{children:"where"}),"\r\nthey will be on the stack. Since the compiler knows exactly which local\r\nvariables are in scope at any point in time, it can effectively simulate the\r\nstack during compilation and note ",(0,a.jsx)(n.span,{name:"fn",children:"where"})," in the stack each\r\nvariable lives."]}),"\n",(0,a.jsx)(n.p,{children:"We'll take advantage of this by using these stack offsets as operands for the\r\nbytecode instructions that read and store local variables. This makes working\r\nwith locals deliciously fast -- as simple as indexing into an array."}),"\n",(0,a.jsxs)(n.aside,{name:"fn",children:["\n",(0,a.jsxs)(n.p,{children:["In this chapter, locals start at the bottom of the VM's stack array and are\r\nindexed from there. When we add ",(0,a.jsx)(n.a,{href:"calls-and-functions.html",children:"functions"}),", that scheme gets a little more\r\ncomplex. Each function needs its own region of the stack for its parameters and\r\nlocal variables. But, as we'll see, that doesn't add as much complexity as you\r\nmight expect."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"There's a lot of state we need to track in the compiler to make this whole thing\r\ngo, so let's get started there. In jlox, we used a linked chain of \"environment\"\r\nHashMaps to track which local variables were currently in scope. That's sort of\r\nthe classic, schoolbook way of representing lexical scope. For clox, as usual,\r\nwe're going a little closer to the metal. All of the state lives in a new\r\nstruct."}),"\n",(0,a.jsx)(n.p,{children:"^code compiler-struct (1 before, 2 after)"}),"\n",(0,a.jsxs)(n.p,{children:["We have a simple, flat array of all locals that are in scope during each point in\r\nthe compilation process. They are ",(0,a.jsx)(n.span,{name:"order",children:"ordered"})," in the array\r\nin the order that their declarations appear in the code. Since the instruction\r\noperand we'll use to encode a local is a single byte, our VM has a hard limit on\r\nthe number of locals that can be in scope at once. That means we can also give\r\nthe locals array a fixed size."]}),"\n",(0,a.jsxs)(n.aside,{name:"order",children:["\n",(0,a.jsxs)(n.p,{children:["We're writing a single-pass compiler, so it's not like we have ",(0,a.jsx)(n.em,{children:"too"})," many other\r\noptions for how to order them in the array."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"^code uint8-count (1 before, 2 after)"}),"\n",(0,a.jsxs)(n.p,{children:["Back in the Compiler struct, the ",(0,a.jsx)(n.code,{children:"localCount"}),' field tracks how many locals are\r\nin scope -- how many of those array slots are in use. We also track the "scope\r\ndepth". This is the number of blocks surrounding the current bit of code we\'re\r\ncompiling.']}),"\n",(0,a.jsx)(n.p,{children:"Our Java interpreter used a chain of maps to keep each block's variables\r\nseparate from other blocks'. This time, we'll simply number variables with the\r\nlevel of nesting where they appear. Zero is the global scope, one is the first\r\ntop-level block, two is inside that, you get the idea. We use this to track\r\nwhich block each local belongs to so that we know which locals to discard when a\r\nblock ends."}),"\n",(0,a.jsx)(n.p,{children:"Each local in the array is one of these:"}),"\n",(0,a.jsx)(n.p,{children:"^code local-struct (1 before, 2 after)"}),"\n",(0,a.jsxs)(n.p,{children:["We store the name of the variable. When we're resolving an identifier, we\r\ncompare the identifier's lexeme with each local's name to find a match. It's\r\npretty hard to resolve a variable if you don't know its name. The ",(0,a.jsx)(n.code,{children:"depth"})," field\r\nrecords the scope depth of the block where the local variable was declared.\r\nThat's all the state we need for now."]}),"\n",(0,a.jsxs)(n.p,{children:["This is a very different representation from what we had in jlox, but it still\r\nlets us answer all of the same questions our compiler needs to ask of the\r\nlexical environment. The next step is figuring out how the compiler ",(0,a.jsx)(n.em,{children:"gets"})," at\r\nthis state. If we were ",(0,a.jsx)(n.span,{name:"thread",children:"principled"})," engineers, we'd\r\ngive each function in the front end a parameter that accepts a pointer to a\r\nCompiler. We'd create a Compiler at the beginning and carefully thread it\r\nthrough each function call... but that would mean a lot of boring changes to\r\nthe code we already wrote, so here's a global variable instead:"]}),"\n",(0,a.jsxs)(n.aside,{name:"thread",children:["\n",(0,a.jsxs)(n.p,{children:["In particular, if we ever want to use our compiler in a multi-threaded\r\napplication, possibly with multiple compilers running in parallel, then using a\r\nglobal variable is a ",(0,a.jsx)(n.em,{children:"bad"})," idea."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"^code current-compiler (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"Here's a little function to initialize the compiler:"}),"\n",(0,a.jsx)(n.p,{children:"^code init-compiler"}),"\n",(0,a.jsx)(n.p,{children:"When we first start up the VM, we call it to get everything into a clean state."}),"\n",(0,a.jsx)(n.p,{children:"^code compiler (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"Our compiler has the data it needs, but not the operations on that data. There's\r\nno way to create and destroy scopes, or add and resolve variables. We'll add\r\nthose as we need them. First, let's start building some language features."}),"\n",(0,a.jsx)(n.h2,{id:"block-statements",children:"Block Statements"}),"\n",(0,a.jsxs)(n.p,{children:["Before we can have any local variables, we need some local scopes. These come\r\nfrom two things: function bodies and ",(0,a.jsx)(n.span,{name:"block",children:"blocks"}),". Functions\r\nare a big chunk of work that we'll tackle in ",(0,a.jsx)(n.a,{href:"calls-and-functions.html",children:"a later chapter"}),", so\r\nfor now we're only going to do blocks. As usual, we start with the syntax. The\r\nnew grammar we'll introduce is:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ebnf",children:'statement      \u2192 exprStmt\r\n               | printStmt\r\n               | block ;\r\n\r\nblock          \u2192 "{" declaration* "}" ;\n'})}),"\n",(0,a.jsxs)(n.aside,{name:"block",children:["\n",(0,a.jsxs)(n.p,{children:['When you think about it, "block" is a weird name. Used metaphorically, "block"\r\nusually means a small indivisible unit, but for some reason, the Algol 60\r\ncommittee decided to use it to refer to a ',(0,a.jsx)(n.em,{children:"compound"})," structure -- a series of\r\nstatements. It could be worse, I suppose. Algol 58 called ",(0,a.jsx)(n.code,{children:"begin"})," and ",(0,a.jsx)(n.code,{children:"end"}),'\r\n"statement parentheses".']}),"\n",(0,a.jsx)(n.img,{src:"image/local-variables/block.png",alt:"A cinder block.",className:"above"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Blocks are a kind of statement, so the rule for them goes in the ",(0,a.jsx)(n.code,{children:"statement"}),"\r\nproduction. The corresponding code to compile one looks like this:"]}),"\n",(0,a.jsx)(n.p,{children:"^code parse-block (2 before, 1 after)"}),"\n",(0,a.jsxs)(n.p,{children:["After ",(0,a.jsx)(n.span,{name:"helper",children:"parsing"})," the initial curly brace, we use this\r\nhelper function to compile the rest of the block:"]}),"\n",(0,a.jsxs)(n.aside,{name:"helper",children:["\n",(0,a.jsx)(n.p,{children:"This function will come in handy later for compiling function bodies."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"^code block"}),"\n",(0,a.jsx)(n.p,{children:"It keeps parsing declarations and statements until it hits the closing brace. As\r\nwe do with any loop in the parser, we also check for the end of the token\r\nstream. This way, if there's a malformed program with a missing closing curly,\r\nthe compiler doesn't get stuck in a loop."}),"\n",(0,a.jsx)(n.p,{children:"Executing a block simply means executing the statements it contains, one after\r\nthe other, so there isn't much to compiling them. The semantically interesting\r\nthing blocks do is create scopes. Before we compile the body of a block, we call\r\nthis function to enter a new local scope:"}),"\n",(0,a.jsx)(n.p,{children:"^code begin-scope"}),"\n",(0,a.jsxs)(n.p,{children:['In order to "create" a scope, all we do is increment the current depth. This is\r\ncertainly much faster than jlox, which allocated an entire new HashMap for\r\neach one. Given ',(0,a.jsx)(n.code,{children:"beginScope()"}),", you can probably guess what ",(0,a.jsx)(n.code,{children:"endScope()"})," does."]}),"\n",(0,a.jsx)(n.p,{children:"^code end-scope"}),"\n",(0,a.jsx)(n.p,{children:"That's it for blocks and scopes -- more or less -- so we're ready to stuff some\r\nvariables into them."}),"\n",(0,a.jsx)(n.h2,{id:"declaring-local-variables",children:"Declaring Local Variables"}),"\n",(0,a.jsxs)(n.p,{children:["Usually we start with parsing here, but our compiler already supports parsing\r\nand compiling variable declarations. We've got ",(0,a.jsx)(n.code,{children:"var"})," statements, identifier\r\nexpressions and assignment in there now. It's just that the compiler assumes\r\nall variables are global. So we don't need any new parsing support, we just need\r\nto hook up the new scoping semantics to the existing code."]}),"\n",(0,a.jsx)(n.img,{src:"image/local-variables/declaration.png",alt:"The code flow within varDeclaration()."}),"\n",(0,a.jsxs)(n.p,{children:["Variable declaration parsing begins in ",(0,a.jsx)(n.code,{children:"varDeclaration()"})," and relies on a couple\r\nof other functions. First, ",(0,a.jsx)(n.code,{children:"parseVariable()"})," consumes the identifier token for\r\nthe variable name, adds its lexeme to the chunk's constant table as a string,\r\nand then returns the constant table index where it was added. Then, after\r\n",(0,a.jsx)(n.code,{children:"varDeclaration()"})," compiles the initializer, it calls ",(0,a.jsx)(n.code,{children:"defineVariable()"})," to emit\r\nthe bytecode for storing the variable's value in the global variable hash table."]}),"\n",(0,a.jsxs)(n.p,{children:["Both of those helpers need a few changes to support local variables. In\r\n",(0,a.jsx)(n.code,{children:"parseVariable()"}),", we add:"]}),"\n",(0,a.jsx)(n.p,{children:"^code parse-local (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"First, we \"declare\" the variable. I'll get to what that means in a second. After\r\nthat, we exit the function if we're in a local scope. At runtime, locals aren't\r\nlooked up by name. There's no need to stuff the variable's name into the\r\nconstant table, so if the declaration is inside a local scope, we return a dummy\r\ntable index instead."}),"\n",(0,a.jsxs)(n.p,{children:["Over in ",(0,a.jsx)(n.code,{children:"defineVariable()"}),", we need to emit the code to store a local variable\r\nif we're in a local scope. It looks like this:"]}),"\n",(0,a.jsx)(n.p,{children:"^code define-variable (1 before, 1 after)"}),"\n",(0,a.jsxs)(n.p,{children:["Wait, what? Yup. That's it. There is no code to create a local variable at\r\nruntime. Think about what state the VM is in. It has already executed the code\r\nfor the variable's initializer (or the implicit ",(0,a.jsx)(n.code,{children:"nil"})," if the user omitted an\r\ninitializer), and that value is sitting right on top of the stack as the only\r\nremaining temporary. We also know that new locals are allocated at the top of\r\nthe stack... right where that value already is. Thus, there's nothing to do. The\r\ntemporary simply ",(0,a.jsx)(n.em,{children:"becomes"})," the local variable. It doesn't get much more\r\nefficient than that."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.span,{name:"locals"})}),"\n",(0,a.jsx)(n.img,{src:"image/local-variables/local-slots.png",alt:"Walking through the bytecode execution showing that each initializer's result ends up in the local's slot."}),"\n",(0,a.jsxs)(n.aside,{name:"locals",children:["\n",(0,a.jsx)(n.p,{children:"The code on the left compiles to the sequence of instructions on the right."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"OK, so what's \"declaring\" about? Here's what that does:"}),"\n",(0,a.jsx)(n.p,{children:"^code declare-variable"}),"\n",(0,a.jsx)(n.p,{children:"This is the point where the compiler records the existence of the variable. We\r\nonly do this for locals, so if we're in the top-level global scope, we just bail\r\nout. Because global variables are late bound, the compiler doesn't keep track of\r\nwhich declarations for them it has seen."}),"\n",(0,a.jsx)(n.p,{children:"But for local variables, the compiler does need to remember that the variable\r\nexists. That's what declaring it does -- it adds it to the compiler's list of\r\nvariables in the current scope. We implement that using another new function."}),"\n",(0,a.jsx)(n.p,{children:"^code add-local"}),"\n",(0,a.jsxs)(n.p,{children:["This initializes the next available Local in the compiler's array of variables.\r\nIt stores the variable's ",(0,a.jsx)(n.span,{name:"lexeme",children:"name"})," and the depth of the\r\nscope that owns the variable."]}),"\n",(0,a.jsxs)(n.aside,{name:"lexeme",children:["\n",(0,a.jsx)(n.p,{children:"Worried about the lifetime of the string for the variable's name? The Local\r\ndirectly stores a copy of the Token struct for the identifier. Tokens store a\r\npointer to the first character of their lexeme and the lexeme's length. That\r\npointer points into the original source string for the script or REPL entry\r\nbeing compiled."}),"\n",(0,a.jsx)(n.p,{children:"As long as that string stays around during the entire compilation process --\r\nwhich it must since, you know, we're compiling it -- then all of the tokens\r\npointing into it are fine."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Our implementation is fine for a correct Lox program, but what about invalid\r\ncode? Let's aim to be robust. The first error to handle is not really the user's\r\nfault, but more a limitation of the VM. The instructions to work with local\r\nvariables refer to them by slot index. That index is stored in a single-byte\r\noperand, which means the VM only supports up to 256 local variables in scope at\r\none time."}),"\n",(0,a.jsx)(n.p,{children:"If we try to go over that, not only could we not refer to them at runtime, but\r\nthe compiler would overwrite its own locals array, too. Let's prevent that."}),"\n",(0,a.jsx)(n.p,{children:"^code too-many-locals (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"The next case is trickier. Consider:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lox",children:'{\r\n  var a = "first";\r\n  var a = "second";\r\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["At the top level, Lox allows redeclaring a variable with the same name as a\r\nprevious declaration because that's useful for the REPL. But inside a local\r\nscope, that's a pretty ",(0,a.jsx)(n.span,{name:"rust",children:"weird"})," thing to do. It's likely\r\nto be a mistake, and many languages, including our own Lox, enshrine that\r\nassumption by making this an error."]}),"\n",(0,a.jsxs)(n.aside,{name:"rust",children:["\n",(0,a.jsxs)(n.p,{children:["Interestingly, the Rust programming language ",(0,a.jsx)(n.em,{children:"does"})," allow this, and idiomatic\r\ncode relies on it."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Note that the above program is different from this one:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lox",children:'{\r\n  var a = "outer";\r\n  {\r\n    var a = "inner";\r\n  }\r\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["It's OK to have two variables with the same name in ",(0,a.jsx)(n.em,{children:"different"})," scopes, even\r\nwhen the scopes overlap such that both are visible at the same time. That's\r\nshadowing, and Lox does allow that. It's only an error to have two variables\r\nwith the same name in the ",(0,a.jsx)(n.em,{children:"same"})," local scope."]}),"\n",(0,a.jsx)(n.p,{children:"We detect that error like so:"}),"\n",(0,a.jsx)(n.p,{children:"^code existing-in-scope (1 before, 2 after)"}),"\n",(0,a.jsxs)(n.aside,{name:"negative",children:["\n",(0,a.jsxs)(n.p,{children:["Don't worry about that odd ",(0,a.jsx)(n.code,{children:"depth != -1"})," part yet. We'll get to what that's\r\nabout later."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Local variables are appended to the array when they're declared, which means the\r\ncurrent scope is always at the end of the array. When we declare a new variable,\r\nwe start at the end and work backward, looking for an existing variable with the\r\nsame name. If we find one in the current scope, we report the error. Otherwise,\r\nif we reach the beginning of the array or a variable owned by another scope,\r\nthen we know we've checked all of the existing variables in the scope."}),"\n",(0,a.jsx)(n.p,{children:"To see if two identifiers are the same, we use this:"}),"\n",(0,a.jsx)(n.p,{children:"^code identifiers-equal"}),"\n",(0,a.jsxs)(n.p,{children:["Since we know the lengths of both lexemes, we check that first. That will fail\r\nquickly for many non-equal strings. If the ",(0,a.jsx)(n.span,{name:"hash",children:"lengths"})," are\r\nthe same, we check the characters using ",(0,a.jsx)(n.code,{children:"memcmp()"}),". To get to ",(0,a.jsx)(n.code,{children:"memcmp()"}),", we\r\nneed an include."]}),"\n",(0,a.jsxs)(n.aside,{name:"hash",children:["\n",(0,a.jsx)(n.p,{children:"It would be a nice little optimization if we could check their hashes, but\r\ntokens aren't full LoxStrings, so we haven't calculated their hashes yet."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"^code compiler-include-string (1 before, 2 after)"}),"\n",(0,a.jsx)(n.p,{children:"With this, we're able to bring variables into being. But, like ghosts, they\r\nlinger on beyond the scope where they are declared. When a block ends, we need\r\nto put them to rest."}),"\n",(0,a.jsx)(n.p,{children:"^code pop-locals (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"When we pop a scope, we walk backward through the local array looking for any\r\nvariables declared at the scope depth we just left. We discard them by simply\r\ndecrementing the length of the array."}),"\n",(0,a.jsxs)(n.p,{children:["There is a runtime component to this too. Local variables occupy slots on the\r\nstack. When a local variable goes out of scope, that slot is no longer needed\r\nand should be freed. So, for each variable that we discard, we also emit an\r\n",(0,a.jsx)(n.code,{children:"OP_POP"})," ",(0,a.jsx)(n.span,{name:"pop",children:"instruction"})," to pop it from the stack."]}),"\n",(0,a.jsxs)(n.aside,{name:"pop",children:["\n",(0,a.jsxs)(n.p,{children:["When multiple local variables go out of scope at once, you get a series of\r\n",(0,a.jsx)(n.code,{children:"OP_POP"})," instructions that get interpreted one at a time. A simple optimization\r\nyou could add to your Lox implementation is a specialized ",(0,a.jsx)(n.code,{children:"OP_POPN"})," instruction\r\nthat takes an operand for the number of slots to pop and pops them all at once."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"using-locals",children:"Using Locals"}),"\n",(0,a.jsx)(n.p,{children:"We can now compile and execute local variable declarations. At runtime, their\r\nvalues are sitting where they should be on the stack. Let's start using them.\r\nWe'll do both variable access and assignment at the same time since they touch\r\nthe same functions in the compiler."}),"\n",(0,a.jsx)(n.p,{children:"We already have code for getting and setting global variables, and -- like good\r\nlittle software engineers -- we want to reuse as much of that existing code as\r\nwe can. Something like this:"}),"\n",(0,a.jsx)(n.p,{children:"^code named-local (1 before, 2 after)"}),"\n",(0,a.jsx)(n.p,{children:"Instead of hardcoding the bytecode instructions emitted for variable access and\r\nassignment, we use a couple of C variables. First, we try to find a local\r\nvariable with the given name. If we find one, we use the instructions for\r\nworking with locals. Otherwise, we assume it's a global variable and use the\r\nexisting bytecode instructions for globals."}),"\n",(0,a.jsx)(n.p,{children:"A little further down, we use those variables to emit the right instructions.\r\nFor assignment:"}),"\n",(0,a.jsx)(n.p,{children:"^code emit-set (2 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"And for access:"}),"\n",(0,a.jsx)(n.p,{children:"^code emit-get (2 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"The real heart of this chapter, the part where we resolve a local variable, is\r\nhere:"}),"\n",(0,a.jsx)(n.p,{children:"^code resolve-local"}),"\n",(0,a.jsxs)(n.p,{children:["For all that, it's straightforward. We walk the list of locals that are\r\ncurrently in scope. If one has the same name as the identifier token, the\r\nidentifier must refer to that variable. We've found it! We walk the array\r\nbackward so that we find the ",(0,a.jsx)(n.em,{children:"last"})," declared variable with the identifier. That\r\nensures that inner local variables correctly shadow locals with the same name in\r\nsurrounding scopes."]}),"\n",(0,a.jsxs)(n.p,{children:["At runtime, we load and store locals using the stack slot index, so that's what\r\nthe compiler needs to calculate after it resolves the variable. Whenever a\r\nvariable is declared, we append it to the locals array in Compiler. That means\r\nthe first local variable is at index zero, the next one is at index one, and so\r\non. In other words, the locals array in the compiler has the ",(0,a.jsx)(n.em,{children:"exact"})," same layout\r\nas the VM's stack will have at runtime. The variable's index in the locals array\r\nis the same as its stack slot. How convenient!"]}),"\n",(0,a.jsxs)(n.p,{children:["If we make it through the whole array without finding a variable with the given\r\nname, it must not be a local. In that case, we return ",(0,a.jsx)(n.code,{children:"-1"})," to signal that it\r\nwasn't found and should be assumed to be a global variable instead."]}),"\n",(0,a.jsx)(n.h3,{id:"interpreting-local-variables",children:"Interpreting local variables"}),"\n",(0,a.jsx)(n.p,{children:"Our compiler is emitting two new instructions, so let's get them working. First\r\nis loading a local variable:"}),"\n",(0,a.jsx)(n.p,{children:"^code get-local-op (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"And its implementation:"}),"\n",(0,a.jsx)(n.p,{children:"^code interpret-get-local (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"It takes a single-byte operand for the stack slot where the local lives. It\r\nloads the value from that index and then pushes it on top of the stack where\r\nlater instructions can find it."}),"\n",(0,a.jsxs)(n.aside,{name:"slot",children:["\n",(0,a.jsxs)(n.p,{children:["It seems redundant to push the local's value onto the stack since it's already\r\non the stack lower down somewhere. The problem is that the other bytecode\r\ninstructions only look for data at the ",(0,a.jsx)(n.em,{children:"top"})," of the stack. This is the core\r\naspect that makes our bytecode instruction set ",(0,a.jsx)(n.em,{children:"stack"}),"-based.\r\n",(0,a.jsx)(n.a,{href:"a-virtual-machine.html#design-note",children:"Register-based"})," bytecode instruction sets avoid this stack juggling at the\r\ncost of having larger instructions with more operands."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Next is assignment:"}),"\n",(0,a.jsx)(n.p,{children:"^code set-local-op (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"You can probably predict the implementation."}),"\n",(0,a.jsx)(n.p,{children:"^code interpret-set-local (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"It takes the assigned value from the top of the stack and stores it in the stack\r\nslot corresponding to the local variable. Note that it doesn't pop the value\r\nfrom the stack. Remember, assignment is an expression, and every expression\r\nproduces a value. The value of an assignment expression is the assigned value\r\nitself, so the VM just leaves the value on the stack."}),"\n",(0,a.jsx)(n.p,{children:"Our disassembler is incomplete without support for these two new instructions."}),"\n",(0,a.jsx)(n.p,{children:"^code disassemble-local (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"The compiler compiles local variables to direct slot access. The local\r\nvariable's name never leaves the compiler to make it into the chunk at all.\r\nThat's great for performance, but not so great for introspection. When we\r\ndisassemble these instructions, we can't show the variable's name like we could\r\nwith globals. Instead, we just show the slot number."}),"\n",(0,a.jsxs)(n.aside,{name:"debug",children:["\n",(0,a.jsx)(n.p,{children:"Erasing local variable names in the compiler is a real issue if we ever want to\r\nimplement a debugger for our VM. When users step through code, they expect to\r\nsee the values of local variables organized by their names. To support that,\r\nwe'd need to output some additional information that tracks the name of each\r\nlocal variable at each stack slot."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"^code byte-instruction"}),"\n",(0,a.jsx)(n.h3,{id:"another-scope-edge-case",children:"Another scope edge case"}),"\n",(0,a.jsxs)(n.p,{children:["We already sunk some time into handling a couple of weird edge cases around\r\nscopes. We made sure shadowing works correctly. We report an error if two\r\nvariables in the same local scope have the same name. For reasons that aren't\r\nentirely clear to me, variable scoping seems to have a lot of these wrinkles.\r\nI've never seen a language where it feels completely ",(0,a.jsx)(n.span,{name:"elegant",children:"elegant"}),"."]}),"\n",(0,a.jsxs)(n.aside,{name:"elegant",children:["\n",(0,a.jsx)(n.p,{children:"No, not even Scheme."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["We've got one more edge case to deal with before we end this chapter. Recall this strange beastie we first met in ",(0,a.jsx)(n.a,{href:"resolving-and-binding.html#resolving-variable-declarations",children:"jlox's implementation of variable resolution"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lox",children:'{\r\n  var a = "outer";\r\n  {\r\n    var a = a;\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"We slayed it then by splitting a variable's declaration into two phases, and\r\nwe'll do that again here:"}),"\n",(0,a.jsx)(n.img,{src:"image/local-variables/phases.png",alt:"An example variable declaration marked 'declared uninitialized' before the variable name and 'ready for use' after the initializer."}),"\n",(0,a.jsx)(n.p,{children:'As soon as the variable declaration begins -- in other words, before its\r\ninitializer -- the name is declared in the current scope. The variable exists,\r\nbut in a special "uninitialized" state. Then we compile the initializer. If at\r\nany point in that expression we resolve an identifier that points back to this\r\nvariable, we\'ll see that it is not initialized yet and report an error. After we\r\nfinish compiling the initializer, we mark the variable as initialized and ready\r\nfor use.'}),"\n",(0,a.jsxs)(n.p,{children:["To implement this, when we declare a local, we need to indicate the\r\n\"uninitialized\" state somehow. We could add a new field to Local, but let's be a\r\nlittle more parsimonious with memory. Instead, we'll set the variable's scope\r\ndepth to a special sentinel value, ",(0,a.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"^code declare-undefined (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"Later, once the variable's initializer has been compiled, we mark it\r\ninitialized."}),"\n",(0,a.jsx)(n.p,{children:"^code define-local (1 before, 2 after)"}),"\n",(0,a.jsx)(n.p,{children:"That is implemented like so:"}),"\n",(0,a.jsx)(n.p,{children:"^code mark-initialized"}),"\n",(0,a.jsxs)(n.p,{children:["So this is ",(0,a.jsx)(n.em,{children:"really"}),' what "declaring" and "defining" a variable means in the\r\ncompiler. "Declaring" is when the variable is added to the scope, and "defining"\r\nis when it becomes available for use.']}),"\n",(0,a.jsx)(n.p,{children:"When we resolve a reference to a local variable, we check the scope depth to see\r\nif it's fully defined."}),"\n",(0,a.jsx)(n.p,{children:"^code own-initializer-error (1 before, 1 after)"}),"\n",(0,a.jsx)(n.p,{children:"If the variable has the sentinel depth, it must be a reference to a variable in\r\nits own initializer, and we report that as an error."}),"\n",(0,a.jsx)(n.p,{children:"That's it for this chapter! We added blocks, local variables, and real,\r\nhonest-to-God lexical scoping. Given that we introduced an entirely different\r\nruntime representation for variables, we didn't have to write a lot of code. The\r\nimplementation ended up being pretty clean and efficient."}),"\n",(0,a.jsxs)(n.p,{children:["You'll notice that almost all of the code we wrote is in the compiler. Over in\r\nthe runtime, it's just two little instructions. You'll see this as a continuing\r\n",(0,a.jsx)(n.span,{name:"static",children:"trend"})," in clox compared to jlox. One of the biggest\r\nhammers in the optimizer's toolbox is pulling work forward into the compiler so\r\nthat you don't have to do it at runtime. In this chapter, that meant resolving\r\nexactly which stack slot every local variable occupies. That way, at runtime, no\r\nlookup or resolution needs to happen."]}),"\n",(0,a.jsxs)(n.aside,{name:"static",children:["\n",(0,a.jsxs)(n.p,{children:["You can look at static types as an extreme example of this trend. A statically\r\ntyped language takes all of the type analysis and type error handling and sorts\r\nit all out during compilation. Then the runtime doesn't have to waste any time\r\nchecking that values have the proper type for their operation. In fact, in some\r\nstatically typed languages like C, you don't even ",(0,a.jsx)(n.em,{children:"know"})," the type at runtime.\r\nThe compiler completely erases any representation of a value's type leaving just\r\nthe bare bits."]}),"\n"]}),"\n",(0,a.jsxs)(n.div,{className:"challenges",children:["\n",(0,a.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Our simple local array makes it easy to calculate the stack slot of each\r\nlocal variable. But it means that when the compiler resolves a reference to\r\na variable, we have to do a linear scan through the array."}),"\n",(0,a.jsx)(n.p,{children:"Come up with something more efficient. Do you think the additional\r\ncomplexity is worth it?"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"How do other languages handle code like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lox",children:"var a = a;\n"})}),"\n",(0,a.jsx)(n.p,{children:"What would you do if it was your language? Why?"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Many languages make a distinction between variables that can be reassigned\r\nand those that can't. In Java, the ",(0,a.jsx)(n.code,{children:"final"})," modifier prevents you from\r\nassigning to a variable. In JavaScript, a variable declared with ",(0,a.jsx)(n.code,{children:"let"})," can\r\nbe assigned, but one declared using ",(0,a.jsx)(n.code,{children:"const"})," can't. Swift treats ",(0,a.jsx)(n.code,{children:"let"})," as\r\nsingle-assignment and uses ",(0,a.jsx)(n.code,{children:"var"})," for assignable variables. Scala and Kotlin\r\nuse ",(0,a.jsx)(n.code,{children:"val"})," and ",(0,a.jsx)(n.code,{children:"var"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Pick a keyword for a single-assignment variable form to add to Lox. Justify\r\nyour choice, then implement it. An attempt to assign to a variable declared\r\nusing your new keyword should cause a compile error."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Extend clox to allow more than 256 local variables to be in scope at a time."}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);