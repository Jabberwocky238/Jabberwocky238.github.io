---
sidebar_position: 8
sidebar_label: ğŸ’©è¿‡ç¨‹å® proc macros
sidebar_class_name: green
---

# è¿‡ç¨‹å®


# serde/src/de/impls.rs line 989
```rust
macro_rules! seq_impl {
    (
        $(#[$attr:meta])*
        $ty:ident <T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*>,
        $access:ident,
        $clear:expr,
        $with_capacity:expr,
        $reserve:expr,
        $insert:expr
    ) => {
        $(#[$attr])*
        impl<'de, T $(, $typaram)*> Deserialize<'de> for $ty<T $(, $typaram)*>
        where
            T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,
            $($typaram: $bound1 $(+ $bound2)*,)*
        {
```

è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ª Rust çš„è¿‡ç¨‹å®ï¼Œåä¸º `seq_impl`ã€‚è¿‡ç¨‹å®åœ¨ Rust ä¸­æ˜¯ä¸€ç§éå¸¸å¼ºå¤§çš„å·¥å…·ï¼Œå…è®¸å¼€å‘è€…ç¼–å†™å¯ä»¥ç”Ÿæˆå¤æ‚ä»£ç æ¨¡æ¿çš„å®ã€‚è¿™ä¸ªç‰¹å®šçš„å® `seq_impl` çœ‹èµ·æ¥æ˜¯ä¸ºäº†å®ç°åºåˆ—åŒ–å’Œååºåˆ—åŒ–æ“ä½œï¼Œç‰¹åˆ«æ˜¯é’ˆå¯¹æŸä¸ªæ³›å‹ç±»å‹ `$ty`ã€‚è®©æˆ‘ä»¬é€è¡Œåˆ†æè¿™ä¸ªå®çš„å®šä¹‰ï¼š

### å®å®šä¹‰ç»“æ„

1. **å±æ€§å’Œæ³›å‹å‚æ•°**
   - `$(#[$attr:meta])*`: è¿™æ˜¯ä¸€ä¸ªé‡å¤å‚æ•°ï¼Œç”¨äºæ•è·é›¶ä¸ªæˆ–å¤šä¸ªå±æ€§ã€‚è¿™äº›å±æ€§å°†è¢«åº”ç”¨åˆ°ç”Ÿæˆçš„ `impl` å—ä¸Šã€‚
   - `$ty:ident <T $(: $tbound1:ident $(+ $tbound2:ident)*)*`: å®šä¹‰äº†ä¸€ä¸ªæ³›å‹ç±»å‹ `$ty`ï¼Œå…¶ä¸­ `T` æ˜¯ç±»å‹å‚æ•°ï¼Œåé¢è·Ÿç€ä¸€ä¸ªæˆ–å¤šä¸ª trait ç»‘å®šï¼ˆä¾‹å¦‚ `: Deserialize`ï¼‰ã€‚
   - `$(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*`: å¯é€‰çš„é¢å¤–ç±»å‹å‚æ•°å’Œå®ƒä»¬çš„ trait ç»‘å®šã€‚

2. **æ–¹æ³•å’Œè¡¨è¾¾å¼**
   - `$access:ident`, `$clear:expr`, `$with_capacity:expr`, `$reserve:expr`, `$insert:expr`: è¿™äº›æ˜¯å®è°ƒç”¨æ—¶æä¾›çš„è¡¨è¾¾å¼æˆ–æ–¹æ³•åï¼Œç”¨äºåœ¨ç”Ÿæˆçš„ä»£ç ä¸­è®¿é—®ã€æ¸…é™¤ã€å¸¦å®¹é‡åˆå§‹åŒ–ã€ä¿ç•™ç©ºé—´å’Œæ’å…¥å…ƒç´ ã€‚

### å®å±•å¼€

- **ç”Ÿæˆçš„ä»£ç **
  - `impl<'de, T $(, $typaram)*> Deserialize<'de> for $ty<T $(, $typaram)*>`: ä¸ºç±»å‹ `$ty` å®ç° `Deserialize` traitã€‚è¿™é‡Œçš„ `'de` æ˜¯ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œç”¨äºååºåˆ—åŒ–æ“ä½œã€‚
  - `where` å­å¥åˆ—å‡ºäº†æ‰€æœ‰ç±»å‹å‚æ•° `T` å’Œ `$typaram` éœ€è¦æ»¡è¶³çš„ trait ç»‘å®šã€‚

### ç¤ºä¾‹ç”¨æ³•

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç±»å‹ `MySeq` å’Œä¸€ä¸ªç±»å‹ `MyTrait`ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸º `MySeq<T>` å®ç° `Deserialize`ï¼Œå…¶ä¸­ `T` å¿…é¡»å®ç° `Deserialize` å’Œ `MyTrait`ï¼š

```rust
seq_impl!(
    /// MySeq deserializer.
    MySeq<T: Deserialize + MyTrait>,
    access,
    clear,
    with_capacity,
    reserve,
    insert
);
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå®ä¼šç”Ÿæˆä¸€ä¸ª `impl` å—ï¼Œä¸º `MySeq<T>` å®ç° `Deserialize` traitï¼Œå…¶ä¸­ `T` éœ€è¦å®ç° `Deserialize` å’Œ `MyTrait`ã€‚

### æ³¨æ„äº‹é¡¹

- **å¤æ‚æ€§**ï¼šè¿‡ç¨‹å®å¯ä»¥éå¸¸å¤æ‚ï¼Œå°¤å…¶æ˜¯å½“å®ƒä»¬å¤„ç†å¤šä¸ªæ³›å‹å‚æ•°å’Œ trait ç»‘å®šæ—¶ã€‚
- **è°ƒè¯•éš¾åº¦**ï¼šç”±äºè¿‡ç¨‹å®åœ¨ç¼–è¯‘æ—¶å±•å¼€ï¼Œå®ƒä»¬å¯èƒ½å¯¼è‡´éš¾ä»¥è·Ÿè¸ªçš„é”™è¯¯ã€‚
- **æ€§èƒ½**ï¼šå°½ç®¡å®å¯ä»¥ç”Ÿæˆä¼˜åŒ–çš„ä»£ç ï¼Œä½†è¿‡åº¦ä½¿ç”¨æˆ–ä¸å½“ä½¿ç”¨å¯èƒ½å¯¼è‡´ç¼–è¯‘æ—¶é—´å¢åŠ ã€‚

è¿™ä¸ªå®çš„è®¾è®¡å…è®¸å®ƒåœ¨å¤šç§ä¸åŒçš„ç±»å‹å’Œçº¦æŸä¸Šé‡ç”¨ï¼Œä½¿å¾—ä»£ç æ›´åŠ æ¨¡å—åŒ–å’Œå¯ç»´æŠ¤ã€‚

```rust
seq_impl!(
    #[cfg(any(feature = "std", feature = "alloc"))]
    #[cfg_attr(docsrs, doc(cfg(any(feature = "std", feature = "alloc"))))]
    BinaryHeap<T: Ord>,
    seq,
    BinaryHeap::clear,
    BinaryHeap::with_capacity(size_hint::cautious::<T>(seq.size_hint())),
    BinaryHeap::reserve,
    BinaryHeap::push
);

seq_impl!(
    #[cfg(any(feature = "std", feature = "alloc"))]
    #[cfg_attr(docsrs, doc(cfg(any(feature = "std", feature = "alloc"))))]
    BTreeSet<T: Eq + Ord>,
    seq,
    BTreeSet::clear,
    BTreeSet::new(),
    nop_reserve,
    BTreeSet::insert
);
```
åœ¨ Rust å®ç³»ç»Ÿä¸­ï¼Œ`ident` å’Œ `expr` æ˜¯ä¸¤ç§ä¸åŒç±»å‹çš„æ¨¡å¼ï¼Œç”¨äºåŒ¹é…å®å®šä¹‰ä¸­çš„è¾“å…¥ã€‚å®ƒä»¬çš„ä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬æ‰€åŒ¹é…çš„è¯­æ³•ç§ç±»ï¼š

1. **`ident`**ï¼š
   - `ident` ç”¨äºåŒ¹é…æ ‡è¯†ç¬¦ã€‚
   - æ ‡è¯†ç¬¦æ˜¯ Rust ä»£ç ä¸­çš„åå­—ï¼Œæ¯”å¦‚å˜é‡åã€å‡½æ•°åã€ç±»å‹åç­‰ã€‚
   - ç¤ºä¾‹ï¼š`fn`ã€`loop`ã€`Result`ã€`x`ã€`y`ã€‚

2. **`expr`**ï¼š
   - `expr` ç”¨äºåŒ¹é…è¡¨è¾¾å¼ã€‚
   - è¡¨è¾¾å¼æ˜¯ Rust ä»£ç ä¸­çš„ä¸€ä¸ªå®Œæ•´çš„è®¡ç®—å•å…ƒï¼Œå¯ä»¥æ˜¯å­—é¢é‡ã€å˜é‡å¼•ç”¨ã€å‡½æ•°è°ƒç”¨ã€è¿ç®—ç¬¦åº”ç”¨ç­‰ã€‚
   - ç¤ºä¾‹ï¼š`2 + 2`ã€`x * y`ã€`foo()`ã€`[1, 2, 3]`ã€‚

### è¯¦ç»†è¯´æ˜

- **`ident`**ï¼š
  - åœ¨å®å®šä¹‰ä¸­ï¼Œ`ident` æ¨¡å¼å¯ä»¥æ•è·ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œå¹¶åœ¨å®å±•å¼€æ—¶ä½œä¸ºæ ‡è¯†ç¬¦ä½¿ç”¨ã€‚
  - å®ƒé€šå¸¸ç”¨äºæ•è·å‡½æ•°åã€å˜é‡åæˆ–å…¶ä»–ç±»å‹çš„åç§°ã€‚
  - åœ¨å®çš„æ›¿æ¢æ–‡æœ¬ä¸­ï¼Œæ•è·çš„æ ‡è¯†ç¬¦å¯ä»¥é€šè¿‡ `${ident}` çš„å½¢å¼ä½¿ç”¨ã€‚

- **`expr`**ï¼š
  - `expr` æ¨¡å¼å¯ä»¥åŒ¹é…ä»»ä½•æœ‰æ•ˆçš„ Rust è¡¨è¾¾å¼ã€‚
  - å®ƒç”¨äºæ•è·æ›´å¤æ‚çš„ä»£ç ç»“æ„ï¼Œæ¯”å¦‚å‡½æ•°è°ƒç”¨ã€ç®—æœ¯è¿ç®—ã€æ¡ä»¶è¡¨è¾¾å¼ç­‰ã€‚
  - åœ¨å®çš„æ›¿æ¢æ–‡æœ¬ä¸­ï¼Œæ•è·çš„è¡¨è¾¾å¼å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œæˆ–è€…é€šè¿‡å…¶ä»–å®è§„åˆ™è¿›ä¸€æ­¥å¤„ç†ã€‚

### ç¤ºä¾‹

```rust
// å®šä¹‰ä¸€ä¸ªç®€å•çš„å®ï¼Œä½¿ç”¨ ident å’Œ expr
macro_rules! create_function {
    ($name:ident -> $ret_type:ty { $body:expr }) => {
        fn $name() -> $ret_type {
            $body
        }
    };
}

// ä½¿ç”¨å®åˆ›å»ºä¸€ä¸ªå‡½æ•°
create_function!(square -> i32 { (3 * 3) });
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼š
- `$name:ident` æ•è·äº†æ ‡è¯†ç¬¦ `square`ã€‚
- `-> $ret_type:ty` æ•è·äº†è¿”å›ç±»å‹ `i32`ã€‚
- `{ $body:expr }` æ•è·äº†è¡¨è¾¾å¼ `(3 * 3)`ã€‚

å®å±•å¼€åï¼Œç”Ÿæˆçš„ä»£ç å¦‚ä¸‹ï¼š

```rust
fn square() -> i32 {
    (3 * 3)
}
```

### æ€»ç»“

- **`ident`** ç”¨äºåŒ¹é…å’Œç”Ÿæˆæ ‡è¯†ç¬¦ã€‚
- **`expr`** ç”¨äºåŒ¹é…å’Œç”Ÿæˆè¡¨è¾¾å¼ã€‚

äº†è§£è¿™ä¸¤ç§æ¨¡å¼çš„åŒºåˆ«å¯¹äºç¼–å†™çµæ´»ä¸”å¼ºå¤§çš„ Rust å®è‡³å…³é‡è¦ã€‚

åœ¨ Rust çš„å®ç³»ç»Ÿä¸­ï¼Œ`ty` å’Œ `block` æ˜¯ç”¨äºåŒ¹é…ç‰¹å®šç±»å‹çš„æ¨¡å¼ã€‚å®ƒä»¬åˆ†åˆ«ç”¨äºç±»å‹å’Œä»£ç å—çš„åŒ¹é…ã€‚

### `ty` æ¨¡å¼

`ty` æ¨¡å¼ç”¨äºåŒ¹é… Rust ä¸­çš„ç±»å‹ã€‚å®ƒæ•è·çš„æ˜¯ä¸€ä¸ªç±»å‹è¡¨è¾¾å¼ï¼Œå¯ä»¥æ˜¯ç®€å•ç±»å‹ï¼Œå¦‚ `i32`ã€`&str`ï¼Œä¹Ÿå¯ä»¥æ˜¯å¤æ‚ç±»å‹ï¼Œå¦‚ `Vec<T>` æˆ–è‡ªå®šä¹‰ç±»å‹ã€‚

**ç¤ºä¾‹**ï¼š

```rust
macro_rules! type_of {
    ($val:expr) => {
        std::mem::discriminant(&$val)
    };
}

fn main() {
    type_of!(42); // åŒ¹é…ç±»å‹ i32
    type_of!("hello"); // åŒ¹é…ç±»å‹ &str
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå® `type_of!` ä½¿ç”¨ `expr` æ¨¡å¼æ¥åŒ¹é…ä»»ä½•è¡¨è¾¾å¼ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™ `std::mem::discriminant` å‡½æ•°ï¼Œè¯¥å‡½æ•°éœ€è¦ä¸€ä¸ªç±»å‹æ ‡è¯†ç¬¦ä½œä¸ºå‚æ•°ã€‚

### `block` æ¨¡å¼

`block` æ¨¡å¼ç”¨äºåŒ¹é… Rust ä¸­çš„ä»£ç å— `{}`ã€‚å®ƒæ•è·çš„æ˜¯ä¸€ä¸ªä»£ç å—è¡¨è¾¾å¼ï¼Œå¯ä»¥åŒ…å«ä»»æ„å¤šçš„è¯­å¥ã€‚

**ç¤ºä¾‹**ï¼š

```rust
macro_rules! block_example {
    ($block:block) => {
        {
            // å¯ä»¥åœ¨è¿™é‡Œå¤„ç† $block
            $block
        }
    };
}

fn main() {
    let result = block_example!({
        let x = 10;
        x + 2
    });
    println!("The result is: {}", result);
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå® `block_example!` ä½¿ç”¨ `block` æ¨¡å¼æ¥åŒ¹é…ä¸€ä¸ªä»£ç å—ï¼Œå¹¶å°†å…¶ä½œä¸ºå‚æ•°ä¼ é€’ã€‚åœ¨å®çš„å±•å¼€ä¸­ï¼Œä»£ç å—è¢«åŒ…å«åœ¨ä¸€ä¸ªæ–°åˆ›å»ºçš„ä»£ç å—ä¸­ï¼Œå…è®¸åœ¨å…¶ä¸­æ‰§è¡Œä¸€äº›åˆå§‹åŒ–æˆ–æœ€ç»ˆå¤„ç†ã€‚

### æ³¨æ„äº‹é¡¹

- `ty` æ¨¡å¼åªèƒ½åŒ¹é…ç±»å‹ï¼Œä¸èƒ½åŒ¹é…å€¼ã€‚
- `block` æ¨¡å¼åŒ¹é…çš„æ˜¯ä»£ç å—ï¼Œå®ƒå¯ä»¥åŒ…å«ä»»æ„å¤šçš„è¯­å¥ã€‚

ä½¿ç”¨è¿™äº›æ¨¡å¼å¯ä»¥å¸®åŠ©ä½ ç¼–å†™æ›´çµæ´»çš„å®ï¼Œä»¥é€‚åº”ä¸åŒçš„ä»£ç ç»“æ„å’Œç±»å‹ã€‚



# syn
ç¥äº†æˆ‘æ“ï¼Œç¼–è¯‘å™¨å¼€æ´

```rust
#[macro_export]
macro_rules! Token {
    [abstract]    => { $crate::token::Abstract };
    [as]          => { $crate::token::As };
    [async]       => { $crate::token::Async };
    [auto]        => { $crate::token::Auto };
    [await]       => { $crate::token::Await };
    [become]      => { $crate::token::Become };
    [box]         => { $crate::token::Box };
    [break]       => { $crate::token::Break };
    [const]       => { $crate::token::Const };
    [continue]    => { $crate::token::Continue };
    [crate]       => { $crate::token::Crate };
    [default]     => { $crate::token::Default };
    [do]          => { $crate::token::Do };
    [dyn]         => { $crate::token::Dyn };
    [else]        => { $crate::token::Else };
    [enum]        => { $crate::token::Enum };
    [extern]      => { $crate::token::Extern };
    [final]       => { $crate::token::Final };
    [fn]          => { $crate::token::Fn };
    [for]         => { $crate::token::For };
    [if]          => { $crate::token::If };
    [impl]        => { $crate::token::Impl };
    [in]          => { $crate::token::In };
    [let]         => { $crate::token::Let };
    [loop]        => { $crate::token::Loop };
    [macro]       => { $crate::token::Macro };
    [match]       => { $crate::token::Match };
    [mod]         => { $crate::token::Mod };
    [move]        => { $crate::token::Move };
    [mut]         => { $crate::token::Mut };
    [override]    => { $crate::token::Override };
    [priv]        => { $crate::token::Priv };
    [pub]         => { $crate::token::Pub };
    [ref]         => { $crate::token::Ref };
    [return]      => { $crate::token::Return };
    [Self]        => { $crate::token::SelfType };
    [self]        => { $crate::token::SelfValue };
    [static]      => { $crate::token::Static };
    [struct]      => { $crate::token::Struct };
    [super]       => { $crate::token::Super };
    [trait]       => { $crate::token::Trait };
    [try]         => { $crate::token::Try };
    [type]        => { $crate::token::Type };
    [typeof]      => { $crate::token::Typeof };
    [union]       => { $crate::token::Union };
    [unsafe]      => { $crate::token::Unsafe };
    [unsized]     => { $crate::token::Unsized };
    [use]         => { $crate::token::Use };
    [virtual]     => { $crate::token::Virtual };
    [where]       => { $crate::token::Where };
    [while]       => { $crate::token::While };
    [yield]       => { $crate::token::Yield };
    [&]           => { $crate::token::And };
    [&&]          => { $crate::token::AndAnd };
    [&=]          => { $crate::token::AndEq };
    [@]           => { $crate::token::At };
    [^]           => { $crate::token::Caret };
    [^=]          => { $crate::token::CaretEq };
    [:]           => { $crate::token::Colon };
    [,]           => { $crate::token::Comma };
    [$]           => { $crate::token::Dollar };
    [.]           => { $crate::token::Dot };
    [..]          => { $crate::token::DotDot };
    [...]         => { $crate::token::DotDotDot };
    [..=]         => { $crate::token::DotDotEq };
    [=]           => { $crate::token::Eq };
    [==]          => { $crate::token::EqEq };
    [=>]          => { $crate::token::FatArrow };
    [>=]          => { $crate::token::Ge };
    [>]           => { $crate::token::Gt };
    [<-]          => { $crate::token::LArrow };
    [<=]          => { $crate::token::Le };
    [<]           => { $crate::token::Lt };
    [-]           => { $crate::token::Minus };
    [-=]          => { $crate::token::MinusEq };
    [!=]          => { $crate::token::Ne };
    [!]           => { $crate::token::Not };
    [|]           => { $crate::token::Or };
    [|=]          => { $crate::token::OrEq };
    [||]          => { $crate::token::OrOr };
    [::]          => { $crate::token::PathSep };
    [%]           => { $crate::token::Percent };
    [%=]          => { $crate::token::PercentEq };
    [+]           => { $crate::token::Plus };
    [+=]          => { $crate::token::PlusEq };
    [#]           => { $crate::token::Pound };
    [?]           => { $crate::token::Question };
    [->]          => { $crate::token::RArrow };
    [;]           => { $crate::token::Semi };
    [<<]          => { $crate::token::Shl };
    [<<=]         => { $crate::token::ShlEq };
    [>>]          => { $crate::token::Shr };
    [>>=]         => { $crate::token::ShrEq };
    [/]           => { $crate::token::Slash };
    [/=]          => { $crate::token::SlashEq };
    [*]           => { $crate::token::Star };
    [*=]          => { $crate::token::StarEq };
    [~]           => { $crate::token::Tilde };
    [_]           => { $crate::token::Underscore };
}
pub struct Match(pub Fragment);

impl ToTokens for Match {
    fn to_tokens(&self, out: &mut TokenStream) {
        match &self.0 {
            Fragment::Expr(expr) => {
                expr.to_tokens(out);
                <Token![,]>::default().to_tokens(out);
            }
            Fragment::Block(block) => {
                token::Brace::default().surround(out, |out| block.to_tokens(out));
            }
        }
    }
}
```

# quote!
å­—ç¬¦æµç»„åˆ
```rust
pub fn pretend_used(cont: &Container, is_packed: bool) -> TokenStream {
    let pretend_fields = pretend_fields_used(cont, is_packed);
    let pretend_variants = pretend_variants_used(cont);

    quote! {
        #pretend_fields
        #pretend_variants
    }
}
```