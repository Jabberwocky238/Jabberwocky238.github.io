---
sidebar_position: 9
sidebar_label: 属性宏(attribute macros)
sidebar_class_name: green
---

# 属性宏


这些代码是 Rust 语言中的属性宏（attribute macros），它们用于配置编译器的行为或者提供元数据。下面是每行代码的解释：

1. `#![doc(html_root_url = "https://docs.rs/serde/1.0.210")]`
   这是一个文档属性宏，它告诉 Rust 文档生成器在生成文档时，将 Serde 类型链接到指定的 URL。这意味着当其他 crate 的文档中引用了 Serde 类型时，它们会被链接到这个 URL 上的相应文档页面。

2. `#![cfg_attr(not(feature = "std"), no_std)]`
   这个属性宏用于条件编译。`cfg_attr` 宏检查是否没有启用 `std` 特性（通过 `feature = "std"` 指定）。如果没有启用 `std` 特性，那么 `no_std` 属性会被应用，允许 crate 在不依赖标准库的情况下编译。这对于编写可以用于嵌入式系统或其他不包含标准库的环境中的代码非常有用。

3. `#![cfg_attr(docsrs, feature(doc_cfg, rustdoc_internals))]`
   这个属性宏用于在生成文档时启用特定的 Rust 编译器特性。`cfg_attr` 宏检查是否在 `docsrs` 环境下（通常用于文档生成），如果是，则启用 `doc_cfg` 和 `rustdoc_internals` 特性。`doc_cfg` 允许在文档中使用条件编译属性，而 `rustdoc_internals` 启用了一些 Rust 文档工具的内部特性。

4. `#![cfg_attr(docsrs, allow(internal_features)))`
   这个属性宏同样用于条件编译。它允许在 `docsrs` 环境下使用内部特性，这些特性通常不推荐在普通代码中使用，因为它们可能会在未来的 Rust 版本中改变。

这些属性宏通常用于库的 `lib.rs` 或 `main.rs` 文件的顶部，以配置库的编译和文档生成行为。


1. `#![deny(clippy::question_mark_used)]`
   - 这行代码使用 `deny` 属性宏来禁止使用 `clippy::question_mark_used` lint。Clippy 是 Rust 的一个代码检查工具，它帮助开发者写出更符合 Rust 社区习惯的代码。`clippy::question_mark_used` lint 检查代码中是否使用了 `?` 操作符。`?` 操作符用于错误传播，如果一个函数返回 `Result` 或 `Option` 类型，并且调用方想要立即处理错误，那么可以使用 `?` 来简化代码。使用 `deny` 属性宏禁止这个 lint 意味着如果代码中使用了 `?` 操作符，编译将会失败。

2. `#![deny(missing_docs, unused_imports)]`
   - 这行代码同样使用 `deny` 属性宏来禁止两个特定的 lint：`missing_docs` 和 `unused_imports`。
     - `missing_docs` lint 检查代码是否缺少文档注释。Rust 社区鼓励为公共 API 提供文档，这个 lint 确保所有的公共函数、结构体、枚举等都有文档注释。
     - `unused_imports` lint 检查代码中是否有未使用的导入（imports）。未使用的导入可能会使代码变得混乱，并且可能会引入不必要的依赖。


1. `#[cfg(all(feature = "alloc", not(feature = "std")))]
   pub use alloc::borrow::{Cow, ToOwned};`
   - 这行代码使用 `cfg` 属性宏进行条件编译。`cfg` 宏允许开发者根据编译时的特征（features）来包含或排除代码。
   - `all` 函数用于确保所有列出的条件都必须为真，才能编译这段代码。
   - `feature = "alloc"` 检查是否启用了 `alloc` 特性。
   - `not(feature = "std")` 检查是否没有启用 `std` 特性。
   - 如果这两个条件都满足，那么 `Cow` 和 `ToOwned` 类型将从 `alloc::borrow` 模块中重新导出（pub use），使得它们可以在当前模块中直接使用。

2. `#[cfg(feature = "std")]
   pub use std::borrow::{Cow, ToOwned};`
   - 这行代码同样使用 `cfg` 属性宏进行条件编译。
   - `feature = "std"` 检查是否启用了 `std` 特性。
   - 如果启用了 `std` 特性，那么 `Cow` 和 `ToOwned` 类型将从 `std::borrow` 模块中重新导出。

这两段代码的目的是允许开发者根据是否启用了 `std` 特性来决定使用标准库的 `Cow` 和 `ToOwned` 类型，还是使用 `alloc` crate 提供的版本。`Cow`（Copy on Write）是一种智能指针，用于优化内存使用，而 `ToOwned` 是一个 trait，用于创建一个类型的所有权副本。

- 如果没有启用 `std` 特性，但启用了 `alloc` 特性，那么代码将使用 `alloc` crate 中的类型。
- 如果启用了 `std` 特性，那么代码将使用标准库中的类型。

这种条件编译的方式使得库可以在不同的环境下灵活使用，例如在嵌入式系统或 WebAssembly 中，可能不使用标准库，而是使用 `alloc` crate 来提供内存分配功能。

这行 Rust 代码用于模块声明和属性宏的使用，具体解释如下：

1. `#[macro_use]`
   - 这是一个属性宏，用于指定模块中的宏（macros）应该在当前作用域中可用。
   - 使用 `#[macro_use]` 属性宏，可以使得模块内的宏被自动导入到当前作用域中，而不需要显式地使用 `use` 语句。

2. `mod macros;`
   - 这是一个模块声明，它告诉 Rust 编译器有一个名为 `macros` 的模块。
   - `macros` 模块可能包含宏定义，这些宏定义在模块内部。

综合来看，这行代码的作用是：
- 声明一个名为 `macros` 的模块。
- 通过 `#[macro_use]` 属性宏，将 `macros` 模块中的宏自动导入到当前作用域中。

这样，你就可以在当前作用域中直接使用 `macros` 模块中定义的宏了。

### 示例

假设你有以下代码结构：

```rust
// 在 lib.rs 或 main.rs 中
#[macro_use]
mod macros;

fn main() {
    my_macro!();
}
```

和以下 `macros.rs` 文件：

```rust
// 在 macros.rs 中
#[macro_export]
macro_rules! my_macro {
    () => {
        println!("Hello from macro!");
    };
}
```

在这个例子中：
- `#[macro_use]` 属性宏使得 `macros` 模块中的宏自动导入到当前作用域。
- `mod macros;` 声明了一个名为 `macros` 的模块。
- 在 `main` 函数中，你可以直接使用 `my_macro!()` 宏，而不需要显式地使用 `use` 语句。

这样做的好处是简化了宏的导入过程，使得代码更加简洁。

`#[doc(no_inline)]` 是 Rust 语言中的一个属性宏，用于控制文档生成时的行为。具体来说，这个属性宏的作用是：

- **阻止内联文档**：当这个属性宏应用于一个函数、结构体、枚举、模块或其他项时，它会阻止 Rust 的文档生成工具 `rustdoc` 将该项的文档注释内联到引用它的地方。默认情况下，`rustdoc` 会将文档注释从源代码的位置复制到引用该项的每个地方。使用 `#[doc(no_inline)]` 可以覆盖这个默认行为。

这个属性通常用于以下情况：

1. **避免重复文档**：如果你不希望某个项的文档注释在文档中的多个地方重复出现，你可以使用 `#[doc(no_inline)]` 来防止这种情况。

2. **集中文档**：有时候，你可能希望所有的文档都在一个地方，而不是分散在多个引用点。使用这个属性宏可以确保文档只在一个地方生成，从而更容易维护。

### 示例

假设你有以下代码：

```rust
/// 文档注释
#[doc(no_inline)]
pub fn my_function() {
    // 函数实现
}
```

在这个例子中，`my_function` 的文档注释不会被 `rustdoc` 内联到引用 `my_function` 的地方。这意味着无论在文档的哪个地方引用了 `my_function`，都不会显示这个函数的文档注释，除非你直接查看 `my_function` 的文档页面。

使用 `#[doc(no_inline)]` 可以帮助你更精细地控制文档的布局和内容。

这段代码是 Rust 语言中使用属性宏的一个例子，用于条件编译和自定义诊断信息。让我们逐行分析：

1. `#[cfg_attr(...)]`
   - `cfg_attr` 是 Rust 的一个属性宏，它允许开发者根据特定的编译时配置（feature flags）来包含或排除代码。如果括号内的条件为真，则包含该属性宏后面的代码；如果条件为假，则忽略它。

2. `not(no_diagnostic_namespace)`
   - 这是 `cfg_attr` 宏的条件部分。`not` 是一个检查特征（feature）是否没有被定义的条件。这里检查的是没有定义 `no_diagnostic_namespace` 特征。

3. `diagnostic::on_unimplemented(...)`
   - 如果上面的条件满足（即没有定义 `no_diagnostic_namespace` 特征），则应用 `diagnostic::on_unimplemented` 属性宏。这个宏用于在某个 trait 没有为特定类型实现时，提供一个自定义的错误或提示信息。

4. `note = "for local types consider adding `#[derive(serde::Deserialize)]` to your `{Self}` type",`
   - 这是 `diagnostic::on_unimplemented` 宏的一个参数，提供了一个备注信息。当一个类型没有实现某个 trait，并且这个 trait 是序列化相关的（如 `serde::Deserialize`），这个备注会提示开发者考虑为他们的类型添加 `#[derive(serde::Deserialize)]` 宏。

5. `note = "for types from other crates check whether the crate offers a `serde` feature flag",`
   - 这是另一个备注信息，用于提示开发者如果类型来自其他 crate，应该检查那个 crate 是否提供了一个 `serde` 特性标志（feature flag），这可能允许使用序列化功能。

综合来看，这段代码的作用是：

- 当没有定义 `no_diagnostic_namespace` 特征时，如果某个类型没有实现 `serde::Deserialize` trait，编译器会提供一个自定义的错误提示，指导开发者如何解决问题。

这种自定义的诊断信息非常有用，因为它可以提供更清晰的错误信息和解决问题的指导，从而改善开发者的体验。

在 Rust 语言中，`#[inline]` 是一个属性宏，用于向编译器提供内联函数的提示。内联函数是一种优化手段，它建议编译器在每次调用函数时将函数的代码直接插入到调用点，而不是进行常规的函数调用。这样做可以减少函数调用的开销，特别是对于小型函数来说，可以提高程序的执行效率。不过，编译器并不保证一定会按照这个提示进行内联，最终是否内联由编译器的优化策略决定。

### 使用场景

1. **小型函数**：对于只有几行代码的小型函数，使用 `#[inline]` 可以减少函数调用的开销。

2. **递归函数**：对于递归函数，内联可以避免递归调用的开销。

3. **性能关键路径**：在性能敏感的代码路径上，内联可以减少函数调用的延迟。

### 示例

```rust
#[inline]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let result = add(2, 3);
    println!("The result is: {}", result);
}
```

在这个例子中，`add` 函数被标记为 `#[inline]`，建议编译器在每次调用 `add` 时将其内联。



### 注意事项

- **滥用内联**：过度使用内联可能会导致代码膨胀，增加编译时间，甚至可能降低性能，因为编译器可能无法优化大块的内联代码。

- **编译器的决策**：即使使用了 `#[inline]`，编译器也可能因为各种原因（如代码大小、调用频率等）而选择不进行内联。

- **跨模块内联**：默认情况下，只能在定义函数的模块内进行内联。如果需要跨模块内联，可以使用 `#[inline(always)]` 强制编译器进行内联，但这通常不推荐，因为它会使得代码更难维护。

总的来说，`#[inline]` 是一个有用的工具，但应该谨慎使用，以避免潜在的负面影响。


# mod超屌用法
```rust
// Used by generated code and doc tests. Not public API.
#[doc(hidden)]
#[path = "private/mod.rs"]
pub mod __private;

#[path = "de/seed.rs"]
mod seed;
```

这些属性宏用于控制 Rust 宏的导出行为和文档的可见性。下面是每行代码的作用：

1. `#[macro_export(local_inner_macros)]`
   - 这是一个属性宏，用于导出宏定义，使其在其他 crate 中可用。
   - `local_inner_macros` 是 `macro_export` 属性的一个选项，它允许宏在导出时能够访问当前模块中的内部宏。

2. `#[doc(hidden)]`
   - 这是一个属性宏，用于指示该宏在生成的文档中应该是隐藏的。
   - 当你不希望某个宏出现在文档中时，可以使用这个属性宏。

3. `#[macro_export]`
   - 这是另一个 `macro_export` 属性宏，同样用于导出宏定义。

4. `#[macro_export(local_inner_macros)]`
   - 这行代码与第一行相同，再次强调了宏的导出行为。

### 示例

假设你有以下宏定义：

```rust
// 在 lib.rs 或 main.rs 中
#[macro_export(local_inner_macros)]
#[doc(hidden)]
macro_rules! my_macro {
    () => {
        println!("Hello from macro!");
    };
}

#[macro_export]
#[macro_export(local_inner_macros)]
macro_rules! another_macro {
    () => {
        println!("Hello from another macro!");
    };
}
```

在这个例子中：
- `my_macro!` 宏被导出，并且可以在其他 crate 中使用。同时，它被标记为隐藏，不会出现在生成的文档中。
- `another_macro!` 宏也被导出，并且可以访问当前模块中的内部宏。

### 注意事项

- `#[macro_export(local_inner_macros)]` 属性宏的使用需要 Rust 1.56 版本或更高。
- 如果你多次使用相同的属性宏，只有最后一次会生效。所以在这个例子中，`another_macro!` 的 `#[macro_export]` 属性宏是多余的，因为后面的 `#[macro_export(local_inner_macros)]` 已经覆盖了它。

这些属性宏的使用可以帮助你更好地控制宏的可见性和导出行为。
