<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Craftinginterpreters/Welcome/A Map of the Territory" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">A Map of the Territory | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jabberwocky238.github.io/docs/Craftinginterpreters/Welcome/A Map of the Territory"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="A Map of the Territory | My Site"><meta data-rh="true" name="description" content="You must have a map, no matter how rough. Otherwise you wander all over the"><meta data-rh="true" property="og:description" content="You must have a map, no matter how rough. Otherwise you wander all over the"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/Welcome/A Map of the Territory"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/Welcome/A Map of the Territory" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/Welcome/A Map of the Territory" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0d35426a.css">
<script src="/assets/js/runtime~main.0868a236.js" defer="defer"></script>
<script src="/assets/js/main.f1c02528.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/english">English</a><button aria-label="展开侧边栏分类 &#x27;English&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/crafting-interpreter">Crafting-interpreter</a><button aria-label="折叠侧边栏分类 &#x27;Crafting-interpreter&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/welcome">Welcome</a><button aria-label="折叠侧边栏分类 &#x27;Welcome&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/Welcome/Introduction">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Craftinginterpreters/Welcome/A Map of the Territory">A Map of the Territory</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/not-translated-yet">not-translated-yet</a><button aria-label="展开侧边栏分类 &#x27;not-translated-yet&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/crafting-interpreter"><span itemprop="name">Crafting-interpreter</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/welcome"><span itemprop="name">Welcome</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">A Map of the Territory</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>A Map of the Territory</h1></header><blockquote>
<p>You must have a map, no matter how rough. Otherwise you wander all over the
place. In <em>The Lord of the Rings</em> I never made anyone go farther than he could
on a given day.</p>
<p><cite>J. R. R. Tolkien</cite></p>
</blockquote>
<p>We don&#x27;t want to wander all over the place, so before we set off, let&#x27;s scan
the territory charted by previous language implementers. It will help us
understand where we are going and the alternate routes others have taken.</p>
<p>First, let me establish a shorthand. Much of this book is about a language&#x27;s
<em>implementation</em>, which is distinct from the <em>language itself</em> in some sort of
Platonic ideal form. Things like &quot;stack&quot;, &quot;bytecode&quot;, and &quot;recursive descent&quot;,
are nuts and bolts one particular implementation might use. From the user&#x27;s
perspective, as long as the resulting contraption faithfully follows the
language&#x27;s specification, it&#x27;s all implementation detail.</p>
<p>We&#x27;re going to spend a lot of time on those details, so if I have to write
&quot;language <em>implementation</em>&quot; every single time I mention them, I&#x27;ll wear my
fingers off. Instead, I&#x27;ll use &quot;language&quot; to refer to either a language or an
implementation of it, or both, unless the distinction matters.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-parts-of-a-language">The Parts of a Language<a href="#the-parts-of-a-language" class="hash-link" aria-label="The Parts of a Language的直接链接" title="The Parts of a Language的直接链接">​</a></h2>
<p>Engineers have been building programming languages since the Dark Ages of
computing. As soon as we could talk to computers, we discovered doing so was too
hard, and we enlisted their help. I find it fascinating that even though today&#x27;s
machines are literally a million times faster and have orders of magnitude more
storage, the way we build programming languages is virtually unchanged.</p>
<p>Though the area explored by language designers is vast, the trails they&#x27;ve
carved through it are <span name="dead">few</span>. Not every language takes the
exact same path -- some take a shortcut or two -- but otherwise they are
reassuringly similar, from Rear Admiral Grace Hopper&#x27;s first COBOL compiler all
the way to some hot, new, transpile-to-JavaScript language whose &quot;documentation&quot;
consists entirely of a single, poorly edited README in a Git repository
somewhere.</p>
<aside name="dead">
<p>There are certainly dead ends, sad little cul-de-sacs of CS papers with zero
citations and now-forgotten optimizations that only made sense when memory was
measured in individual bytes.</p>
</aside>
<p>I visualize the network of paths an implementation may choose as climbing a
mountain. You start off at the bottom with the program as raw source text,
literally just a string of characters. Each phase analyzes the program and
transforms it to some higher-level representation where the semantics -- what
the author wants the computer to do -- become more apparent.</p>
<p>Eventually we reach the peak. We have a bird&#x27;s-eye view of the user&#x27;s program
and can see what their code <em>means</em>. We begin our descent down the other side of
the mountain. We transform this highest-level representation down to
successively lower-level forms to get closer and closer to something we know how
to make the CPU actually execute.</p>
<p><img decoding="async" loading="lazy" alt="The branching paths a language may take over the mountain." src="/assets/images/mountain-fb8894c489ca034a5178297e3681c993.png" width="1824" height="833" class="img_ev3q"></p>
<p>Let&#x27;s trace through each of those trails and points of interest. Our journey
begins on the left with the bare text of the user&#x27;s source code:</p>
<img decoding="async" loading="lazy" src="image/a-map-of-the-territory/string.png" alt="var average = (min + max) / 2;" class="img_ev3q">
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="scanning">Scanning<a href="#scanning" class="hash-link" aria-label="Scanning的直接链接" title="Scanning的直接链接">​</a></h3>
<p>The first step is <strong>scanning</strong>, also known as <strong>lexing</strong>, or (if you&#x27;re trying
to impress someone) <strong>lexical analysis</strong>. They all mean pretty much the same
thing. I like &quot;lexing&quot; because it sounds like something an evil supervillain
would do, but I&#x27;ll use &quot;scanning&quot; because it seems to be marginally more
commonplace.</p>
<p>第一步是扫描，也被叫做分词，或者(如果你想要震惊某些人)也可以叫做词法分析。
他们其实都一个意思。我喜欢分词，是因为听起来像是超级反派会做的事，但我会用扫描，因为它看上去稍显平凡。</p>
<p>A <strong>scanner</strong> (or <strong>lexer</strong>) takes in the linear stream of characters and chunks
them together into a series of something more akin to <span name="word">&quot;words&quot;</span>. In programming languages, each of these words is
called a <strong>token</strong>. Some tokens are single characters, like <code>(</code> and <code>,</code>. Others
may be several characters long, like numbers (<code>123</code>), string literals (<code>&quot;hi!&quot;</code>),
and identifiers (<code>min</code>).</p>
<p>一个扫描器(分词器)接受线性字符流，然后把他们分组成一系列更像单词的东西。在编程语言中，这些词被叫做token。一些token是单独的字符，像&amp;，其他的可能几个字符长，像数字，字符串字面量，标志符。</p>
<aside name="word">
<p>&quot;Lexical&quot; comes from the Greek root &quot;lex&quot;, meaning &quot;word&quot;.</p>
</aside>
<p>Some characters in a source file don&#x27;t actually mean anything. Whitespace is
often insignificant, and comments, by definition, are ignored by the language.
The scanner usually discards these, leaving a clean sequence of meaningful
tokens.</p>
<p>一些源码中的字符并没有任何意义。空格经常是不重要的，还有在定义上注释也会被语言所忽略。扫描器会抛弃这些留下了干净的，有意义的token序列。</p>
<img decoding="async" loading="lazy" src="image/a-map-of-the-territory/tokens.png" alt="[var] [average] [=] [(] [min] [+] [max] [)] [/] [2] [;]" class="img_ev3q">
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parsing">Parsing<a href="#parsing" class="hash-link" aria-label="Parsing的直接链接" title="Parsing的直接链接">​</a></h3>
<p>The next step is <strong>parsing</strong>. This is where our syntax gets a <strong>grammar</strong> -- the
ability to compose larger expressions and statements out of smaller parts. Did
you ever diagram sentences in English class? If so, you&#x27;ve done what a parser
does, except that English has thousands and thousands of &quot;keywords&quot; and an
overflowing cornucopia of ambiguity. Programming languages are much simpler.</p>
<p>A <strong>parser</strong> takes the flat sequence of tokens and builds a tree structure that
mirrors the nested nature of the grammar. These trees have a couple of different
names -- <strong>parse tree</strong> or <strong>abstract syntax tree</strong> -- depending on how
close to the bare syntactic structure of the source language they are. In
practice, language hackers usually call them <strong>syntax trees</strong>, <strong>ASTs</strong>, or
often just <strong>trees</strong>.</p>
<img decoding="async" loading="lazy" src="image/a-map-of-the-territory/ast.png" alt="An abstract syntax tree." class="img_ev3q">
<p>Parsing has a long, rich history in computer science that is closely tied to the
artificial intelligence community. Many of the techniques used today to parse
programming languages were originally conceived to parse <em>human</em> languages by AI
researchers who were trying to get computers to talk to us.</p>
<p>It turns out human languages were too messy for the rigid grammars those parsers
could handle, but they were a perfect fit for the simpler artificial grammars of
programming languages. Alas, we flawed humans still manage to use those simple
grammars incorrectly, so the parser&#x27;s job also includes letting us know when we
do by reporting <strong>syntax errors</strong>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="static-analysis">Static analysis<a href="#static-analysis" class="hash-link" aria-label="Static analysis的直接链接" title="Static analysis的直接链接">​</a></h3>
<p>The first two stages are pretty similar across all implementations. Now, the
individual characteristics of each language start coming into play. At this
point, we know the syntactic structure of the code -- things like which
expressions are nested in which -- but we don&#x27;t know much more than that.</p>
<p>In an expression like <code>a + b</code>, we know we are adding <code>a</code> and <code>b</code>, but we don&#x27;t
know what those names refer to. Are they local variables? Global? Where are they
defined?</p>
<p>The first bit of analysis that most languages do is called <strong>binding</strong> or
<strong>resolution</strong>. For each <strong>identifier</strong>, we find out where that name is defined
and wire the two together. This is where <strong>scope</strong> comes into play -- the region
of source code where a certain name can be used to refer to a certain
declaration.</p>
<p>If the language is <span name="type">statically typed</span>, this is when we
type check. Once we know where <code>a</code> and <code>b</code> are declared, we can also figure out
their types. Then if those types don&#x27;t support being added to each other, we
report a <strong>type error</strong>.</p>
<aside name="type">
<p>The language we&#x27;ll build in this book is dynamically typed, so it will do its
type checking later, at runtime.</p>
</aside>
<p>Take a deep breath. We have attained the summit of the mountain and a sweeping
view of the user&#x27;s program. All this semantic insight that is visible to us from
analysis needs to be stored somewhere. There are a few places we can squirrel it
away:</p>
<ul>
<li>
<p>Often, it gets stored right back as <strong>attributes</strong> on the syntax tree
itself -- extra fields in the nodes that aren&#x27;t initialized during parsing
but get filled in later.</p>
</li>
<li>
<p>Other times, we may store data in a lookup table off to the side. Typically,
the keys to this table are identifiers -- names of variables and declarations.
In that case, we call it a <strong>symbol table</strong> and the values it associates with
each key tell us what that identifier refers to.</p>
</li>
<li>
<p>The most powerful bookkeeping tool is to transform the tree into an entirely
new data structure that more directly expresses the semantics of the code.
That&#x27;s the next section.</p>
</li>
</ul>
<p>Everything up to this point is considered the <strong>front end</strong> of the
implementation. You might guess everything after this is the <strong>back end</strong>, but
no. Back in the days of yore when &quot;front end&quot; and &quot;back end&quot; were coined,
compilers were much simpler. Later researchers invented new phases to stuff
between the two halves. Rather than discard the old terms, William Wulf and
company lumped those new phases into the charming but spatially paradoxical name
<strong>middle end</strong>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="intermediate-representations">Intermediate representations<a href="#intermediate-representations" class="hash-link" aria-label="Intermediate representations的直接链接" title="Intermediate representations的直接链接">​</a></h3>
<p>You can think of the compiler as a pipeline where each stage&#x27;s job is to
organize the data representing the user&#x27;s code in a way that makes the next
stage simpler to implement. The front end of the pipeline is specific to the
source language the program is written in. The back end is concerned with the
final architecture where the program will run.</p>
<p>In the middle, the code may be stored in some <span name="ir"><strong>intermediate
representation</strong></span> (<strong>IR</strong>) that isn&#x27;t tightly tied to either the source or
destination forms (hence &quot;intermediate&quot;). Instead, the IR acts as an interface
between these two languages.</p>
<aside name="ir">
<p>There are a few well-established styles of IRs out there. Hit your search engine
of choice and look for &quot;control flow graph&quot;, &quot;static single-assignment&quot;,
&quot;continuation-passing style&quot;, and &quot;three-address code&quot;.</p>
</aside>
<p>This lets you support multiple source languages and target platforms with less
effort. Say you want to implement Pascal, C, and Fortran compilers, and you want
to target x86, ARM, and, I dunno, SPARC. Normally, that means you&#x27;re signing up
to write <em>nine</em> full compilers: Pascal→x86, C→ARM, and every other
combination.</p>
<p>A <span name="gcc">shared</span> intermediate representation reduces that
dramatically. You write <em>one</em> front end for each source language that produces
the IR. Then <em>one</em> back end for each target architecture. Now you can mix and
match those to get every combination.</p>
<aside name="gcc">
<p>If you&#x27;ve ever wondered how <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection" target="_blank" rel="noopener noreferrer">GCC</a> supports so many crazy languages and
architectures, like Modula-3 on Motorola 68k, now you know. Language front ends
target one of a handful of IRs, mainly <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html" target="_blank" rel="noopener noreferrer">GIMPLE</a> and <a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html" target="_blank" rel="noopener noreferrer">RTL</a>. Target back ends
like the one for 68k then take those IRs and produce native code.</p>
</aside>
<p>There&#x27;s another big reason we might want to transform the code into a form that
makes the semantics more apparent...</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="optimization">Optimization<a href="#optimization" class="hash-link" aria-label="Optimization的直接链接" title="Optimization的直接链接">​</a></h3>
<p>Once we understand what the user&#x27;s program means, we are free to swap it out
with a different program that has the <em>same semantics</em> but implements them more
efficiently -- we can <strong>optimize</strong> it.</p>
<p>A simple example is <strong>constant folding</strong>: if some expression always evaluates to
the exact same value, we can do the evaluation at compile time and replace the
code for the expression with its result. If the user typed in this:</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>we could do all of that arithmetic in the compiler and change the code to:</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pennyArea = 0.4417860938;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Optimization is a huge part of the programming language business. Many language
hackers spend their entire careers here, squeezing every drop of performance
they can out of their compilers to get their benchmarks a fraction of a percent
faster. It can become a sort of obsession.</p>
<p>We&#x27;re mostly going to <span name="rathole">hop over that rathole</span> in this
book. Many successful languages have surprisingly few compile-time
optimizations. For example, Lua and CPython generate relatively unoptimized
code, and focus most of their performance effort on the runtime.</p>
<aside name="rathole">
<p>If you can&#x27;t resist poking your foot into that hole, some keywords to get you
started are &quot;constant propagation&quot;, &quot;common subexpression elimination&quot;, &quot;loop
invariant code motion&quot;, &quot;global value numbering&quot;, &quot;strength reduction&quot;, &quot;scalar
replacement of aggregates&quot;, &quot;dead code elimination&quot;, and &quot;loop unrolling&quot;.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="code-generation">Code generation<a href="#code-generation" class="hash-link" aria-label="Code generation的直接链接" title="Code generation的直接链接">​</a></h3>
<p>We have applied all of the optimizations we can think of to the user&#x27;s program.
The last step is converting it to a form the machine can actually run. In other
words, <strong>generating code</strong> (or <strong>code gen</strong>), where &quot;code&quot; here usually refers to
the kind of primitive assembly-like instructions a CPU runs and not the kind of
&quot;source code&quot; a human might want to read.</p>
<p>Finally, we are in the <strong>back end</strong>, descending the other side of the mountain.
From here on out, our representation of the code becomes more and more
primitive, like evolution run in reverse, as we get closer to something our
simple-minded machine can understand.</p>
<p>We have a decision to make. Do we generate instructions for a real CPU or a
virtual one? If we generate real machine code, we get an executable that the OS
can load directly onto the chip. Native code is lightning fast, but generating
it is a lot of work. Today&#x27;s architectures have piles of instructions, complex
pipelines, and enough <span name="aad">historical baggage</span> to fill a 747&#x27;s
luggage bay.</p>
<p>Speaking the chip&#x27;s language also means your compiler is tied to a specific
architecture. If your compiler targets <a href="https://en.wikipedia.org/wiki/X86" target="_blank" rel="noopener noreferrer">x86</a> machine code, it&#x27;s not going to
run on an <a href="https://en.wikipedia.org/wiki/ARM_architecture" target="_blank" rel="noopener noreferrer">ARM</a> device. All the way back in the &#x27;60s, during the
Cambrian explosion of computer architectures, that lack of portability was a
real obstacle.</p>
<aside name="aad">
<p>For example, the <a href="http://www.felixcloutier.com/x86/AAD.html" target="_blank" rel="noopener noreferrer">AAD</a> (&quot;ASCII Adjust AX Before Division&quot;) instruction lets
you perform division, which sounds useful. Except that instruction takes, as
operands, two binary-coded decimal digits packed into a single 16-bit register.
When was the last time <em>you</em> needed BCD on a 16-bit machine?</p>
</aside>
<p>To get around that, hackers like Martin Richards and Niklaus Wirth, of BCPL and
Pascal fame, respectively, made their compilers produce <em>virtual</em> machine code.
Instead of instructions for some real chip, they produced code for a
hypothetical, idealized machine. Wirth called this <strong>p-code</strong> for <em>portable</em>,
but today, we generally call it <strong>bytecode</strong> because each instruction is often a
single byte long.</p>
<p>These synthetic instructions are designed to map a little more closely to the
language&#x27;s semantics, and not be so tied to the peculiarities of any one
computer architecture and its accumulated historical cruft. You can think of it
like a dense, binary encoding of the language&#x27;s low-level operations.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="virtual-machine">Virtual machine<a href="#virtual-machine" class="hash-link" aria-label="Virtual machine的直接链接" title="Virtual machine的直接链接">​</a></h3>
<p>If your compiler produces bytecode, your work isn&#x27;t over once that&#x27;s done. Since
there is no chip that speaks that bytecode, it&#x27;s your job to translate. Again,
you have two options. You can write a little mini-compiler for each target
architecture that converts the bytecode to native code for that machine. You
still have to do work for <span name="shared">each</span> chip you support, but
this last stage is pretty simple and you get to reuse the rest of the compiler
pipeline across all of the machines you support. You&#x27;re basically using your
bytecode as an intermediate representation.</p>
<aside name="shared" class="bottom">
<p>The basic principle here is that the farther down the pipeline you push the
architecture-specific work, the more of the earlier phases you can share across
architectures.</p>
<p>There is a tension, though. Many optimizations, like register allocation and
instruction selection, work best when they know the strengths and capabilities
of a specific chip. Figuring out which parts of your compiler can be shared and
which should be target-specific is an art.</p>
</aside>
<p>Or you can write a <span name="vm"><strong>virtual machine</strong></span> (<strong>VM</strong>), a
program that emulates a hypothetical chip supporting your virtual architecture
at runtime. Running bytecode in a VM is slower than translating it to native
code ahead of time because every instruction must be simulated at runtime each
time it executes. In return, you get simplicity and portability. Implement your
VM in, say, C, and you can run your language on any platform that has a C
compiler. This is how the second interpreter we build in this book works.</p>
<aside name="vm">
<p>The term &quot;virtual machine&quot; also refers to a different kind of abstraction. A
<strong>system virtual machine</strong> emulates an entire hardware platform and operating
system in software. This is how you can play Windows games on your Linux
machine, and how cloud providers give customers the user experience of
controlling their own &quot;server&quot; without needing to physically allocate separate
computers for each user.</p>
<p>The kind of VMs we&#x27;ll talk about in this book are <strong>language virtual machines</strong>
or <strong>process virtual machines</strong> if you want to be unambiguous.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="runtime">Runtime<a href="#runtime" class="hash-link" aria-label="Runtime的直接链接" title="Runtime的直接链接">​</a></h3>
<p>We have finally hammered the user&#x27;s program into a form that we can execute. The
last step is running it. If we compiled it to machine code, we simply tell the
operating system to load the executable and off it goes. If we compiled it to
bytecode, we need to start up the VM and load the program into that.</p>
<p>In both cases, for all but the basest of low-level languages, we usually need
some services that our language provides while the program is running. For
example, if the language automatically manages memory, we need a garbage
collector going in order to reclaim unused bits. If our language supports
&quot;instance of&quot; tests so you can see what kind of object you have, then we need
some representation to keep track of the type of each object during execution.</p>
<p>All of this stuff is going at runtime, so it&#x27;s called, appropriately, the
<strong>runtime</strong>. In a fully compiled language, the code implementing the runtime
gets inserted directly into the resulting executable. In, say, <a href="https://golang.org/" target="_blank" rel="noopener noreferrer">Go</a>, each
compiled application has its own copy of Go&#x27;s runtime directly embedded in it.
If the language is run inside an interpreter or VM, then the runtime lives
there. This is how most implementations of languages like Java, Python, and
JavaScript work.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="shortcuts-and-alternate-routes">Shortcuts and Alternate Routes<a href="#shortcuts-and-alternate-routes" class="hash-link" aria-label="Shortcuts and Alternate Routes的直接链接" title="Shortcuts and Alternate Routes的直接链接">​</a></h2>
<p>That&#x27;s the long path covering every possible phase you might implement. Many
languages do walk the entire route, but there are a few shortcuts and alternate
paths.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="single-pass-compilers">Single-pass compilers<a href="#single-pass-compilers" class="hash-link" aria-label="Single-pass compilers的直接链接" title="Single-pass compilers的直接链接">​</a></h3>
<p>Some simple compilers interleave parsing, analysis, and code generation so that
they produce output code directly in the parser, without ever allocating any
syntax trees or other IRs. These <span name="sdt"><strong>single-pass
compilers</strong></span> restrict the design of the language. You have no intermediate
data structures to store global information about the program, and you don&#x27;t
revisit any previously parsed part of the code. That means as soon as you see
some expression, you need to know enough to correctly compile it.</p>
<aside name="sdt">
<p><a href="https://en.wikipedia.org/wiki/Syntax-directed_translation" target="_blank" rel="noopener noreferrer"><strong>Syntax-directed translation</strong></a> is a structured technique for building
these all-at-once compilers. You associate an <em>action</em> with each piece of the
grammar, usually one that generates output code. Then, whenever the parser
matches that chunk of syntax, it executes the action, building up the target
code one rule at a time.</p>
</aside>
<p>Pascal and C were designed around this limitation. At the time, memory was so
precious that a compiler might not even be able to hold an entire <em>source file</em>
in memory, much less the whole program. This is why Pascal&#x27;s grammar requires
type declarations to appear first in a block. It&#x27;s why in C you can&#x27;t call a
function above the code that defines it unless you have an explicit forward
declaration that tells the compiler what it needs to know to generate code for a
call to the later function.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tree-walk-interpreters">Tree-walk interpreters<a href="#tree-walk-interpreters" class="hash-link" aria-label="Tree-walk interpreters的直接链接" title="Tree-walk interpreters的直接链接">​</a></h3>
<p>Some programming languages begin executing code right after parsing it to an AST
(with maybe a bit of static analysis applied). To run the program, the
interpreter traverses the syntax tree one branch and leaf at a time, evaluating
each node as it goes.</p>
<p>This implementation style is common for student projects and little languages,
but is not widely used for <span name="ruby">general-purpose</span> languages
since it tends to be slow. Some people use &quot;interpreter&quot; to mean only these
kinds of implementations, but others define that word more generally, so I&#x27;ll
use the inarguably explicit <strong>tree-walk interpreter</strong> to refer to these. Our
first interpreter rolls this way.</p>
<aside name="ruby">
<p>A notable exception is early versions of Ruby, which were tree walkers. At 1.9,
the canonical implementation of Ruby switched from the original MRI (Matz&#x27;s Ruby
Interpreter) to Koichi Sasada&#x27;s YARV (Yet Another Ruby VM). YARV is a
bytecode virtual machine.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="transpilers">Transpilers<a href="#transpilers" class="hash-link" aria-label="Transpilers的直接链接" title="Transpilers的直接链接">​</a></h3>
<p><span name="gary">Writing</span> a complete back end for a language can be a lot
of work. If you have some existing generic IR to target, you could bolt your
front end onto that. Otherwise, it seems like you&#x27;re stuck. But what if you
treated some other <em>source language</em> as if it were an intermediate
representation?</p>
<p>You write a front end for your language. Then, in the back end, instead of doing
all the work to <em>lower</em> the semantics to some primitive target language, you
produce a string of valid source code for some other language that&#x27;s about as
high level as yours. Then, you use the existing compilation tools for <em>that</em>
language as your escape route off the mountain and down to something you can
execute.</p>
<p>They used to call this a <strong>source-to-source compiler</strong> or a <strong>transcompiler</strong>.
After the rise of languages that compile to JavaScript in order to run in the
browser, they&#x27;ve affected the hipster sobriquet <strong>transpiler</strong>.</p>
<aside name="gary">
<p>The first transcompiler, XLT86, translated 8080 assembly into 8086 assembly.
That might seem straightforward, but keep in mind the 8080 was an 8-bit chip and
the 8086 a 16-bit chip that could use each register as a pair of 8-bit ones.
XLT86 did data flow analysis to track register usage in the source program and
then efficiently map it to the register set of the 8086.</p>
<p>It was written by Gary Kildall, a tragic hero of computer science if there
ever was one. One of the first people to recognize the promise of
microcomputers, he created PL/M and CP/M, the first high-level language and OS
for them.</p>
<p>He was a sea captain, business owner, licensed pilot, and motorcyclist. A TV
host with the Kris Kristofferson-esque look sported by dashing bearded dudes in
the &#x27;80s. He took on Bill Gates and, like many, lost, before meeting his end in
a biker bar under mysterious circumstances. He died too young, but sure as hell
lived before he did.</p>
</aside>
<p>While the first transcompiler translated one assembly language to another,
today, most transpilers work on higher-level languages. After the viral spread
of UNIX to machines various and sundry, there began a long tradition of
compilers that produced C as their output language. C compilers were available
everywhere UNIX was and produced efficient code, so targeting C was a good way
to get your language running on a lot of architectures.</p>
<p>Web browsers are the &quot;machines&quot; of today, and their &quot;machine code&quot; is
JavaScript, so these days it seems <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js" target="_blank" rel="noopener noreferrer">almost every language out there</a> has a
compiler that targets JS since that&#x27;s the <span name="js">main</span> way to get
your code running in a browser.</p>
<aside name="js">
<p>JS used to be the <em>only</em> way to execute code in a browser. Thanks to
<a href="https://github.com/webassembly/" target="_blank" rel="noopener noreferrer">WebAssembly</a>, compilers now have a second, lower-level language they can
target that runs on the web.</p>
</aside>
<p>The front end -- scanner and parser -- of a transpiler looks like other
compilers. Then, if the source language is only a simple syntactic skin over the
target language, it may skip analysis entirely and go straight to outputting the
analogous syntax in the destination language.</p>
<p>If the two languages are more semantically different, you&#x27;ll see more of the
typical phases of a full compiler including analysis and possibly even
optimization. Then, when it comes to code generation, instead of outputting some
binary language like machine code, you produce a string of grammatically correct
source (well, destination) code in the target language.</p>
<p>Either way, you then run that resulting code through the output language&#x27;s
existing compilation pipeline, and you&#x27;re good to go.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="just-in-time-compilation">Just-in-time compilation<a href="#just-in-time-compilation" class="hash-link" aria-label="Just-in-time compilation的直接链接" title="Just-in-time compilation的直接链接">​</a></h3>
<p>This last one is less a shortcut and more a dangerous alpine scramble best
reserved for experts. The fastest way to execute code is by compiling it to
machine code, but you might not know what architecture your end user&#x27;s machine
supports. What to do?</p>
<p>You can do the same thing that the HotSpot Java Virtual Machine (JVM),
Microsoft&#x27;s Common Language Runtime (CLR), and most JavaScript interpreters do.
On the end user&#x27;s machine, when the program is loaded -- either from source in
the case of JS, or platform-independent bytecode for the JVM and CLR -- you
compile it to native code for the architecture their computer supports.
Naturally enough, this is called <strong>just-in-time compilation</strong>. Most hackers just
say &quot;JIT&quot;, pronounced like it rhymes with &quot;fit&quot;.</p>
<p>The most sophisticated JITs insert profiling hooks into the generated code to
see which regions are most performance critical and what kind of data is flowing
through them. Then, over time, they will automatically recompile those <span name="hot">hot spots</span> with more advanced optimizations.</p>
<aside name="hot">
<p>This is, of course, exactly where the HotSpot JVM gets its name.</p>
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="compilers-and-interpreters">Compilers and Interpreters<a href="#compilers-and-interpreters" class="hash-link" aria-label="Compilers and Interpreters的直接链接" title="Compilers and Interpreters的直接链接">​</a></h2>
<p>Now that I&#x27;ve stuffed your head with a dictionary&#x27;s worth of programming
language jargon, we can finally address a question that&#x27;s plagued coders since
time immemorial: What&#x27;s the difference between a compiler and an interpreter?</p>
<p>It turns out this is like asking the difference between a fruit and a vegetable.
That seems like a binary either-or choice, but actually &quot;fruit&quot; is a <em>botanical</em>
term and &quot;vegetable&quot; is <em>culinary</em>. One does not strictly imply the negation of
the other. There are fruits that aren&#x27;t vegetables (apples) and vegetables that
aren&#x27;t fruits (carrots), but also edible plants that are both fruits <em>and</em>
vegetables, like tomatoes.</p>
<p><span name="veg"></span></p>
<img decoding="async" loading="lazy" src="image/a-map-of-the-territory/plants.png" alt="A Venn diagram of edible plants" class="img_ev3q">
<aside name="veg">
<p>Peanuts (which are not even nuts) and cereals like wheat are actually fruit, but
I got this drawing wrong. What can I say, I&#x27;m a software engineer, not a
botanist. I should probably erase the little peanut guy, but he&#x27;s so cute that I
can&#x27;t bear to.</p>
<p>Now <em>pine nuts</em>, on the other hand, are plant-based foods that are neither
fruits nor vegetables. At least as far as I can tell.</p>
</aside>
<p>So, back to languages:</p>
<ul>
<li>
<p><strong>Compiling</strong> is an <em>implementation technique</em> that involves translating a
source language to some other -- usually lower-level -- form. When you
generate bytecode or machine code, you are compiling. When you transpile to
another high-level language, you are compiling too.</p>
</li>
<li>
<p>When we say a language implementation &quot;is a <strong>compiler</strong>&quot;, we mean it
translates source code to some other form but doesn&#x27;t execute it. The user has
to take the resulting output and run it themselves.</p>
</li>
<li>
<p>Conversely, when we say an implementation &quot;is an <strong>interpreter</strong>&quot;, we mean it
takes in source code and executes it immediately. It runs programs &quot;from
source&quot;.</p>
</li>
</ul>
<p>Like apples and oranges, some implementations are clearly compilers and <em>not</em>
interpreters. GCC and Clang take your C code and compile it to machine code. An
end user runs that executable directly and may never even know which tool was
used to compile it. So those are <em>compilers</em> for C.</p>
<p>In older versions of Matz&#x27;s canonical implementation of Ruby, the user ran Ruby
from source. The implementation parsed it and executed it directly by traversing
the syntax tree. No other translation occurred, either internally or in any
user-visible form. So this was definitely an <em>interpreter</em> for Ruby.</p>
<p>But what of CPython? When you run your Python program using it, the code is
parsed and converted to an internal bytecode format, which is then executed
inside the VM. From the user&#x27;s perspective, this is clearly an interpreter --
they run their program from source. But if you look under CPython&#x27;s scaly skin,
you&#x27;ll see that there is definitely some compiling going on.</p>
<p>The answer is that it is <span name="go">both</span>. CPython <em>is</em> an
interpreter, and it <em>has</em> a compiler. In practice, most scripting languages work
this way, as you can see:</p>
<aside name="go">
<p>The <a href="https://golang.org/" target="_blank" rel="noopener noreferrer">Go tool</a> is even more of a horticultural curiosity. If you run <code>go build</code>, it compiles your Go source code to machine code and stops. If you type
<code>go run</code>, it does that, then immediately executes the generated executable.</p>
<p>So <code>go</code> <em>is</em> a compiler (you can use it as a tool to compile code without
running it), <em>is</em> an interpreter (you can invoke it to immediately run a program
from source), and also <em>has</em> a compiler (when you use it as an interpreter, it
is still compiling internally).</p>
</aside>
<img decoding="async" loading="lazy" src="image/a-map-of-the-territory/venn.png" alt="A Venn diagram of compilers and interpreters" class="img_ev3q">
<p>That overlapping region in the center is where our second interpreter lives too,
since it internally compiles to bytecode. So while this book is nominally about
interpreters, we&#x27;ll cover some compilation too.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="our-journey">Our Journey<a href="#our-journey" class="hash-link" aria-label="Our Journey的直接链接" title="Our Journey的直接链接">​</a></h2>
<p>That&#x27;s a lot to take in all at once. Don&#x27;t worry. This isn&#x27;t the chapter where
you&#x27;re expected to <em>understand</em> all of these pieces and parts. I just want you
to know that they are out there and roughly how they fit together.</p>
<p>This map should serve you well as you explore the territory beyond the guided
path we take in this book. I want to leave you yearning to strike out on your
own and wander all over that mountain.</p>
<p>But, for now, it&#x27;s time for our own journey to begin. Tighten your bootlaces,
cinch up your pack, and come along. From <span name="here">here</span> on out,
all you need to focus on is the path in front of you.</p>
<aside name="here">
<p>Henceforth, I promise to tone down the whole mountain metaphor thing.</p>
</aside>
<div class="challenges">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h2>
<ol>
<li>
<p>Pick an open source implementation of a language you like. Download the
source code and poke around in it. Try to find the code that implements the
scanner and parser. Are they handwritten, or generated using tools like
Lex and Yacc? (<code>.l</code> or <code>.y</code> files usually imply the latter.)</p>
</li>
<li>
<p>Just-in-time compilation tends to be the fastest way to implement dynamically
typed languages, but not all of them use it. What reasons are there to <em>not</em>
JIT?</p>
</li>
<li>
<p>Most Lisp implementations that compile to C also contain an interpreter that
lets them execute Lisp code on the fly as well. Why?</p>
</li>
</ol>
</div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/Welcome/A Map of the Territory.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Craftinginterpreters/Welcome/Introduction"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Introduction</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/category/not-translated-yet"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">not-translated-yet</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#the-parts-of-a-language" class="table-of-contents__link toc-highlight">The Parts of a Language</a><ul><li><a href="#scanning" class="table-of-contents__link toc-highlight">Scanning</a></li><li><a href="#parsing" class="table-of-contents__link toc-highlight">Parsing</a></li><li><a href="#static-analysis" class="table-of-contents__link toc-highlight">Static analysis</a></li><li><a href="#intermediate-representations" class="table-of-contents__link toc-highlight">Intermediate representations</a></li><li><a href="#optimization" class="table-of-contents__link toc-highlight">Optimization</a></li><li><a href="#code-generation" class="table-of-contents__link toc-highlight">Code generation</a></li><li><a href="#virtual-machine" class="table-of-contents__link toc-highlight">Virtual machine</a></li><li><a href="#runtime" class="table-of-contents__link toc-highlight">Runtime</a></li></ul></li><li><a href="#shortcuts-and-alternate-routes" class="table-of-contents__link toc-highlight">Shortcuts and Alternate Routes</a><ul><li><a href="#single-pass-compilers" class="table-of-contents__link toc-highlight">Single-pass compilers</a></li><li><a href="#tree-walk-interpreters" class="table-of-contents__link toc-highlight">Tree-walk interpreters</a></li><li><a href="#transpilers" class="table-of-contents__link toc-highlight">Transpilers</a></li><li><a href="#just-in-time-compilation" class="table-of-contents__link toc-highlight">Just-in-time compilation</a></li></ul></li><li><a href="#compilers-and-interpreters" class="table-of-contents__link toc-highlight">Compilers and Interpreters</a></li><li><a href="#our-journey" class="table-of-contents__link toc-highlight">Our Journey</a></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>