<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Craftinginterpreters/not-translated-yet/resolving-and-binding" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">resolving-and-binding | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="resolving-and-binding | My Site"><meta data-rh="true" name="description" content="Once in a while you find yourself in an odd situation. You get into it by"><meta data-rh="true" property="og:description" content="Once in a while you find yourself in an odd situation. You get into it by"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0d35426a.css">
<script src="/assets/js/runtime~main.0868a236.js" defer="defer"></script>
<script src="/assets/js/main.f1c02528.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/english">English</a><button aria-label="展开侧边栏分类 &#x27;English&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/crafting-interpreter">Crafting-interpreter</a><button aria-label="折叠侧边栏分类 &#x27;Crafting-interpreter&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/welcome">Welcome</a><button aria-label="展开侧边栏分类 &#x27;Welcome&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/not-translated-yet">not-translated-yet</a><button aria-label="折叠侧边栏分类 &#x27;not-translated-yet&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-bytecode-virtual-machine">a-bytecode-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-tree-walk-interpreter">a-tree-walk-interpreter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine">a-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/acknowledgements">acknowledgements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-i">appendix-i</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii">appendix-ii</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/backmatter">backmatter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/calls-and-functions">calls-and-functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode">chunks-of-bytecode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes-and-instances">classes-and-instances</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes">classes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/closures">closures</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/compiling-expressions">compiling-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/contents">contents</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/control-flow">control-flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/dedication">dedication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions">evaluating-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/functions">functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection">garbage-collection</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/global-variables">global-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/hash-tables">hash-tables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/inheritance">inheritance</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth">jumping-back-and-forth</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/local-variables">local-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/methods-and-initializers">methods-and-initializers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/optimization">optimization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/parsing-expressions">parsing-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/representing-code">representing-code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding">resolving-and-binding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand">scanning-on-demand</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning">scanning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/statements-and-state">statements-and-state</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/strings">strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/superclasses">superclasses</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/the-lox-language">the-lox-language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/types-of-values">types-of-values</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/crafting-interpreter"><span itemprop="name">Crafting-interpreter</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/not-translated-yet"><span itemprop="name">not-translated-yet</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">resolving-and-binding</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>resolving-and-binding</h1></header><blockquote>
<p>Once in a while you find yourself in an odd situation. You get into it by
degrees and in the most natural way but, when you are right in the midst of
it, you are suddenly astonished and ask yourself how in the world it all came
about.</p>
<p><cite>Thor Heyerdahl, <em>Kon-Tiki</em></cite></p>
</blockquote>
<p>Oh, no! Our language implementation is taking on water! Way back when we <a href="/docs/Craftinginterpreters/not-translated-yet/statements-and-state.html">added
variables and blocks</a>, we had scoping nice and tight. But when we
<a href="/docs/Craftinginterpreters/not-translated-yet/functions.html">later added closures</a>, a hole opened in our formerly waterproof
interpreter. Most real programs are unlikely to slip through this hole, but as
language implementers, we take a sacred vow to care about correctness even in
the deepest, dampest corners of the semantics.</p>
<p>We will spend this entire chapter exploring that leak, and then carefully
patching it up. In the process, we will gain a more rigorous understanding of
lexical scoping as used by Lox and other languages in the C tradition. We&#x27;ll
also get a chance to learn about <em>semantic analysis</em> -- a powerful technique for
extracting meaning from the user&#x27;s source code without having to run it.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="static-scope">Static Scope<a href="#static-scope" class="hash-link" aria-label="Static Scope的直接链接" title="Static Scope的直接链接">​</a></h2>
<p>A quick refresher: Lox, like most modern languages, uses <em>lexical</em> scoping. This
means that you can figure out which declaration a variable name refers to just
by reading the text of the program. For example:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;outer&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;inner&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Here, we know that the <code>a</code> being printed is the variable declared on the
previous line, and not the global one. Running the program doesn&#x27;t -- <em>can&#x27;t</em> --
affect this. The scope rules are part of the <em>static</em> semantics of the language,
which is why they&#x27;re also called <em>static scope</em>.</p>
<p>I haven&#x27;t spelled out those scope rules, but now is the time for <span name="precise">precision</span>:</p>
<aside name="precise">
<p>This is still nowhere near as precise as a real language specification. Those
docs must be so explicit that even a Martian or an outright malicious programmer
would be forced to implement the correct semantics provided they followed the
letter of the spec.</p>
<p>That exactitude is important when a language may be implemented by competing
companies who want their product to be incompatible with the others to lock
customers onto their platform. For this book, we can thankfully ignore those
kinds of shady shenanigans.</p>
</aside>
<p><strong>A variable usage refers to the preceding declaration with the same name in the
innermost scope that encloses the expression where the variable is used.</strong></p>
<p>There&#x27;s a lot to unpack in that:</p>
<ul>
<li>
<p>I say &quot;variable usage&quot; instead of &quot;variable expression&quot; to cover both
variable expressions and assignments. Likewise with &quot;expression where the
variable is used&quot;.</p>
</li>
<li>
<p>&quot;Preceding&quot; means appearing before <em>in the program text</em>.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;outer&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;inner&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Here, the <code>a</code> being printed is the outer one since it appears <span name="hoisting">before</span> the <code>print</code> statement that uses it. In most
cases, in straight line code, the declaration preceding in <em>text</em> will also
precede the usage in <em>time</em>. But that&#x27;s not always true. As we&#x27;ll see,
functions may defer a chunk of code such that its <em>dynamic temporal</em>
execution no longer mirrors the <em>static textual</em> ordering.</p>
<aside name="hoisting">
<p>In JavaScript, variables declared using <code>var</code> are implicitly &quot;hoisted&quot; to
the beginning of the block. Any use of that name in the block will refer to
that variable, even if the use appears before the declaration. When you
write this in JavaScript:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">a</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">var</span><span class="token plain"> a </span><span class="token operator">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;value&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>It behaves like:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">var</span><span class="token plain"> a</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(98, 114, 164)">// Hoist.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">a</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  a </span><span class="token operator">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;value&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>That means that in some cases you can read a variable before its initializer
has run -- an annoying source of bugs. The alternate <code>let</code> syntax for
declaring variables was added later to address this problem.</p>
</aside>
</li>
<li>
<p>&quot;Innermost&quot; is there because of our good friend shadowing. There may be more
than one variable with the given name in enclosing scopes, as in:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;outer&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;inner&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Our rule disambiguates this case by saying the innermost scope wins.</p>
</li>
</ul>
<p>Since this rule makes no mention of any runtime behavior, it implies that a
variable expression always refers to the same declaration through the entire
execution of the program. Our interpreter so far <em>mostly</em> implements the rule
correctly. But when we added closures, an error snuck in.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;global&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun showA() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  showA();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;block&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  showA();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><span name="tricky">Before</span> you type this in and run it, decide what you
think it <em>should</em> print.</p>
<aside name="tricky">
<p>I know, it&#x27;s a totally pathological, contrived program. It&#x27;s just <em>weird</em>. No
reasonable person would ever write code like this. Alas, more of your life than
you&#x27;d expect will be spent dealing with bizarro snippets of code like this if
you stay in the programming language game for long.</p>
</aside>
<p>OK... got it? If you&#x27;re familiar with closures in other languages, you&#x27;ll expect
it to print &quot;global&quot; twice. The first call to <code>showA()</code> should definitely print
&quot;global&quot; since we haven&#x27;t even reached the declaration of the inner <code>a</code> yet. And
by our rule that a variable expression always resolves to the same variable,
that implies the second call to <code>showA()</code> should print the same thing.</p>
<p>Alas, it prints:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">global</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">block</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Let me stress that this program never reassigns any variable and contains only a
single <code>print</code> statement. Yet, somehow, that <code>print</code> statement for a
never-assigned variable prints two different values at different points in time.
We definitely broke something somewhere.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="scopes-and-mutable-environments">Scopes and mutable environments<a href="#scopes-and-mutable-environments" class="hash-link" aria-label="Scopes and mutable environments的直接链接" title="Scopes and mutable environments的直接 链接">​</a></h3>
<p>In our interpreter, environments are the dynamic manifestation of static scopes.
The two mostly stay in sync with each other -- we create a new environment when
we enter a new scope, and discard it when we leave the scope. There is one other
operation we perform on environments: binding a variable in one. This is where
our bug lies.</p>
<p>Let&#x27;s walk through that problematic example and see what the environments look
like at each step. First, we declare <code>a</code> in the global scope.</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/environment-1.png" alt="The global environment with &#x27;a&#x27; defined in it." class="img_ev3q">
<p>That gives us a single environment with a single variable in it. Then we enter
the block and execute the declaration of <code>showA()</code>.</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/environment-2.png" alt="A block environment linking to the global one." class="img_ev3q">
<p>We get a new environment for the block. In that, we declare one name, <code>showA</code>,
which is bound to the LoxFunction object we create to represent the function.
That object has a <code>closure</code> field that captures the environment where the
function was declared, so it has a reference back to the environment for the
block.</p>
<p>Now we call <code>showA()</code>.</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/environment-3.png" alt="An empty environment for showA()&#x27;s body linking to the previous two. &#x27;a&#x27; is resolved in the global environment." class="img_ev3q">
<p>The interpreter dynamically creates a new environment for the function body of
<code>showA()</code>. It&#x27;s empty since that function doesn&#x27;t declare any variables. The
parent of that environment is the function&#x27;s closure -- the outer block
environment.</p>
<p>Inside the body of <code>showA()</code>, we print the value of <code>a</code>. The interpreter looks
up this value by walking the chain of environments. It gets all the way
to the global environment before finding it there and printing <code>&quot;global&quot;</code>.
Great.</p>
<p>Next, we declare the second <code>a</code>, this time inside the block.</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/environment-4.png" alt="The block environment has both &#x27;a&#x27; and &#x27;showA&#x27; now." class="img_ev3q">
<p>It&#x27;s in the same block -- the same scope -- as <code>showA()</code>, so it goes into the
same environment, which is also the same environment <code>showA()</code>&#x27;s closure refers
to. This is where it gets interesting. We call <code>showA()</code> again.</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/environment-5.png" alt="An empty environment for showA()&#x27;s body linking to the previous two. &#x27;a&#x27; is resolved in the block environment." class="img_ev3q">
<p>We create a new empty environment for the body of <code>showA()</code> again, wire it up to
that closure, and run the body. When the interpreter walks the chain of
environments to find <code>a</code>, it now discovers the <em>new</em> <code>a</code> in the block
environment. Boo.</p>
<p>I chose to implement environments in a way that I hoped would agree with your
informal intuition around scopes. We tend to consider all of the code within a
block as being within the same scope, so our interpreter uses a single
environment to represent that. Each environment is a mutable hash table. When a
new local variable is declared, it gets added to the existing environment for
that scope.</p>
<p>That intuition, like many in life, isn&#x27;t quite right. A block is not necessarily
all the same scope. Consider:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // 1.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var b;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // 2.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>At the first marked line, only <code>a</code> is in scope. At the second line, both <code>a</code> and
<code>b</code> are. If you define a &quot;scope&quot; to be a set of declarations, then those are
clearly not the same scope -- they don&#x27;t contain the same declarations. It&#x27;s
like each <code>var</code> statement <span name="split">splits</span> the block into two
separate scopes, the scope before the variable is declared and the one after,
which includes the new variable.</p>
<aside name="split">
<p>Some languages make this split explicit. In Scheme and ML, when you declare a
local variable using <code>let</code>, you also delineate the subsequent code where the new
variable is in scope. There is no implicit &quot;rest of the block&quot;.</p>
</aside>
<p>But in our implementation, environments do act like the entire block is one
scope, just a scope that changes over time. Closures do not like that. When a
function is declared, it captures a reference to the current environment. The
function <em>should</em> capture a frozen snapshot of the environment <em>as it existed at
the moment the function was declared</em>. But instead, in the Java code, it has a
reference to the actual mutable environment object. When a variable is later
declared in the scope that environment corresponds to, the closure sees the new
variable, even though the declaration does <em>not</em> precede the function.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="persistent-environments">Persistent environments<a href="#persistent-environments" class="hash-link" aria-label="Persistent environments的直接链接" title="Persistent environments的直接链接">​</a></h3>
<p>There is a style of programming that uses what are called <strong>persistent data
structures</strong>. Unlike the squishy data structures you&#x27;re familiar with in
imperative programming, a persistent data structure can never be directly
modified. Instead, any &quot;modification&quot; to an existing structure produces a <span name="copy">brand</span> new object that contains all of the original data and
the new modification. The original is left unchanged.</p>
<aside name="copy">
<p>This sounds like it might waste tons of memory and time copying the structure
for each operation. In practice, persistent data structures share most of their
data between the different &quot;copies&quot;.</p>
</aside>
<p>If we were to apply that technique to Environment, then every time you declared
a variable it would return a <em>new</em> environment that contained all of the
previously declared variables along with the one new name. Declaring a variable
would do the implicit &quot;split&quot; where you have an environment before the variable
is declared and one after:</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/split.png" alt="Separate environments before and after the variable is declared." class="img_ev3q">
<p>A closure retains a reference to the Environment instance in play when the
function was declared. Since any later declarations in that block would produce
new Environment objects, the closure wouldn&#x27;t see the new variables and our bug
would be fixed.</p>
<p>This is a legit way to solve the problem, and it&#x27;s the classic way to implement
environments in Scheme interpreters. We could do that for Lox, but it would mean
going back and changing a pile of existing code.</p>
<p>I won&#x27;t drag you through that. We&#x27;ll keep the way we represent environments the
same. Instead of making the data more statically structured, we&#x27;ll bake the
static resolution into the access <em>operation</em> itself.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="semantic-analysis">Semantic Analysis<a href="#semantic-analysis" class="hash-link" aria-label="Semantic Analysis的直接链接" title="Semantic Analysis的直接链接">​</a></h2>
<p>Our interpreter <strong>resolves</strong> a variable -- tracks down which declaration it
refers to -- each and every time the variable expression is evaluated. If that
variable is swaddled inside a loop that runs a thousand times, that variable
gets re-resolved a thousand times.</p>
<p>We know static scope means that a variable usage always resolves to the same
declaration, which can be determined just by looking at the text. Given that,
why are we doing it dynamically every time? Doing so doesn&#x27;t just open the hole
that leads to our annoying bug, it&#x27;s also needlessly slow.</p>
<p>A better solution is to resolve each variable use <em>once</em>. Write a chunk of code
that inspects the user&#x27;s program, finds every variable mentioned, and figures
out which declaration each refers to. This process is an example of a <strong>semantic
analysis</strong>. Where a parser tells only if a program is grammatically correct (a
<em>syntactic</em> analysis), semantic analysis goes farther and starts to figure out
what pieces of the program actually mean. In this case, our analysis will
resolve variable bindings. We&#x27;ll know not just that an expression <em>is</em> a
variable, but <em>which</em> variable it is.</p>
<p>There are a lot of ways we could store the binding between a variable and its
declaration. When we get to the C interpreter for Lox, we&#x27;ll have a <em>much</em> more
efficient way of storing and accessing local variables. But for jlox, I want to
minimize the collateral damage we inflict on our existing codebase. I&#x27;d hate to
throw out a bunch of mostly fine code.</p>
<p>Instead, we&#x27;ll store the resolution in a way that makes the most out of our
existing Environment class. Recall how the accesses of <code>a</code> are interpreted in
the problematic example.</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/environment-3.png" alt="An empty environment for showA()&#x27;s body linking to the previous two. &#x27;a&#x27; is resolved in the global environment." class="img_ev3q">
<p>In the first (correct) evaluation, we look at three environments in the chain
before finding the global declaration of <code>a</code>. Then, when the inner <code>a</code> is later
declared in a block scope, it shadows the global one.</p>
<img decoding="async" loading="lazy" src="image/resolving-and-binding/environment-5.png" alt="An empty environment for showA()&#x27;s body linking to the previous two. &#x27;a&#x27; is resolved in the block environment." class="img_ev3q">
<p>The next lookup walks the chain, finds <code>a</code> in the <em>second</em> environment and
stops there. Each environment corresponds to a single lexical scope where
variables are declared. If we could ensure a variable lookup always walked the
<em>same</em> number of links in the environment chain, that would ensure that it
found the same variable in the same scope every time.</p>
<p>To &quot;resolve&quot; a variable usage, we only need to calculate how many &quot;hops&quot; away
the declared variable will be in the environment chain. The interesting question
is <em>when</em> to do this calculation -- or, put differently, where in our
interpreter&#x27;s implementation do we stuff the code for it?</p>
<p>Since we&#x27;re calculating a static property based on the structure of the source
code, the obvious answer is in the parser. That is the traditional home, and is
where we&#x27;ll put it later in clox. It would work here too, but I want an excuse to
show you another technique. We&#x27;ll write our resolver as a separate pass.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-variable-resolution-pass">A variable resolution pass<a href="#a-variable-resolution-pass" class="hash-link" aria-label="A variable resolution pass的直接链接" title="A variable resolution pass的直接链接">​</a></h3>
<p>After the parser produces the syntax tree, but before the interpreter starts
executing it, we&#x27;ll do a single walk over the tree to resolve all of the
variables it contains. Additional passes between parsing and execution are
common. If Lox had static types, we could slide a type checker in there.
Optimizations are often implemented in separate passes like this too. Basically,
any work that doesn&#x27;t rely on state that&#x27;s only available at runtime can be done
in this way.</p>
<p>Our variable resolution pass works like a sort of mini-interpreter. It walks the
tree, visiting each node, but a static analysis is different from a dynamic
execution:</p>
<ul>
<li>
<p><strong>There are no side effects.</strong> When the static analysis visits a print
statement, it doesn&#x27;t actually print anything. Calls to native functions or
other operations that reach out to the outside world are stubbed out and
have no effect.</p>
</li>
<li>
<p><strong>There is no control flow.</strong> Loops are visited only <span name="fix">once</span>. Both branches are visited in <code>if</code> statements. Logic
operators are not short-circuited.</p>
</li>
</ul>
<aside name="fix">
<p>Variable resolution touches each node once, so its performance is <em>O(n)</em> where
<em>n</em> is the number of syntax tree nodes. More sophisticated analyses may have
greater complexity, but most are carefully designed to be linear or not far from
it. It&#x27;s an embarrassing faux pas if your compiler gets exponentially slower as
the user&#x27;s program grows.</p>
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-resolver-class">A Resolver Class<a href="#a-resolver-class" class="hash-link" aria-label="A Resolver Class的直接链接" title="A Resolver Class的直接链接">​</a></h2>
<p>Like everything in Java, our variable resolution pass is embodied in a class.</p>
<p>^code resolver</p>
<p>Since the resolver needs to visit every node in the syntax tree, it implements
the visitor abstraction we already have in place. Only a few kinds of nodes are
interesting when it comes to resolving variables:</p>
<ul>
<li>
<p>A block statement introduces a new scope for the statements it contains.</p>
</li>
<li>
<p>A function declaration introduces a new scope for its body and binds its
parameters in that scope.</p>
</li>
<li>
<p>A variable declaration adds a new variable to the current scope.</p>
</li>
<li>
<p>Variable and assignment expressions need to have their variables resolved.</p>
</li>
</ul>
<p>The rest of the nodes don&#x27;t do anything special, but we still need to implement
visit methods for them that traverse into their subtrees. Even though a <code>+</code>
expression doesn&#x27;t <em>itself</em> have any variables to resolve, either of its
operands might.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resolving-blocks">Resolving blocks<a href="#resolving-blocks" class="hash-link" aria-label="Resolving blocks的直接链接" title="Resolving blocks的直接链接">​</a></h3>
<p>We start with blocks since they create the local scopes where all the magic
happens.</p>
<p>^code visit-block-stmt</p>
<p>This begins a new scope, traverses into the statements inside the block, and
then discards the scope. The fun stuff lives in those helper methods. We start
with the simple one.</p>
<p>^code resolve-statements</p>
<p>This walks a list of statements and resolves each one. It in turn calls:</p>
<p>^code resolve-stmt</p>
<p>While we&#x27;re at it, let&#x27;s add another overload that we&#x27;ll need later for
resolving an expression.</p>
<p>^code resolve-expr</p>
<p>These methods are similar to the <code>evaluate()</code> and <code>execute()</code> methods in
Interpreter -- they turn around and apply the Visitor pattern to the given
syntax tree node.</p>
<p>The real interesting behavior is around scopes. A new block scope is created
like so:</p>
<p>^code begin-scope</p>
<p>Lexical scopes nest in both the interpreter and the resolver. They behave like a
stack. The interpreter implements that stack using a linked list -- the chain of
Environment objects. In the resolver, we use an actual Java Stack.</p>
<p>^code scopes-field (1 before, 2 after)</p>
<p>This field keeps track of the stack of scopes currently, uh, in scope. Each
element in the stack is a Map representing a single block scope. Keys, as in
Environment, are variable names. The values are Booleans, for a reason I&#x27;ll
explain soon.</p>
<p>The scope stack is only used for local block scopes. Variables declared at the
top level in the global scope are not tracked by the resolver since they are
more dynamic in Lox. When resolving a variable, if we can&#x27;t find it in the stack
of local scopes, we assume it must be global.</p>
<p>Since scopes are stored in an explicit stack, exiting one is straightforward.</p>
<p>^code end-scope</p>
<p>Now we can push and pop a stack of empty scopes. Let&#x27;s put some things in them.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resolving-variable-declarations">Resolving variable declarations<a href="#resolving-variable-declarations" class="hash-link" aria-label="Resolving variable declarations的直接链接" title="Resolving variable declarations的直接链接">​</a></h3>
<p>Resolving a variable declaration adds a new entry to the current innermost
scope&#x27;s map. That seems simple, but there&#x27;s a little dance we need to do.</p>
<p>^code visit-var-stmt</p>
<p>We split binding into two steps, declaring then defining, in order to handle
funny edge cases like this:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;outer&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>What happens when the initializer for a local variable refers to a variable with
the same name as the variable being declared? We have a few options:</p>
<ol>
<li>
<p><strong>Run the initializer, then put the new variable in scope.</strong> Here, the new
local <code>a</code> would be initialized with &quot;outer&quot;, the value of the <em>global</em> one.
In other words, the previous declaration would desugar to:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var temp = a; // Run the initializer.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a;        // Declare the variable.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">a = temp;     // Initialize it.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p><strong>Put the new variable in scope, then run the initializer.</strong> This means you
could observe a variable before it&#x27;s initialized, so we would need to figure
out what value it would have then. Probably <code>nil</code>. That means the new local
<code>a</code> would be re-initialized to its own implicitly initialized value, <code>nil</code>.
Now the desugaring would look like:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a; // Define the variable.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">a = a; // Run the initializer.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p><strong>Make it an error to reference a variable in its initializer.</strong> Have the
interpreter fail either at compile time or runtime if an initializer
mentions the variable being initialized.</p>
</li>
</ol>
<p>Do either of those first two options look like something a user actually
<em>wants</em>? Shadowing is rare and often an error, so initializing a shadowing
variable based on the value of the shadowed one seems unlikely to be deliberate.</p>
<p>The second option is even less useful. The new variable will <em>always</em> have the
value <code>nil</code>. There is never any point in mentioning it by name. You could use an
explicit <code>nil</code> instead.</p>
<p>Since the first two options are likely to mask user errors, we&#x27;ll take the
third. Further, we&#x27;ll make it a compile error instead of a runtime one. That
way, the user is alerted to the problem before any code is run.</p>
<p>In order to do that, as we visit expressions, we need to know if we&#x27;re inside
the initializer for some variable. We do that by splitting binding into two
steps. The first is <strong>declaring</strong> it.</p>
<p>^code declare</p>
<p>Declaration adds the variable to the innermost scope so that it shadows any
outer one and so that we know the variable exists. We mark it as &quot;not ready yet&quot;
by binding its name to <code>false</code> in the scope map. The value associated with a key
in the scope map represents whether or not we have finished resolving that
variable&#x27;s initializer.</p>
<p>After declaring the variable, we resolve its initializer expression in that same
scope where the new variable now exists but is unavailable. Once the initializer
expression is done, the variable is ready for prime time. We do that by
<strong>defining</strong> it.</p>
<p>^code define</p>
<p>We set the variable&#x27;s value in the scope map to <code>true</code> to mark it as fully
initialized and available for use. It&#x27;s alive!</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resolving-variable-expressions">Resolving variable expressions<a href="#resolving-variable-expressions" class="hash-link" aria-label="Resolving variable expressions的直接链接" title="Resolving variable expressions的直接链接">​</a></h3>
<p>Variable declarations -- and function declarations, which we&#x27;ll get to -- write
to the scope maps. Those maps are read when we resolve variable expressions.</p>
<p>^code visit-variable-expr</p>
<p>First, we check to see if the variable is being accessed inside its own
initializer. This is where the values in the scope map come into play. If the
variable exists in the current scope but its value is <code>false</code>, that means we
have declared it but not yet defined it. We report that error.</p>
<p>After that check, we actually resolve the variable itself using this helper:</p>
<p>^code resolve-local</p>
<p>This looks, for good reason, a lot like the code in Environment for evaluating a
variable. We start at the innermost scope and work outwards, looking in each map
for a matching name. If we find the variable, we resolve it, passing in the
number of scopes between the current innermost scope and the scope where the
variable was found. So, if the variable was found in the current scope, we
pass in 0. If it&#x27;s in the immediately enclosing scope, 1. You get the idea.</p>
<p>If we walk through all of the block scopes and never find the variable, we leave
it unresolved and assume it&#x27;s global. We&#x27;ll get to the implementation of that
<code>resolve()</code> method a little later. For now, let&#x27;s keep on cranking through the
other syntax nodes.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resolving-assignment-expressions">Resolving assignment expressions<a href="#resolving-assignment-expressions" class="hash-link" aria-label="Resolving assignment expressions的直接链接" title="Resolving assignment expressions的直接链接">​</a></h3>
<p>The other expression that references a variable is assignment. Resolving one
looks like this:</p>
<p>^code visit-assign-expr</p>
<p>First, we resolve the expression for the assigned value in case it also contains
references to other variables. Then we use our existing <code>resolveLocal()</code> method
to resolve the variable that&#x27;s being assigned to.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resolving-function-declarations">Resolving function declarations<a href="#resolving-function-declarations" class="hash-link" aria-label="Resolving function declarations的直接链接" title="Resolving function declarations的直接链接">​</a></h3>
<p>Finally, functions. Functions both bind names and introduce a scope. The name of
the function itself is bound in the surrounding scope where the function is
declared. When we step into the function&#x27;s body, we also bind its parameters
into that inner function scope.</p>
<p>^code visit-function-stmt</p>
<p>Similar to <code>visitVariableStmt()</code>, we declare and define the name of the function
in the current scope. Unlike variables, though, we define the name eagerly,
before resolving the function&#x27;s body. This lets a function recursively refer to
itself inside its own body.</p>
<p>Then we resolve the function&#x27;s body using this:</p>
<p>^code resolve-function</p>
<p>It&#x27;s a separate method since we will also use it for resolving Lox methods when
we add classes later. It creates a new scope for the body and then binds
variables for each of the function&#x27;s parameters.</p>
<p>Once that&#x27;s ready, it resolves the function body in that scope. This is
different from how the interpreter handles function declarations. At <em>runtime</em>,
declaring a function doesn&#x27;t do anything with the function&#x27;s body. The body
doesn&#x27;t get touched until later when the function is called. In a <em>static</em>
analysis, we immediately traverse into the body right then and there.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resolving-the-other-syntax-tree-nodes">Resolving the other syntax tree nodes<a href="#resolving-the-other-syntax-tree-nodes" class="hash-link" aria-label="Resolving the other syntax tree nodes的直接链接" title="Resolving the other syntax tree nodes的直接链接">​</a></h3>
<p>That covers the interesting corners of the grammars. We handle every place where
a variable is declared, read, or written, and every place where a scope is
created or destroyed. Even though they aren&#x27;t affected by variable resolution,
we also need visit methods for all of the other syntax tree nodes in order to
recurse into their subtrees. <span name="boring">Sorry</span> this bit is
boring, but bear with me. We&#x27;ll go kind of &quot;top down&quot; and start with statements.</p>
<aside name="boring">
<p>I did say the book would have every single line of code for these interpreters.
I didn&#x27;t say they&#x27;d all be exciting.</p>
</aside>
<p>An expression statement contains a single expression to traverse.</p>
<p>^code visit-expression-stmt</p>
<p>An if statement has an expression for its condition and one or two statements
for the branches.</p>
<p>^code visit-if-stmt</p>
<p>Here, we see how resolution is different from interpretation. When we resolve an
<code>if</code> statement, there is no control flow. We resolve the condition and <em>both</em>
branches. Where a dynamic execution steps only into the branch that <em>is</em> run, a
static analysis is conservative -- it analyzes any branch that <em>could</em> be run.
Since either one could be reached at runtime, we resolve both.</p>
<p>Like expression statements, a <code>print</code> statement contains a single subexpression.</p>
<p>^code visit-print-stmt</p>
<p>Same deal for return.</p>
<p>^code visit-return-stmt</p>
<p>As in <code>if</code> statements, with a <code>while</code> statement, we resolve its condition and
resolve the body exactly once.</p>
<p>^code visit-while-stmt</p>
<p>That covers all the statements. On to expressions...</p>
<p>Our old friend the binary expression. We traverse into and resolve both
operands.</p>
<p>^code visit-binary-expr</p>
<p>Calls are similar -- we walk the argument list and resolve them all. The thing
being called is also an expression (usually a variable expression), so that gets
resolved too.</p>
<p>^code visit-call-expr</p>
<p>Parentheses are easy.</p>
<p>^code visit-grouping-expr</p>
<p>Literals are easiest of all.</p>
<p>^code visit-literal-expr</p>
<p>A literal expression doesn&#x27;t mention any variables and doesn&#x27;t contain any
subexpressions so there is no work to do.</p>
<p>Since a static analysis does no control flow or short-circuiting, logical
expressions are exactly the same as other binary operators.</p>
<p>^code visit-logical-expr</p>
<p>And, finally, the last node. We resolve its one operand.</p>
<p>^code visit-unary-expr</p>
<p>With all of these visit methods, the Java compiler should be satisfied that
Resolver fully implements Stmt.Visitor and Expr.Visitor. Now is a good time to
take a break, have a snack, maybe a little nap.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="interpreting-resolved-variables">Interpreting Resolved Variables<a href="#interpreting-resolved-variables" class="hash-link" aria-label="Interpreting Resolved Variables的直接链接" title="Interpreting Resolved Variables的直接链接">​</a></h2>
<p>Let&#x27;s see what our resolver is good for. Each time it visits a variable, it
tells the interpreter how many scopes there are between the current scope and
the scope where the variable is defined. At runtime, this corresponds exactly to
the number of <em>environments</em> between the current one and the enclosing one where
the interpreter can find the variable&#x27;s value. The resolver hands that number to
the interpreter by calling this:</p>
<p>^code resolve</p>
<p>We want to store the resolution information somewhere so we can use it when the
variable or assignment expression is later executed, but where? One obvious
place is right in the syntax tree node itself. That&#x27;s a fine approach, and
that&#x27;s where many compilers store the results of analyses like this.</p>
<p>We could do that, but it would require mucking around with our syntax tree
generator. Instead, we&#x27;ll take another common approach and store it off to the
<span name="side">side</span> in a map that associates each syntax tree node
with its resolved data.</p>
<aside name="side">
<p>I <em>think</em> I&#x27;ve heard this map called a &quot;side table&quot; since it&#x27;s a tabular data
structure that stores data separately from the objects it relates to. But
whenever I try to Google for that term, I get pages about furniture.</p>
</aside>
<p>Interactive tools like IDEs often incrementally reparse and re-resolve parts of
the user&#x27;s program. It may be hard to find all of the bits of state that need
recalculating when they&#x27;re hiding in the foliage of the syntax tree. A benefit
of storing this data outside of the nodes is that it makes it easy to <em>discard</em>
it -- simply clear the map.</p>
<p>^code locals-field (1 before, 2 after)</p>
<p>You might think we&#x27;d need some sort of nested tree structure to avoid getting
confused when there are multiple expressions that reference the same variable,
but each expression node is its own Java object with its own unique identity. A
single monolithic map doesn&#x27;t have any trouble keeping them separated.</p>
<p>As usual, using a collection requires us to import a couple of names.</p>
<p>^code import-hash-map (1 before, 1 after)</p>
<p>And:</p>
<p>^code import-map (1 before, 2 after)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="accessing-a-resolved-variable">Accessing a resolved variable<a href="#accessing-a-resolved-variable" class="hash-link" aria-label="Accessing a resolved variable的直接链接" title="Accessing a resolved variable的直接链接">​</a></h3>
<p>Our interpreter now has access to each variable&#x27;s resolved location. Finally, we
get to make use of that. We replace the visit method for variable expressions
with this:</p>
<p>^code call-look-up-variable (1 before, 1 after)</p>
<p>That delegates to:</p>
<p>^code look-up-variable</p>
<p>There are a couple of things going on here. First, we look up the resolved
distance in the map. Remember that we resolved only <em>local</em> variables. Globals
are treated specially and don&#x27;t end up in the map (hence the name <code>locals</code>). So,
if we don&#x27;t find a distance in the map, it must be global. In that case, we
look it up, dynamically, directly in the global environment. That throws a
runtime error if the variable isn&#x27;t defined.</p>
<p>If we <em>do</em> get a distance, we have a local variable, and we get to take
advantage of the results of our static analysis. Instead of calling <code>get()</code>, we
call this new method on Environment:</p>
<p>^code get-at</p>
<p>The old <code>get()</code> method dynamically walks the chain of enclosing environments,
scouring each one to see if the variable might be hiding in there somewhere. But
now we know exactly which environment in the chain will have the variable. We
reach it using this helper method:</p>
<p>^code ancestor</p>
<p>This walks a fixed number of hops up the parent chain and returns the
environment there. Once we have that, <code>getAt()</code> simply returns the value of the
variable in that environment&#x27;s map. It doesn&#x27;t even have to check to see if the
variable is there -- we know it will be because the resolver already found it
before.</p>
<aside name="coupled">
<p>The way the interpreter assumes the variable is in that map feels like flying
blind. The interpreter code trusts that the resolver did its job and resolved
the variable correctly. This implies a deep coupling between these two classes.
In the resolver, each line of code that touches a scope must have its exact
match in the interpreter for modifying an environment.</p>
<p>I felt that coupling firsthand because as I wrote the code for the book, I
ran into a couple of subtle bugs where the resolver and interpreter code were
slightly out of sync. Tracking those down was difficult. One tool to make that
easier is to have the interpreter explicitly assert -- using Java&#x27;s assert
statements or some other validation tool -- the contract it expects the resolver
to have already upheld.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="assigning-to-a-resolved-variable">Assigning to a resolved variable<a href="#assigning-to-a-resolved-variable" class="hash-link" aria-label="Assigning to a resolved variable的直接链接" title="Assigning to a resolved variable的直接链接">​</a></h3>
<p>We can also use a variable by assigning to it. The changes to visiting an
assignment expression are similar.</p>
<p>^code resolved-assign (2 before, 1 after)</p>
<p>Again, we look up the variable&#x27;s scope distance. If not found, we assume it&#x27;s
global and handle it the same way as before. Otherwise, we call this new method:</p>
<p>^code assign-at</p>
<p>As <code>getAt()</code> is to <code>get()</code>, <code>assignAt()</code> is to <code>assign()</code>. It walks a fixed
number of environments, and then stuffs the new value in that map.</p>
<p>Those are the only changes to Interpreter. This is why I chose a representation
for our resolved data that was minimally invasive. All of the rest of the nodes
continue working as they did before. Even the code for modifying environments is
unchanged.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="running-the-resolver">Running the resolver<a href="#running-the-resolver" class="hash-link" aria-label="Running the resolver的直接链接" title="Running the resolver的直接链接">​</a></h3>
<p>We do need to actually <em>run</em> the resolver, though. We insert the new pass after
the parser does its magic.</p>
<p>^code create-resolver (3 before, 1 after)</p>
<p>We don&#x27;t run the resolver if there are any parse errors. If the code has a
syntax error, it&#x27;s never going to run, so there&#x27;s little value in resolving it.
If the syntax is clean, we tell the resolver to do its thing. The resolver has a
reference to the interpreter and pokes the resolution data directly into it as
it walks over variables. When the interpreter runs next, it has everything it
needs.</p>
<p>At least, that&#x27;s true if the resolver <em>succeeds</em>. But what about errors during
resolution?</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="resolution-errors">Resolution Errors<a href="#resolution-errors" class="hash-link" aria-label="Resolution Errors的直接链接" title="Resolution Errors的直接链接">​</a></h2>
<p>Since we are doing a semantic analysis pass, we have an opportunity to make
Lox&#x27;s semantics more precise, and to help users catch bugs early before running
their code. Take a look at this bad boy:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun bad() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;first&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;second&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We do allow declaring multiple variables with the same name in the <em>global</em>
scope, but doing so in a local scope is probably a mistake. If they knew the
variable already existed, they would have assigned to it instead of using <code>var</code>.
And if they <em>didn&#x27;t</em> know it existed, they probably didn&#x27;t intend to overwrite
the previous one.</p>
<p>We can detect this mistake statically while resolving.</p>
<p>^code duplicate-variable (1 before, 1 after)</p>
<p>When we declare a variable in a local scope, we already know the names of every
variable previously declared in that same scope. If we see a collision, we
report an error.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="invalid-return-errors">Invalid return errors<a href="#invalid-return-errors" class="hash-link" aria-label="Invalid return errors的直接链接" title="Invalid return errors的直接链接">​</a></h3>
<p>Here&#x27;s another nasty little script:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">return &quot;at top level&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>This executes a <code>return</code> statement, but it&#x27;s not even inside a function at all.
It&#x27;s top-level code. I don&#x27;t know what the user <em>thinks</em> is going to happen, but
I don&#x27;t think we want Lox to allow this.</p>
<p>We can extend the resolver to detect this statically. Much like we track scopes
as we walk the tree, we can track whether or not the code we are currently
visiting is inside a function declaration.</p>
<p>^code function-type-field (1 before, 2 after)</p>
<p>Instead of a bare Boolean, we use this funny enum:</p>
<p>^code function-type</p>
<p>It seems kind of dumb now, but we&#x27;ll add a couple more cases to it later and
then it will make more sense. When we resolve a function declaration, we pass
that in.</p>
<p>^code pass-function-type (2 before, 1 after)</p>
<p>Over in <code>resolveFunction()</code>, we take that parameter and store it in the field
before resolving the body.</p>
<p>^code set-current-function (1 after)</p>
<p>We stash the previous value of the field in a local variable first. Remember,
Lox has local functions, so you can nest function declarations arbitrarily
deeply. We need to track not just that we&#x27;re in a function, but <em>how many</em> we&#x27;re
in.</p>
<p>We could use an explicit stack of FunctionType values for that, but instead
we&#x27;ll piggyback on the JVM. We store the previous value in a local on the Java
stack. When we&#x27;re done resolving the function body, we restore the field to that
value.</p>
<p>^code restore-current-function (1 before, 1 after)</p>
<p>Now that we can always tell whether or not we&#x27;re inside a function declaration,
we check that when resolving a <code>return</code> statement.</p>
<p>^code return-from-top (1 before, 1 after)</p>
<p>Neat, right?</p>
<p>There&#x27;s one more piece. Back in the main Lox class that stitches everything
together, we are careful to not run the interpreter if any parse errors are
encountered. That check runs <em>before</em> the resolver so that we don&#x27;t try to
resolve syntactically invalid code.</p>
<p>But we also need to skip the interpreter if there are resolution errors, so we
add <em>another</em> check.</p>
<p>^code resolution-error (1 before, 2 after)</p>
<p>You could imagine doing lots of other analysis in here. For example, if we added
<code>break</code> statements to Lox, we would probably want to ensure they are only used
inside loops.</p>
<p>We could go farther and report warnings for code that isn&#x27;t necessarily <em>wrong</em>
but probably isn&#x27;t useful. For example, many IDEs will warn if you have
unreachable code after a <code>return</code> statement, or a local variable whose value is
never read. All of that would be pretty easy to add to our static visiting pass,
or as <span name="separate">separate</span> passes.</p>
<aside name="separate">
<p>The choice of how many different analyses to lump into a single pass is
difficult. Many small isolated passes, each with their own responsibility, are
simpler to implement and maintain. However, there is a real runtime cost to
traversing the syntax tree itself, so bundling multiple analyses into a single
pass is usually faster.</p>
</aside>
<p>But, for now, we&#x27;ll stick with that limited amount of analysis. The important
part is that we fixed that one weird annoying edge case bug, though it might be
surprising that it took this much work to do it.</p>
<div class="challenges">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h2>
<ol>
<li>
<p>Why is it safe to eagerly define the variable bound to a function&#x27;s name
when other variables must wait until after they are initialized before they
can be used?</p>
</li>
<li>
<p>How do other languages you know handle local variables that refer to the
same name in their initializer, like:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;outer&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Is it a runtime error? Compile error? Allowed? Do they treat global
variables differently? Do you agree with their choices? Justify your answer.</p>
</li>
<li>
<p>Extend the resolver to report an error if a local variable is never used.</p>
</li>
<li>
<p>Our resolver calculates <em>which</em> environment the variable is found in, but
it&#x27;s still looked up by name in that map. A more efficient environment
representation would store local variables in an array and look them up by
index.</p>
<p>Extend the resolver to associate a unique index for each local variable
declared in a scope. When resolving a variable access, look up both the
scope the variable is in and its index and store that. In the interpreter,
use that to quickly access a variable by its index instead of using a map.</p>
</li>
</ol>
</div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Craftinginterpreters/not-translated-yet/representing-code"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">representing-code</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">scanning-on-demand</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#static-scope" class="table-of-contents__link toc-highlight">Static Scope</a><ul><li><a href="#scopes-and-mutable-environments" class="table-of-contents__link toc-highlight">Scopes and mutable environments</a></li><li><a href="#persistent-environments" class="table-of-contents__link toc-highlight">Persistent environments</a></li></ul></li><li><a href="#semantic-analysis" class="table-of-contents__link toc-highlight">Semantic Analysis</a><ul><li><a href="#a-variable-resolution-pass" class="table-of-contents__link toc-highlight">A variable resolution pass</a></li></ul></li><li><a href="#a-resolver-class" class="table-of-contents__link toc-highlight">A Resolver Class</a><ul><li><a href="#resolving-blocks" class="table-of-contents__link toc-highlight">Resolving blocks</a></li><li><a href="#resolving-variable-declarations" class="table-of-contents__link toc-highlight">Resolving variable declarations</a></li><li><a href="#resolving-variable-expressions" class="table-of-contents__link toc-highlight">Resolving variable expressions</a></li><li><a href="#resolving-assignment-expressions" class="table-of-contents__link toc-highlight">Resolving assignment expressions</a></li><li><a href="#resolving-function-declarations" class="table-of-contents__link toc-highlight">Resolving function declarations</a></li><li><a href="#resolving-the-other-syntax-tree-nodes" class="table-of-contents__link toc-highlight">Resolving the other syntax tree nodes</a></li></ul></li><li><a href="#interpreting-resolved-variables" class="table-of-contents__link toc-highlight">Interpreting Resolved Variables</a><ul><li><a href="#accessing-a-resolved-variable" class="table-of-contents__link toc-highlight">Accessing a resolved variable</a></li><li><a href="#assigning-to-a-resolved-variable" class="table-of-contents__link toc-highlight">Assigning to a resolved variable</a></li><li><a href="#running-the-resolver" class="table-of-contents__link toc-highlight">Running the resolver</a></li></ul></li><li><a href="#resolution-errors" class="table-of-contents__link toc-highlight">Resolution Errors</a><ul><li><a href="#invalid-return-errors" class="table-of-contents__link toc-highlight">Invalid return errors</a></li></ul></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>