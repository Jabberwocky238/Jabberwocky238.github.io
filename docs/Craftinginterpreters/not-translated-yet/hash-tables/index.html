<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Craftinginterpreters/not-translated-yet/hash-tables" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">hash-tables | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/hash-tables"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="hash-tables | My Site"><meta data-rh="true" name="description" content="Hash, x. There is no definition for this word -- nobody knows what hash is."><meta data-rh="true" property="og:description" content="Hash, x. There is no definition for this word -- nobody knows what hash is."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/hash-tables"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/hash-tables" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/hash-tables" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0d35426a.css">
<script src="/assets/js/runtime~main.0868a236.js" defer="defer"></script>
<script src="/assets/js/main.f1c02528.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/english">English</a><button aria-label="展开侧边栏分类 &#x27;English&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/crafting-interpreter">Crafting-interpreter</a><button aria-label="折叠侧边栏分类 &#x27;Crafting-interpreter&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/welcome">Welcome</a><button aria-label="展开侧边栏分类 &#x27;Welcome&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/not-translated-yet">not-translated-yet</a><button aria-label="折叠侧边栏分类 &#x27;not-translated-yet&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-bytecode-virtual-machine">a-bytecode-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-tree-walk-interpreter">a-tree-walk-interpreter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine">a-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/acknowledgements">acknowledgements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-i">appendix-i</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii">appendix-ii</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/backmatter">backmatter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/calls-and-functions">calls-and-functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode">chunks-of-bytecode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes-and-instances">classes-and-instances</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes">classes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/closures">closures</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/compiling-expressions">compiling-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/contents">contents</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/control-flow">control-flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/dedication">dedication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions">evaluating-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/functions">functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection">garbage-collection</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/global-variables">global-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/hash-tables">hash-tables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/inheritance">inheritance</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth">jumping-back-and-forth</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/local-variables">local-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/methods-and-initializers">methods-and-initializers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/optimization">optimization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/parsing-expressions">parsing-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/representing-code">representing-code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding">resolving-and-binding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand">scanning-on-demand</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning">scanning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/statements-and-state">statements-and-state</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/strings">strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/superclasses">superclasses</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/the-lox-language">the-lox-language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/types-of-values">types-of-values</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/crafting-interpreter"><span itemprop="name">Crafting-interpreter</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/not-translated-yet"><span itemprop="name">not-translated-yet</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">hash-tables</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>hash-tables</h1></header><blockquote>
<p>Hash, x. There is no definition for this word -- nobody knows what hash is.</p>
<p><cite>Ambrose Bierce, <em>The Unabridged Devil&#x27;s Dictionary</em></cite></p>
</blockquote>
<p>Before we can add variables to our burgeoning virtual machine, we need some way
to look up a value given a variable&#x27;s name. Later, when we add classes, we&#x27;ll
also need a way to store fields on instances. The perfect data structure for
these problems and others is a hash table.</p>
<p>You probably already know what a hash table is, even if you don&#x27;t know it by
that name. If you&#x27;re a Java programmer, you call them &quot;HashMaps&quot;. C# and Python
users call them &quot;dictionaries&quot;. In C++, it&#x27;s an &quot;unordered map&quot;. &quot;Objects&quot; in
JavaScript and &quot;tables&quot; in Lua are hash tables under the hood, which is what
gives them their flexibility.</p>
<p>A hash table, whatever your language calls it, associates a set of <strong>keys</strong> with
a set of <strong>values</strong>. Each key/value pair is an <strong>entry</strong> in the table. Given a
key, you can look up its corresponding value. You can add new key/value pairs
and remove entries by key. If you add a new value for an existing key, it
replaces the previous entry.</p>
<p>Hash tables appear in so many languages because they are incredibly powerful.
Much of this power comes from one metric: given a key, a hash table returns the
corresponding value in <span name="constant">constant time</span>, <em>regardless
of how many keys are in the hash table</em>.</p>
<aside name="constant">
<p>More specifically, the <em>average-case</em> lookup time is constant. Worst-case
performance can be, well, worse. In practice, it&#x27;s easy to avoid degenerate
behavior and stay on the happy path.</p>
</aside>
<p>That&#x27;s pretty remarkable when you think about it. Imagine you&#x27;ve got a big stack
of business cards and I ask you to find a certain person. The bigger the pile
is, the longer it will take. Even if the pile is nicely sorted and you&#x27;ve got
the manual dexterity to do a binary search by hand, you&#x27;re still talking
<em>O(log n)</em>. But with a <span name="rolodex">hash table</span>, it takes the
same time to find that business card when the stack has ten cards as when it has
a million.</p>
<aside name="rolodex">
<p>Stuff all those cards in a Rolodex -- does anyone even remember those things
anymore? -- with dividers for each letter, and you improve your speed
dramatically. As we&#x27;ll see, that&#x27;s not too far from the trick a hash table uses.</p>
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="an-array-of-buckets">An Array of Buckets<a href="#an-array-of-buckets" class="hash-link" aria-label="An Array of Buckets的直接链接" title="An Array of Buckets的直接链接">​</a></h2>
<p>A complete, fast hash table has a couple of moving parts. I&#x27;ll introduce them
one at a time by working through a couple of toy problems and their solutions.
Eventually, we&#x27;ll build up to a data structure that can associate any set of
names with their values.</p>
<p>For now, imagine if Lox was a <em>lot</em> more restricted in variable names. What if a
variable&#x27;s name could only be a <span name="basic">single</span> lowercase
letter. How could we very efficiently represent a set of variable names and
their values?</p>
<aside name="basic">
<p>This limitation isn&#x27;t <em>too</em> far-fetched. The initial versions of BASIC out of
Dartmouth allowed variable names to be only a single letter followed by one
optional digit.</p>
</aside>
<p>With only 26 possible variables (27 if you consider underscore a &quot;letter&quot;, I
guess), the answer is easy. Declare a fixed-size array with 26 elements. We&#x27;ll
follow tradition and call each element a <strong>bucket</strong>. Each represents a variable
with <code>a</code> starting at index zero. If there&#x27;s a value in the array at some
letter&#x27;s index, then that key is present with that value. Otherwise, the bucket
is empty and that key/value pair isn&#x27;t in the data structure.</p>
<aside name="bucket">
<p><img decoding="async" loading="lazy" src="image/hash-tables/bucket-array.png" alt="A row of buckets, each
labeled with a letter of the alphabet." class="img_ev3q"></p>
</aside>
<p>Memory usage is great -- just a single, reasonably sized <span name="bucket">array</span>. There&#x27;s some waste from the empty buckets, but it&#x27;s
not huge. There&#x27;s no overhead for node pointers, padding, or other stuff you&#x27;d
get with something like a linked list or tree.</p>
<p>Performance is even better. Given a variable name -- its character -- you can
subtract the ASCII value of <code>a</code> and use the result to index directly into the
array. Then you can either look up the existing value or store a new value
directly into that slot. It doesn&#x27;t get much faster than that.</p>
<p>This is sort of our Platonic ideal data structure. Lightning fast, dead simple,
and compact in memory. As we add support for more complex keys, we&#x27;ll have to
make some concessions, but this is what we&#x27;re aiming for. Even once you add in
hash functions, dynamic resizing, and collision resolution, this is still the
core of every hash table out there -- a contiguous array of buckets that you
index directly into.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="load-factor-and-wrapped-keys">Load factor and wrapped keys<a href="#load-factor-and-wrapped-keys" class="hash-link" aria-label="Load factor and wrapped keys的直接链接" title="Load factor and wrapped keys的直接链接">​</a></h3>
<p>Confining Lox to single-letter variables would make our job as implementers
easier, but it&#x27;s probably no fun programming in a language that gives you only
26 storage locations. What if we loosened it a little and allowed variables up
to <span name="six">eight</span> characters long?</p>
<aside name="six">
<p>Again, this restriction isn&#x27;t so crazy. Early linkers for C treated only the
first six characters of external identifiers as meaningful. Everything after
that was ignored. If you&#x27;ve ever wondered why the C standard library is so
enamored of abbreviation -- looking at you, <code>strncmp()</code> -- it turns out it
wasn&#x27;t entirely because of the small screens (or teletypes!) of the day.</p>
</aside>
<p>That&#x27;s small enough that we can pack all eight characters into a 64-bit integer
and easily turn the string into a number. We can then use it as an array index.
Or, at least, we could if we could somehow allocate a 295,148 <em>petabyte</em> array.
Memory&#x27;s gotten cheaper over time, but not quite <em>that</em> cheap. Even if we could
make an array that big, it would be heinously wasteful. Almost every bucket
would be empty unless users started writing way bigger Lox programs than we&#x27;ve
anticipated.</p>
<p>Even though our variable keys cover the full 64-bit numeric range, we clearly
don&#x27;t need an array that large. Instead, we allocate an array with more than
enough capacity for the entries we need, but not unreasonably large. We map the
full 64-bit keys down to that smaller range by taking the value modulo the size
of the array. Doing that essentially folds the larger numeric range onto itself
until it fits the smaller range of array elements.</p>
<p>For example, say we want to store &quot;bagel&quot;. We allocate an array with eight
elements, plenty enough to store it and more later. We treat the key string as a
64-bit integer. On a little-endian machine like Intel, packing those characters
into a 64-bit word puts the first letter, &quot;b&quot; (ASCII value 98), in the
least-significant byte. We take that integer modulo the array size (<span name="power-of-two">8</span>) to fit it in the bounds and get a bucket index, 2.
Then we store the value there as usual.</p>
<aside name="power-of-two">
<p>I&#x27;m using powers of two for the array sizes here, but they don&#x27;t need to be.
Some styles of hash tables work best with powers of two, including the one we&#x27;ll
build in this book. Others prefer prime number array sizes or have other rules.</p>
</aside>
<p>Using the array size as a modulus lets us map the key&#x27;s numeric range down to
fit an array of any size. We can thus control the number of buckets
independently of the key range. That solves our waste problem, but introduces a
new one. Any two variables whose key number has the same remainder when divided
by the array size will end up in the same bucket. Keys can <strong>collide</strong>. For
example, if we try to add &quot;jam&quot;, it also ends up in bucket 2.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/collision.png" alt="&#x27;Bagel&#x27; and &#x27;jam&#x27; both end up in bucket index 2." class="img_ev3q">
<p>We have some control over this by tuning the array size. The bigger the array,
the fewer the indexes that get mapped to the same bucket and the fewer the
collisions that are likely to occur. Hash table implementers track this
collision likelihood by measuring the table&#x27;s <strong>load factor</strong>. It&#x27;s defined as
the number of entries divided by the number of buckets. So a hash table with
five entries and an array of 16 elements has a load factor of 0.3125. The higher
the load factor, the greater the chance of collisions.</p>
<p>One way we mitigate collisions is by resizing the array. Just like the dynamic
arrays we implemented earlier, we reallocate and grow the hash table&#x27;s array as
it fills up. Unlike a regular dynamic array, though, we won&#x27;t wait until the
array is <em>full</em>. Instead, we pick a desired load factor and grow the array when
it goes over that.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="collision-resolution">Collision Resolution<a href="#collision-resolution" class="hash-link" aria-label="Collision Resolution的直接链接" title="Collision Resolution的直接链接">​</a></h2>
<p>Even with a very low load factor, collisions can still occur. The <a href="https://en.wikipedia.org/wiki/Birthday_problem" target="_blank" rel="noopener noreferrer"><em>birthday
paradox</em></a> tells us that as the number of entries in the hash table
increases, the chance of collision increases very quickly. We can pick a large
array size to reduce that, but it&#x27;s a losing game. Say we wanted to store a
hundred items in a hash table. To keep the chance of collision below a
still-pretty-high 10%, we need an array with at least 47,015 elements. To get
the chance below 1% requires an array with 492,555 elements, over 4,000 empty
buckets for each one in use.</p>
<p>A low load factor can make collisions <span name="pigeon">rarer</span>, but the
<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank" rel="noopener noreferrer"><em>pigeonhole principle</em></a> tells us we can never eliminate them entirely.
If you&#x27;ve got five pet pigeons and four holes to put them in, at least one hole
is going to end up with more than one pigeon. With 18,446,744,073,709,551,616
different variable names, any reasonably sized array can potentially end up with
multiple keys in the same bucket.</p>
<p>Thus we still have to handle collisions gracefully when they occur. Users don&#x27;t
like it when their programming language can look up variables correctly only
<em>most</em> of the time.</p>
<aside name="pigeon">
<p>Put these two funny-named mathematical rules together and you get this
observation: Take a birdhouse containing 365 pigeonholes, and use each pigeon&#x27;s
birthday to assign it to a pigeonhole. You&#x27;ll need only about 26 randomly chosen
pigeons before you get a greater than 50% chance of two pigeons in the same box.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/pigeons.png" alt="Two pigeons in the same hole." class="img_ev3q">
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="separate-chaining">Separate chaining<a href="#separate-chaining" class="hash-link" aria-label="Separate chaining的直接链接" title="Separate chaining的直接链接">​</a></h3>
<p>Techniques for resolving collisions fall into two broad categories. The first is
<strong>separate chaining</strong>. Instead of each bucket containing a single entry, we let
it contain a collection of them. In the classic implementation, each bucket
points to a linked list of entries. To look up an entry, you find its bucket and
then walk the list until you find an entry with the matching key.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/chaining.png" alt="An array with eight buckets. Bucket 2 links to a chain of two nodes. Bucket 5 links to a single node." class="img_ev3q">
<p>In catastrophically bad cases where every entry collides in the same bucket, the
data structure degrades into a single unsorted linked list with <em>O(n)</em> lookup.
In practice, it&#x27;s easy to avoid that by controlling the load factor and how
entries get scattered across buckets. In typical separate-chained hash tables,
it&#x27;s rare for a bucket to have more than one or two entries.</p>
<p>Separate chaining is conceptually simple -- it&#x27;s literally an array of linked
lists. Most operations are straightforward to implement, even deletion which, as
we&#x27;ll see, can be a pain. But it&#x27;s not a great fit for modern CPUs. It has a lot
of overhead from pointers and tends to scatter little linked list <span name="node">nodes</span> around in memory which isn&#x27;t great for cache usage.</p>
<aside name="node">
<p>There are a few tricks to optimize this. Many implementations store the first
entry right in the bucket so that in the common case where there&#x27;s only one, no
extra pointer indirection is needed. You can also make each linked list node
store a few entries to reduce the pointer overhead.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="open-addressing">Open addressing<a href="#open-addressing" class="hash-link" aria-label="Open addressing的直接链接" title="Open addressing的直接链接">​</a></h3>
<p>The other technique is <span name="open">called</span> <strong>open addressing</strong> or
(confusingly) <strong>closed hashing</strong>. With this technique, all entries live directly
in the bucket array, with one entry per bucket. If two entries collide in the
same bucket, we find a different empty bucket to use instead.</p>
<aside name="open">
<p>It&#x27;s called &quot;open&quot; addressing because the entry may end up at an address
(bucket) outside of its preferred one. It&#x27;s called &quot;closed&quot; hashing because all
of the entries stay inside the array of buckets.</p>
</aside>
<p>Storing all entries in a single, big, contiguous array is great for keeping the
memory representation simple and fast. But it makes all of the operations on the
hash table more complex. When inserting an entry, its bucket may be full,
sending us to look at another bucket. That bucket itself may be occupied and so
on. This process of finding an available bucket is called <strong>probing</strong>, and the
order that you examine buckets is a <strong>probe sequence</strong>.</p>
<p>There are a <span name="probe">number</span> of algorithms for determining
which buckets to probe and how to decide which entry goes in which bucket.
There&#x27;s been a ton of research here because even slight tweaks can have a large
performance impact. And, on a data structure as heavily used as hash tables,
that performance impact touches a very large number of real-world programs
across a range of hardware capabilities.</p>
<aside name="probe">
<p>If you&#x27;d like to learn more (and you should, because some of these are really
cool), look into &quot;double hashing&quot;, &quot;cuckoo hashing&quot;, &quot;Robin Hood hashing&quot;, and
anything those lead you to.</p>
</aside>
<p>As usual in this book, we&#x27;ll pick the simplest one that gets the job done
efficiently. That&#x27;s good old <strong>linear probing</strong>. When looking for an entry, we
look in the first bucket its key maps to. If it&#x27;s not in there, we look in the
very next element in the array, and so on. If we reach the end, we wrap back
around to the beginning.</p>
<p>The good thing about linear probing is that it&#x27;s cache friendly. Since you walk
the array directly in memory order, it keeps the CPU&#x27;s cache lines full and
happy. The bad thing is that it&#x27;s prone to <strong>clustering</strong>. If you have a lot of
entries with numerically similar key values, you can end up with a lot of
colliding, overflowing buckets right next to each other.</p>
<p>Compared to separate chaining, open addressing can be harder to wrap your head
around. I think of open addressing as similar to separate chaining except that
the &quot;list&quot; of nodes is threaded through the bucket array itself. Instead of
storing the links between them in pointers, the connections are calculated
implicitly by the order that you look through the buckets.</p>
<p>The tricky part is that more than one of these implicit lists may be interleaved
together. Let&#x27;s walk through an example that covers all the interesting cases.
We&#x27;ll ignore values for now and just worry about a set of keys. We start with an
empty array of 8 buckets.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/insert-1.png" alt="An array with eight empty buckets." class="wide img_ev3q">
<p>We decide to insert &quot;bagel&quot;. The first letter, &quot;b&quot; (ASCII value 98), modulo the
array size (8) puts it in bucket 2.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/insert-2.png" alt="Bagel goes into bucket 2." class="wide img_ev3q">
<p>Next, we insert &quot;jam&quot;. That also wants to go in bucket 2 (106 mod 8 = 2), but
that bucket&#x27;s taken. We keep probing to the next bucket. It&#x27;s empty, so we put
it there.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/insert-3.png" alt="Jam goes into bucket 3, since 2 is full." class="wide img_ev3q">
<p>We insert &quot;fruit&quot;, which happily lands in bucket 6.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/insert-4.png" alt="Fruit goes into bucket 6." class="wide img_ev3q">
<p>Likewise, &quot;migas&quot; can go in its preferred bucket 5.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/insert-5.png" alt="Migas goes into bucket 5." class="wide img_ev3q">
<p>When we try to insert &quot;eggs&quot;, it also wants to be in bucket 5. That&#x27;s full, so we
skip to 6. Bucket 6 is also full. Note that the entry in there is <em>not</em> part of
the same probe sequence. &quot;Fruit&quot; is in its preferred bucket, 6. So the 5 and 6
sequences have collided and are interleaved. We skip over that and finally put
&quot;eggs&quot; in bucket 7.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/insert-6.png" alt="Eggs goes into bucket 7 because 5 and 6 are full." class="wide img_ev3q">
<p>We run into a similar problem with &quot;nuts&quot;. It can&#x27;t land in 6 like it wants to.
Nor can it go into 7. So we keep going. But we&#x27;ve reached the end of the array,
so we wrap back around to 0 and put it there.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/insert-7.png" alt="Nuts wraps around to bucket 0 because 6 and 7 are full." class="wide img_ev3q">
<p>In practice, the interleaving turns out to not be much of a problem. Even in
separate chaining, we need to walk the list to check each entry&#x27;s key because
multiple keys can reduce to the same bucket. With open addressing, we need to do
that same check, and that also covers the case where you are stepping over
entries that &quot;belong&quot; to a different original bucket.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="hash-functions">Hash Functions<a href="#hash-functions" class="hash-link" aria-label="Hash Functions的直接链接" title="Hash Functions的直接链接">​</a></h2>
<p>We can now build ourselves a reasonably efficient table for storing variable
names up to eight characters long, but that limitation is still annoying. In
order to relax the last constraint, we need a way to take a string of any length
and convert it to a fixed-size integer.</p>
<p>Finally, we get to the &quot;hash&quot; part of &quot;hash table&quot;. A <strong>hash function</strong> takes
some larger blob of data and &quot;hashes&quot; it to produce a fixed-size integer <strong>hash
code</strong> whose value depends on all of the bits of the original data. A <span name="crypto">good</span> hash function has three main goals:</p>
<aside name="crypto">
<p>Hash functions are also used for cryptography. In that domain, &quot;good&quot; has a
<em>much</em> more stringent definition to avoid exposing details about the data being
hashed. We, thankfully, don&#x27;t need to worry about those concerns for this book.</p>
</aside>
<ul>
<li>
<p><strong>It must be <em>deterministic</em>.</strong> The same input must always hash to the same
number. If the same variable ends up in different buckets at different
points in time, it&#x27;s gonna get really hard to find it.</p>
</li>
<li>
<p><strong>It must be <em>uniform</em>.</strong> Given a typical set of inputs, it should produce a
wide and evenly distributed range of output numbers, with as few clumps or
patterns as possible. We want it to <span name="scatter">scatter</span>
values across the whole numeric range to minimize collisions and clustering.</p>
</li>
<li>
<p><strong>It must be <em>fast</em>.</strong> Every operation on the hash table requires us to hash
the key first. If hashing is slow, it can potentially cancel out the speed
of the underlying array storage.</p>
</li>
</ul>
<aside name="scatter">
<p>One of the original names for a hash table was &quot;scatter table&quot; because it takes
the entries and scatters them throughout the array. The word &quot;hash&quot; came from
the idea that a hash function takes the input data, chops it up, and tosses it
all together into a pile to come up with a single number from all of those bits.</p>
</aside>
<p>There is a veritable pile of hash functions out there. Some are old and
optimized for architectures no one uses anymore. Some are designed to be fast,
others cryptographically secure. Some take advantage of vector instructions and
cache sizes for specific chips, others aim to maximize portability.</p>
<p>There are people out there for whom designing and evaluating hash functions is,
like, their <em>jam</em>. I admire them, but I&#x27;m not mathematically astute enough to
<em>be</em> one. So for clox, I picked a simple, well-worn hash function called
<a href="http://www.isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="noopener noreferrer">FNV-1a</a> that&#x27;s served me fine over the years. Consider <span name="thing">trying</span> out different ones in your code and see if they make
a difference.</p>
<aside name="thing">
<p>Who knows, maybe hash functions could turn out to be your thing too?</p>
</aside>
<p>OK, that&#x27;s a quick run through of buckets, load factors, open addressing,
collision resolution, and hash functions. That&#x27;s an awful lot of text and not a
lot of real code. Don&#x27;t worry if it still seems vague. Once we&#x27;re done coding it
up, it will all click into place.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="building-a-hash-table">Building a Hash Table<a href="#building-a-hash-table" class="hash-link" aria-label="Building a Hash Table的直接链接" title="Building a Hash Table的直接链接">​</a></h2>
<p>The great thing about hash tables compared to other classic techniques like
balanced search trees is that the actual data structure is so simple. Ours goes
into a new module.</p>
<p>^code table-h</p>
<p>A hash table is an array of entries. As in our dynamic array earlier, we keep
track of both the allocated size of the array (<code>capacity</code>) and the number of
key/value pairs currently stored in it (<code>count</code>). The ratio of count to capacity
is exactly the load factor of the hash table.</p>
<p>Each entry is one of these:</p>
<p>^code entry (1 before, 2 after)</p>
<p>It&#x27;s a simple key/value pair. Since the key is always a <span name="string">string</span>, we store the ObjString pointer directly instead of
wrapping it in a Value. It&#x27;s a little faster and smaller this way.</p>
<aside name="string">
<p>In clox, we only need to support keys that are strings. Handling other types of
keys doesn&#x27;t add much complexity. As long as you can compare two objects for
equality and reduce them to sequences of bits, it&#x27;s easy to use them as hash
keys.</p>
</aside>
<p>To create a new, empty hash table, we declare a constructor-like function.</p>
<p>^code init-table-h (2 before, 2 after)</p>
<p>We need a new implementation file to define that. While we&#x27;re at it, let&#x27;s get
all of the pesky includes out of the way.</p>
<p>^code table-c</p>
<p>As in our dynamic value array type, a hash table initially starts with zero
capacity and a <code>NULL</code> array. We don&#x27;t allocate anything until needed. Assuming
we do eventually allocate something, we need to be able to free it too.</p>
<p>^code free-table-h (1 before, 2 after)</p>
<p>And its glorious implementation:</p>
<p>^code free-table</p>
<p>Again, it looks just like a dynamic array. In fact, you can think of a hash
table as basically a dynamic array with a really strange policy for inserting
items. We don&#x27;t need to check for <code>NULL</code> here since <code>FREE_ARRAY()</code> already
handles that gracefully.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashing-strings">Hashing strings<a href="#hashing-strings" class="hash-link" aria-label="Hashing strings的直接链接" title="Hashing strings的直接链接">​</a></h3>
<p>Before we can start putting entries in the table, we need to, well, hash them.
To ensure that the entries get distributed uniformly throughout the array, we
want a good hash function that looks at all of the bits of the key string. If it
looked at, say, only the first few characters, then a series of strings that all
shared the same prefix would end up colliding in the same bucket.</p>
<p>On the other hand, walking the entire string to calculate the hash is kind of
slow. We&#x27;d lose some of the performance benefit of the hash table if we had to
walk the string every time we looked for a key in the table. So we&#x27;ll do the
obvious thing: cache it.</p>
<p>Over in the &quot;object&quot; module in ObjString, we add:</p>
<p>^code obj-string-hash (1 before, 1 after)</p>
<p>Each ObjString stores the hash code for its string. Since strings are immutable
in Lox, we can calculate the hash code once up front and be certain that it will
never get invalidated. Caching it eagerly makes a kind of sense: allocating the
string and copying its characters over is already an <em>O(n)</em> operation, so it&#x27;s a
good time to also do the <em>O(n)</em> calculation of the string&#x27;s hash.</p>
<p>Whenever we call the internal function to allocate a string, we pass in its
hash code.</p>
<p>^code allocate-string (1 after)</p>
<p>That function simply stores the hash in the struct.</p>
<p>^code allocate-store-hash (1 before, 2 after)</p>
<p>The fun happens over at the callers. <code>allocateString()</code> is called from two
places: the function that copies a string and the one that takes ownership of an
existing dynamically allocated string. We&#x27;ll start with the first.</p>
<p>^code copy-string-hash (1 before, 1 after)</p>
<p>No magic here. We calculate the hash code and then pass it along.</p>
<p>^code copy-string-allocate (2 before, 1 after)</p>
<p>The other string function is similar.</p>
<p>^code take-string-hash (1 before, 1 after)</p>
<p>The interesting code is over here:</p>
<p>^code hash-string</p>
<p>This is the actual bona fide &quot;hash function&quot; in clox. The algorithm is called
&quot;FNV-1a&quot;, and is the shortest decent hash function I know. Brevity is certainly
a virtue in a book that aims to show you every line of code.</p>
<p>The basic idea is pretty simple, and many hash functions follow the same
pattern. You start with some initial hash value, usually a constant with certain
carefully chosen mathematical properties. Then you walk the data to be hashed.
For each byte (or sometimes word), you mix the bits into the hash value somehow,
and then scramble the resulting bits around some.</p>
<p>What it means to &quot;mix&quot; and &quot;scramble&quot; can get pretty sophisticated. Ultimately,
though, the basic goal is <em>uniformity</em> -- we want the resulting hash values to
be as widely scattered around the numeric range as possible to avoid collisions
and clustering.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="inserting-entries">Inserting entries<a href="#inserting-entries" class="hash-link" aria-label="Inserting entries的直接链接" title="Inserting entries的直接链接">​</a></h3>
<p>Now that string objects know their hash code, we can start putting them into
hash tables.</p>
<p>^code table-set-h (1 before, 2 after)</p>
<p>This function adds the given key/value pair to the given hash table. If an entry
for that key is already present, the new value overwrites the old value. The
function returns <code>true</code> if a new entry was added. Here&#x27;s the implementation:</p>
<p>^code table-set</p>
<p>Most of the interesting logic is in <code>findEntry()</code> which we&#x27;ll get to soon. That
function&#x27;s job is to take a key and figure out which bucket in the array it
should go in. It returns a pointer to that bucket -- the address of the Entry in
the array.</p>
<p>Once we have a bucket, inserting is straightforward. We update the hash table&#x27;s
size, taking care to not increase the count if we overwrote the value for an
already-present key. Then we copy the key and value into the corresponding
fields in the Entry.</p>
<p>We&#x27;re missing a little something here, though. We haven&#x27;t actually allocated the
Entry array yet. Oops! Before we can insert anything, we need to make sure we
have an array, and that it&#x27;s big enough.</p>
<p>^code table-set-grow (1 before, 1 after)</p>
<p>This is similar to the code we wrote a while back for growing a dynamic array.
If we don&#x27;t have enough capacity to insert an item, we reallocate and grow the
array. The <code>GROW_CAPACITY()</code> macro takes an existing capacity and grows it by
a multiple to ensure that we get amortized constant performance over a series
of inserts.</p>
<p>The interesting difference here is that <code>TABLE_MAX_LOAD</code> constant.</p>
<p>^code max-load (2 before, 1 after)</p>
<p>This is how we manage the table&#x27;s <span name="75">load</span> factor. We don&#x27;t
grow when the capacity is completely full. Instead, we grow the array before
then, when the array becomes at least 75% full.</p>
<aside name="75">
<p>Ideal max load factor varies based on the hash function, collision-handling
strategy, and typical keysets you&#x27;ll see. Since a toy language like Lox doesn&#x27;t
have &quot;real world&quot; data sets, it&#x27;s hard to optimize this, and I picked 75%
somewhat arbitrarily. When you build your own hash tables, benchmark and tune
this.</p>
</aside>
<p>We&#x27;ll get to the implementation of <code>adjustCapacity()</code> soon. First, let&#x27;s look
at that <code>findEntry()</code> function you&#x27;ve been wondering about.</p>
<p>^code find-entry</p>
<p>This function is the real core of the hash table. It&#x27;s responsible for taking a
key and an array of buckets, and figuring out which bucket the entry belongs in.
This function is also where linear probing and collision handling come into
play. We&#x27;ll use <code>findEntry()</code> both to look up existing entries in the hash
table and to decide where to insert new ones.</p>
<p>For all that, there isn&#x27;t much to it. First, we use modulo to map the key&#x27;s hash
code to an index within the array&#x27;s bounds. That gives us a bucket index where,
ideally, we&#x27;ll be able to find or place the entry.</p>
<p>There are a few cases to check for:</p>
<ul>
<li>
<p>If the key for the Entry at that array index is <code>NULL</code>, then the bucket is
empty. If we&#x27;re using <code>findEntry()</code> to look up something in the hash table,
this means it isn&#x27;t there. If we&#x27;re using it to insert, it means we&#x27;ve found
a place to add the new entry.</p>
</li>
<li>
<p>If the key in the bucket is <span name="equal">equal</span> to the key we&#x27;re
looking for, then that key is already present in the table. If we&#x27;re doing a
lookup, that&#x27;s good -- we&#x27;ve found the key we seek. If we&#x27;re doing an insert,
this means we&#x27;ll be replacing the value for that key instead of adding a new
entry.</p>
</li>
</ul>
<aside name="equal">
<p>It looks like we&#x27;re using <code>==</code> to see if two strings are equal. That doesn&#x27;t
work, does it? There could be two copies of the same string at different places
in memory. Fear not, astute reader. We&#x27;ll solve this further on. And, strangely
enough, it&#x27;s a hash table that provides the tool we need.</p>
</aside>
<ul>
<li>Otherwise, the bucket has an entry in it, but with a different key. This is
a collision. In that case, we start probing. That&#x27;s what that <code>for</code> loop
does. We start at the bucket where the entry would ideally go. If that
bucket is empty or has the same key, we&#x27;re done. Otherwise, we advance to
the next element -- this is the <em>linear</em> part of &quot;linear probing&quot; -- and
check there. If we go past the end of the array, that second modulo operator
wraps us back around to the beginning.</li>
</ul>
<p>We exit the loop when we find either an empty bucket or a bucket with the same
key as the one we&#x27;re looking for. You might be wondering about an infinite loop.
What if we collide with <em>every</em> bucket? Fortunately, that can&#x27;t happen thanks to
our load factor. Because we grow the array as soon as it gets close to being
full, we know there will always be empty buckets.</p>
<p>We return directly from within the loop, yielding a pointer to the found Entry
so the caller can either insert something into it or read from it. Way back in
<code>tableSet()</code>, the function that first kicked this off, we store the new entry in
that returned bucket and we&#x27;re done.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="allocating-and-resizing">Allocating and resizing<a href="#allocating-and-resizing" class="hash-link" aria-label="Allocating and resizing的直接链接" title="Allocating and resizing的直接链接">​</a></h3>
<p>Before we can put entries in the hash table, we do need a place to actually
store them. We need to allocate an array of buckets. That happens in this
function:</p>
<p>^code table-adjust-capacity</p>
<p>We create a bucket array with <code>capacity</code> entries. After we allocate the array,
we initialize every element to be an empty bucket and then store the array (and
its capacity) in the hash table&#x27;s main struct. This code is fine for when we
insert the very first entry into the table, and we require the first allocation
of the array. But what about when we already have one and we need to grow it?</p>
<p>Back when we were doing a dynamic array, we could just use <code>realloc()</code> and let
the C standard library copy everything over. That doesn&#x27;t work for a hash table.
Remember that to choose the bucket for each entry, we take its hash key <em>modulo
the array size</em>. That means that when the array size changes, entries may end up
in different buckets.</p>
<p>Those new buckets may have new collisions that we need to deal with. So the
simplest way to get every entry where it belongs is to rebuild the table from
scratch by re-inserting every entry into the new empty array.</p>
<p>^code re-hash (2 before, 2 after)</p>
<p>We walk through the old array front to back. Any time we find a non-empty
bucket, we insert that entry into the new array. We use <code>findEntry()</code>, passing
in the <em>new</em> array instead of the one currently stored in the Table. (This is
why <code>findEntry()</code> takes a pointer directly to an Entry array and not the whole
<code>Table</code> struct. That way, we can pass the new array and capacity before we&#x27;ve
stored those in the struct.)</p>
<p>After that&#x27;s done, we can release the memory for the old array.</p>
<p>^code free-old-array (3 before, 1 after)</p>
<p>With that, we have a hash table that we can stuff as many entries into as we
like. It handles overwriting existing keys and growing itself as needed to
maintain the desired load capacity.</p>
<p>While we&#x27;re at it, let&#x27;s also define a helper function for copying all of the
entries of one hash table into another.</p>
<p>^code table-add-all-h (1 before, 2 after)</p>
<p>We won&#x27;t need this until much later when we support method inheritance, but we
may as well implement it now while we&#x27;ve got all the hash table stuff fresh in
our minds.</p>
<p>^code table-add-all</p>
<p>There&#x27;s not much to say about this. It walks the bucket array of the source hash
table. Whenever it finds a non-empty bucket, it adds the entry to the
destination hash table using the <code>tableSet()</code> function we recently defined.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="retrieving-values">Retrieving values<a href="#retrieving-values" class="hash-link" aria-label="Retrieving values的直接链接" title="Retrieving values的直接链接">​</a></h3>
<p>Now that our hash table contains some stuff, let&#x27;s start pulling things back
out. Given a key, we can look up the corresponding value, if there is one, with
this function:</p>
<p>^code table-get-h (1 before, 1 after)</p>
<p>You pass in a table and a key. If it finds an entry with that key, it returns
<code>true</code>, otherwise it returns <code>false</code>. If the entry exists, the <code>value</code> output
parameter points to the resulting value.</p>
<p>Since <code>findEntry()</code> already does the hard work, the implementation isn&#x27;t bad.</p>
<p>^code table-get</p>
<p>If the table is completely empty, we definitely won&#x27;t find the entry, so we
check for that first. This isn&#x27;t just an optimization -- it also ensures that we
don&#x27;t try to access the bucket array when the array is <code>NULL</code>. Otherwise, we let
<code>findEntry()</code> work its magic. That returns a pointer to a bucket. If the bucket
is empty, which we detect by seeing if the key is <code>NULL</code>, then we didn&#x27;t find an
Entry with our key. If <code>findEntry()</code> does return a non-empty Entry, then that&#x27;s
our match. We take the Entry&#x27;s value and copy it to the output parameter so the
caller can get it. Piece of cake.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="deleting-entries">Deleting entries<a href="#deleting-entries" class="hash-link" aria-label="Deleting entries的直接链接" title="Deleting entries的直接链接">​</a></h3>
<p>There is one more fundamental operation a full-featured hash table needs to
support: removing an entry. This seems pretty obvious, if you can add things,
you should be able to <em>un</em>-add them, right? But you&#x27;d be surprised how many
tutorials on hash tables omit this.</p>
<p>I could have taken that route too. In fact, we use deletion in clox only in a
tiny edge case in the VM. But if you want to actually understand how to
completely implement a hash table, this feels important. I can sympathize with
their desire to overlook it. As we&#x27;ll see, deleting from a hash table that uses
<span name="delete">open</span> addressing is tricky.</p>
<aside name="delete">
<p>With separate chaining, deleting is as easy as removing a node from a linked
list.</p>
</aside>
<p>At least the declaration is simple.</p>
<p>^code table-delete-h (1 before, 1 after)</p>
<p>The obvious approach is to mirror insertion. Use <code>findEntry()</code> to look up the
entry&#x27;s bucket. Then clear out the bucket. Done!</p>
<p>In cases where there are no collisions, that works fine. But if a collision has
occurred, then the bucket where the entry lives may be part of one or more
implicit probe sequences. For example, here&#x27;s a hash table containing three keys
all with the same preferred bucket, 2:</p>
<img decoding="async" loading="lazy" src="image/hash-tables/delete-1.png" alt="A hash table containing &#x27;bagel&#x27; in bucket 2, &#x27;biscuit&#x27; in bucket 3, and &#x27;jam&#x27; in bucket 4." class="img_ev3q">
<p>Remember that when we&#x27;re walking a probe sequence to find an entry, we know
we&#x27;ve reached the end of a sequence and that the entry isn&#x27;t present when we hit
an empty bucket. It&#x27;s like the probe sequence is a list of entries and an empty
entry terminates that list.</p>
<p>If we delete &quot;biscuit&quot; by simply clearing the Entry, then we break that probe
sequence in the middle, leaving the trailing entries orphaned and unreachable.
Sort of like removing a node from a linked list without relinking the pointer
from the previous node to the next one.</p>
<p>If we later try to look for &quot;jam&quot;, we&#x27;d start at &quot;bagel&quot;, stop at the next
empty Entry, and never find it.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/delete-2.png" alt="The &#x27;biscuit&#x27; entry has been deleted from the hash table, breaking the chain." class="img_ev3q">
<p>To solve this, most implementations use a trick called <span name="tombstone"><strong>tombstones</strong></span>. Instead of clearing the entry on
deletion, we replace it with a special sentinel entry called a &quot;tombstone&quot;. When
we are following a probe sequence during a lookup, and we hit a tombstone, we
<em>don&#x27;t</em> treat it like an empty slot and stop iterating. Instead, we keep going
so that deleting an entry doesn&#x27;t break any implicit collision chains and we can
still find entries after it.</p>
<img decoding="async" loading="lazy" src="image/hash-tables/delete-3.png" alt="Instead of deleting &#x27;biscuit&#x27;, it&#x27;s replaced with a tombstone." class="img_ev3q">
<p>The code looks like this:</p>
<p>^code table-delete</p>
<p>First, we find the bucket containing the entry we want to delete. (If we don&#x27;t
find it, there&#x27;s nothing to delete, so we bail out.) We replace the entry with a
tombstone. In clox, we use a <code>NULL</code> key and a <code>true</code> value to represent that,
but any representation that can&#x27;t be confused with an empty bucket or a valid
entry works.</p>
<aside name="tombstone">
<img decoding="async" loading="lazy" src="image/hash-tables/tombstone.png" alt="A tombstone enscribed &#x27;Here lies entry biscuit → 3.75, gone but not deleted&#x27;." class="img_ev3q">
</aside>
<p>That&#x27;s all we need to do to delete an entry. Simple and fast. But all of the
other operations need to correctly handle tombstones too. A tombstone is a sort
of &quot;half&quot; entry. It has some of the characteristics of a present entry, and some
of the characteristics of an empty one.</p>
<p>When we are following a probe sequence during a lookup, and we hit a tombstone,
we note it and keep going.</p>
<p>^code find-tombstone (2 before, 2 after)</p>
<p>The first time we pass a tombstone, we store it in this local variable:</p>
<p>^code find-entry-tombstone (1 before, 1 after)</p>
<p>If we reach a truly empty entry, then the key isn&#x27;t present. In that case, if we
have passed a tombstone, we return its bucket instead of the later empty one. If
we&#x27;re calling <code>findEntry()</code> in order to insert a node, that lets us treat the
tombstone bucket as empty and reuse it for the new entry.</p>
<p>Reusing tombstone slots automatically like this helps reduce the number of
tombstones wasting space in the bucket array. In typical use cases where there
is a mixture of insertions and deletions, the number of tombstones grows for a
while and then tends to stabilize.</p>
<p>Even so, there&#x27;s no guarantee that a large number of deletes won&#x27;t cause the
array to be full of tombstones. In the very worst case, we could end up with
<em>no</em> empty buckets. That would be bad because, remember, the only thing
preventing an infinite loop in <code>findEntry()</code> is the assumption that we&#x27;ll
eventually hit an empty bucket.</p>
<p>So we need to be thoughtful about how tombstones interact with the table&#x27;s load
factor and resizing. The key question is, when calculating the load factor,
should we treat tombstones like full buckets or empty ones?</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="counting-tombstones">Counting tombstones<a href="#counting-tombstones" class="hash-link" aria-label="Counting tombstones的直接链接" title="Counting tombstones的直接链接">​</a></h3>
<p>If we treat tombstones like full buckets, then we may end up with a bigger array
than we probably need because it artificially inflates the load factor. There
are tombstones we could reuse, but they aren&#x27;t treated as unused so we end up
growing the array prematurely.</p>
<p>But if we treat tombstones like empty buckets and <em>don&#x27;t</em> include them in the
load factor, then we run the risk of ending up with <em>no</em> actual empty buckets to
terminate a lookup. An infinite loop is a much worse problem than a few extra
array slots, so for load factor, we consider tombstones to be full buckets.</p>
<p>That&#x27;s why we don&#x27;t reduce the count when deleting an entry in the previous
code. The count is no longer the number of entries in the hash table, it&#x27;s the
number of entries plus tombstones. That implies that we increment the count
during insertion only if the new entry goes into an entirely empty bucket.</p>
<p>^code set-increment-count (1 before, 2 after)</p>
<p>If we are replacing a tombstone with a new entry, the bucket has already been
accounted for and the count doesn&#x27;t change.</p>
<p>When we resize the array, we allocate a new array and re-insert all of the
existing entries into it. During that process, we <em>don&#x27;t</em> copy the tombstones
over. They don&#x27;t add any value since we&#x27;re rebuilding the probe sequences
anyway, and would just slow down lookups. That means we need to recalculate the
count since it may change during a resize. So we clear it out:</p>
<p>^code resize-init-count (2 before, 1 after)</p>
<p>Then each time we find a non-tombstone entry, we increment it.</p>
<p>^code resize-increment-count (1 before, 1 after)</p>
<p>This means that when we grow the capacity, we may end up with <em>fewer</em> entries in
the resulting larger array because all of the tombstones get discarded. That&#x27;s a
little wasteful, but not a huge practical problem.</p>
<p>I find it interesting that much of the work to support deleting entries is in
<code>findEntry()</code> and <code>adjustCapacity()</code>. The actual delete logic is quite simple
and fast. In practice, deletions tend to be rare, so you&#x27;d expect a hash table
to do as much work as it can in the delete function and leave the other
functions alone to keep them faster. With our tombstone approach, deletes are
fast, but lookups get penalized.</p>
<p>I did a little benchmarking to test this out in a few different deletion
scenarios. I was surprised to discover that tombstones did end up being faster
overall compared to doing all the work during deletion to reinsert the affected
entries.</p>
<p>But if you think about it, it&#x27;s not that the tombstone approach pushes the work
of fully deleting an entry to other operations, it&#x27;s more that it makes deleting
<em>lazy</em>. At first, it does the minimal work to turn the entry into a tombstone.
That can cause a penalty when later lookups have to skip over it. But it also
allows that tombstone bucket to be reused by a later insert too. That reuse is a
very efficient way to avoid the cost of rearranging all of the following
affected entries. You basically recycle a node in the chain of probed entries.
It&#x27;s a neat trick.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="string-interning">String Interning<a href="#string-interning" class="hash-link" aria-label="String Interning的直接链接" title="String Interning的直接链接">​</a></h2>
<p>We&#x27;ve got ourselves a hash table that mostly works, though it has a critical
flaw in its center. Also, we aren&#x27;t using it for anything yet. It&#x27;s time to
address both of those and, in the process, learn a classic technique used by
interpreters.</p>
<p>The reason the hash table doesn&#x27;t totally work is that when <code>findEntry()</code> checks
to see if an existing key matches the one it&#x27;s looking for, it uses <code>==</code> to
compare two strings for equality. That only returns true if the two keys are the
exact same string in memory. Two separate strings with the same characters
should be considered equal, but aren&#x27;t.</p>
<p>Remember, back when we added strings in the last chapter, we added <a href="/docs/Craftinginterpreters/not-translated-yet/strings.html#operations-on-strings">explicit
support to compare the strings character-by-character</a> in order to get
true value equality. We could do that in <code>findEntry()</code>, but that&#x27;s <span name="hash-collision">slow</span>.</p>
<aside name="hash-collision">
<p>In practice, we would first compare the hash codes of the two strings. That
quickly detects almost all different strings -- it wouldn&#x27;t be a very good hash
function if it didn&#x27;t. But when the two hashes are the same, we still have to
compare characters to make sure we didn&#x27;t have a hash collision on different
strings.</p>
</aside>
<p>Instead, we&#x27;ll use a technique called <strong>string interning</strong>. The core problem is
that it&#x27;s possible to have different strings in memory with the same characters.
Those need to behave like equivalent values even though they are distinct
objects. They&#x27;re essentially duplicates, and we have to compare all of their
bytes to detect that.</p>
<p><span name="intern">String interning</span> is a process of deduplication. We
create a collection of &quot;interned&quot; strings. Any string in that collection is
guaranteed to be textually distinct from all others. When you intern a string,
you look for a matching string in the collection. If found, you use that
original one. Otherwise, the string you have is unique, so you add it to the
collection.</p>
<aside name="intern">
<p>I&#x27;m guessing &quot;intern&quot; is short for &quot;internal&quot;. I think the idea is that the
language&#x27;s runtime keeps its own &quot;internal&quot; collection of these strings, whereas
other strings could be user created and floating around in memory. When you
intern a string, you ask the runtime to add the string to that internal
collection and return a pointer to it.</p>
<p>Languages vary in how much string interning they do and how it&#x27;s exposed to the
user. Lua interns <em>all</em> strings, which is what clox will do too. Lisp, Scheme,
Smalltalk, Ruby and others have a separate string-like type called &quot;symbol&quot; that
is implicitly interned. (This is why they say symbols are &quot;faster&quot; in Ruby.)
Java interns constant strings by default, and provides an API to let you
explicitly intern any string you give it.</p>
</aside>
<p>In this way, you know that each sequence of characters is represented by only
one string in memory. This makes value equality trivial. If two strings point
to the same address in memory, they are obviously the same string and must be
equal. And, because we know strings are unique, if two strings point to
different addresses, they must be distinct strings.</p>
<p>Thus, pointer equality exactly matches value equality. Which in turn means that
our existing <code>==</code> in <code>findEntry()</code> does the right thing. Or, at least, it will
once we intern all the strings. In order to reliably deduplicate all strings,
the VM needs to be able to find every string that&#x27;s created. We do that by
giving it a hash table to store them all.</p>
<p>^code vm-strings (1 before, 1 after)</p>
<p>As usual, we need an include.</p>
<p>^code vm-include-table (1 before, 1 after)</p>
<p>When we spin up a new VM, the string table is empty.</p>
<p>^code init-strings (1 before, 1 after)</p>
<p>And when we shut down the VM, we clean up any resources used by the table.</p>
<p>^code free-strings (1 before, 1 after)</p>
<p>Some languages have a separate type or an explicit step to intern a string. For
clox, we&#x27;ll automatically intern every one. That means whenever we create a new
unique string, we add it to the table.</p>
<p>^code allocate-store-string (1 before, 1 after)</p>
<p>We&#x27;re using the table more like a hash <em>set</em> than a hash <em>table</em>. The keys are
the strings and those are all we care about, so we just use <code>nil</code> for the
values.</p>
<p>This gets a string into the table assuming that it&#x27;s unique, but we need to
actually check for duplication before we get here. We do that in the two
higher-level functions that call <code>allocateString()</code>. Here&#x27;s one:</p>
<p>^code copy-string-intern (1 before, 1 after)</p>
<p>When copying a string into a new LoxString, we look it up in the string table
first. If we find it, instead of &quot;copying&quot;, we just return a reference to that
string. Otherwise, we fall through, allocate a new string, and store it in the
string table.</p>
<p>Taking ownership of a string is a little different.</p>
<p>^code take-string-intern (1 before, 1 after)</p>
<p>Again, we look up the string in the string table first. If we find it, before we
return it, we free the memory for the string that was passed in. Since ownership
is being passed to this function and we no longer need the duplicate string,
it&#x27;s up to us to free it.</p>
<p>Before we get to the new function we need to write, there&#x27;s one more include.</p>
<p>^code object-include-table (1 before, 1 after)</p>
<p>To look for a string in the table, we can&#x27;t use the normal <code>tableGet()</code> function
because that calls <code>findEntry()</code>, which has the exact problem with duplicate
strings that we&#x27;re trying to fix right now. Instead, we use this new function:</p>
<p>^code table-find-string-h (1 before, 2 after)</p>
<p>The implementation looks like so:</p>
<p>^code table-find-string</p>
<p>It appears we have copy-pasted <code>findEntry()</code>. There is a lot of redundancy, but
also a couple of key differences. First, we pass in the raw character array of
the key we&#x27;re looking for instead of an ObjString. At the point that we call
this, we haven&#x27;t created an ObjString yet.</p>
<p>Second, when checking to see if we found the key, we look at the actual strings.
We first see if they have matching lengths and hashes. Those are quick to check
and if they aren&#x27;t equal, the strings definitely aren&#x27;t the same.</p>
<p>If there is a hash collision, we do an actual character-by-character string
comparison. This is the one place in the VM where we actually test strings for
textual equality. We do it here to deduplicate strings and then the rest of the
VM can take for granted that any two strings at different addresses in memory
must have different contents.</p>
<p>In fact, now that we&#x27;ve interned all the strings, we can take advantage of it in
the bytecode interpreter. When a user does <code>==</code> on two objects that happen to be
strings, we don&#x27;t need to test the characters any more.</p>
<p>^code equal (1 before, 1 after)</p>
<p>We&#x27;ve added a little overhead when creating strings to intern them. But in
return, at runtime, the equality operator on strings is much faster. With that,
we have a full-featured hash table ready for us to use for tracking variables,
instances, or any other key-value pairs that might show up.</p>
<p>We also sped up testing strings for equality. This is nice for when the user
does <code>==</code> on strings. But it&#x27;s even more critical in a dynamically typed
language like Lox where method calls and instance fields are looked up by name
at runtime. If testing a string for equality is slow, then that means looking up
a method by name is slow. And if <em>that&#x27;s</em> slow in your object-oriented language,
then <em>everything</em> is slow.</p>
<div class="challenges">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h2>
<ol>
<li>
<p>In clox, we happen to only need keys that are strings, so the hash table we
built is hardcoded for that key type. If we exposed hash tables to Lox users
as a first-class collection, it would be useful to support different kinds
of keys.</p>
<p>Add support for keys of the other primitive types: numbers, Booleans, and
<code>nil</code>. Later, clox will support user-defined classes. If we want to support
keys that are instances of those classes, what kind of complexity does that
add?</p>
</li>
<li>
<p>Hash tables have a lot of knobs you can tweak that affect their performance.
You decide whether to use separate chaining or open addressing. Depending on
which fork in that road you take, you can tune how many entries are stored
in each node, or the probing strategy you use. You control the hash
function, load factor, and growth rate.</p>
<p>All of this variety wasn&#x27;t created just to give CS doctoral candidates
something to <span name="publish">publish</span> theses on: each has its
uses in the many varied domains and hardware scenarios where hashing comes
into play. Look up a few hash table implementations in different open source
systems, research the choices they made, and try to figure out why they did
things that way.</p>
<aside name="publish">
<p>Well, at least that wasn&#x27;t the <em>only</em> reason they were created. Whether that
was the <em>main</em> reason is up for debate.</p>
</aside>
</li>
<li>
<p>Benchmarking a hash table is notoriously difficult. A hash table
implementation may perform well with some keysets and poorly with others. It
may work well at small sizes but degrade as it grows, or vice versa. It may
choke when deletions are common, but fly when they aren&#x27;t. Creating
benchmarks that accurately represent how your users will use the hash table
is a challenge.</p>
<p>Write a handful of different benchmark programs to validate our hash table
implementation. How does the performance vary between them? Why did you
choose the specific test cases you chose?</p>
</li>
</ol>
</div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/hash-tables.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Craftinginterpreters/not-translated-yet/global-variables"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">global-variables</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Craftinginterpreters/not-translated-yet/inheritance"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">inheritance</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#an-array-of-buckets" class="table-of-contents__link toc-highlight">An Array of Buckets</a><ul><li><a href="#load-factor-and-wrapped-keys" class="table-of-contents__link toc-highlight">Load factor and wrapped keys</a></li></ul></li><li><a href="#collision-resolution" class="table-of-contents__link toc-highlight">Collision Resolution</a><ul><li><a href="#separate-chaining" class="table-of-contents__link toc-highlight">Separate chaining</a></li><li><a href="#open-addressing" class="table-of-contents__link toc-highlight">Open addressing</a></li></ul></li><li><a href="#hash-functions" class="table-of-contents__link toc-highlight">Hash Functions</a></li><li><a href="#building-a-hash-table" class="table-of-contents__link toc-highlight">Building a Hash Table</a><ul><li><a href="#hashing-strings" class="table-of-contents__link toc-highlight">Hashing strings</a></li><li><a href="#inserting-entries" class="table-of-contents__link toc-highlight">Inserting entries</a></li><li><a href="#allocating-and-resizing" class="table-of-contents__link toc-highlight">Allocating and resizing</a></li><li><a href="#retrieving-values" class="table-of-contents__link toc-highlight">Retrieving values</a></li><li><a href="#deleting-entries" class="table-of-contents__link toc-highlight">Deleting entries</a></li><li><a href="#counting-tombstones" class="table-of-contents__link toc-highlight">Counting tombstones</a></li></ul></li><li><a href="#string-interning" class="table-of-contents__link toc-highlight">String Interning</a></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>