<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Craftinginterpreters/not-translated-yet/statements-and-state" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">statements-and-state | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/statements-and-state"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="statements-and-state | My Site"><meta data-rh="true" name="description" content="All my life, my heart has yearned for a thing I cannot name."><meta data-rh="true" property="og:description" content="All my life, my heart has yearned for a thing I cannot name."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/statements-and-state"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/statements-and-state" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/statements-and-state" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0d35426a.css">
<script src="/assets/js/runtime~main.0868a236.js" defer="defer"></script>
<script src="/assets/js/main.f1c02528.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/english">English</a><button aria-label="展开侧边栏分类 &#x27;English&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/crafting-interpreter">Crafting-interpreter</a><button aria-label="折叠侧边栏分类 &#x27;Crafting-interpreter&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/welcome">Welcome</a><button aria-label="展开侧边栏分类 &#x27;Welcome&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/not-translated-yet">not-translated-yet</a><button aria-label="折叠侧边栏分类 &#x27;not-translated-yet&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-bytecode-virtual-machine">a-bytecode-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-tree-walk-interpreter">a-tree-walk-interpreter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine">a-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/acknowledgements">acknowledgements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-i">appendix-i</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii">appendix-ii</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/backmatter">backmatter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/calls-and-functions">calls-and-functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode">chunks-of-bytecode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes-and-instances">classes-and-instances</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes">classes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/closures">closures</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/compiling-expressions">compiling-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/contents">contents</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/control-flow">control-flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/dedication">dedication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions">evaluating-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/functions">functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection">garbage-collection</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/global-variables">global-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/hash-tables">hash-tables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/inheritance">inheritance</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth">jumping-back-and-forth</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/local-variables">local-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/methods-and-initializers">methods-and-initializers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/optimization">optimization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/parsing-expressions">parsing-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/representing-code">representing-code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding">resolving-and-binding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand">scanning-on-demand</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning">scanning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/statements-and-state">statements-and-state</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/strings">strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/superclasses">superclasses</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/the-lox-language">the-lox-language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/types-of-values">types-of-values</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/crafting-interpreter"><span itemprop="name">Crafting-interpreter</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/not-translated-yet"><span itemprop="name">not-translated-yet</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">statements-and-state</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>statements-and-state</h1></header><blockquote>
<p>All my life, my heart has yearned for a thing I cannot name.
<cite>André Breton, <em>Mad Love</em></cite></p>
</blockquote>
<p>The interpreter we have so far feels less like programming a real language and
more like punching buttons on a calculator. &quot;Programming&quot; to me means building
up a system out of smaller pieces. We can&#x27;t do that yet because we have no way
to bind a name to some data or function. We can&#x27;t compose software without a way
to refer to the pieces.</p>
<p>To support bindings, our interpreter needs internal state. When you define a
variable at the beginning of the program and use it at the end, the interpreter
has to hold on to the value of that variable in the meantime. So in this
chapter, we will give our interpreter a brain that can not just process, but
<em>remember</em>.</p>
<img decoding="async" loading="lazy" src="image/statements-and-state/brain.png" alt="A brain, presumably remembering stuff." class="img_ev3q">
<p>State and <span name="expr">statements</span> go hand in hand. Since statements,
by definition, don&#x27;t evaluate to a value, they need to do something else to be
useful. That something is called a <strong>side effect</strong>. It could mean producing
user-visible output or modifying some state in the interpreter that can be
detected later. The latter makes them a great fit for defining variables or
other named entities.</p>
<aside name="expr">
<p>You could make a language that treats variable declarations as expressions that
both create a binding and produce a value. The only language I know that does
that is Tcl. Scheme seems like a contender, but note that after a <code>let</code>
expression is evaluated, the variable it bound is forgotten. The <code>define</code> syntax
is not an expression.</p>
</aside>
<p>In this chapter, we&#x27;ll do all of that. We&#x27;ll define statements that produce
output (<code>print</code>) and create state (<code>var</code>). We&#x27;ll add expressions to access and
assign to variables. Finally, we&#x27;ll add blocks and local scope. That&#x27;s a lot to
stuff into one chapter, but we&#x27;ll chew through it all one bite at a time.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="statements">Statements<a href="#statements" class="hash-link" aria-label="Statements的直接链接" title="Statements的直接链接">​</a></h2>
<p>We start by extending Lox&#x27;s grammar with statements. They aren&#x27;t very different
from expressions. We start with the two simplest kinds:</p>
<ol>
<li>
<p>An <strong>expression statement</strong> lets you place an expression where a statement
is expected. They exist to evaluate expressions that have side effects. You
may not notice them, but you use them all the time in <span name="expr-stmt">C</span>, Java, and other languages. Any time you see a
function or method call followed by a <code>;</code>, you&#x27;re looking at an expression
statement.</p>
<aside name="expr-stmt">
<p>Pascal is an outlier. It distinguishes between <em>procedures</em> and <em>functions</em>.
Functions return values, but procedures cannot. There is a statement form
for calling a procedure, but functions can only be called where an
expression is expected. There are no expression statements in Pascal.</p>
</aside>
</li>
<li>
<p>A <strong><code>print</code> statement</strong> evaluates an expression and displays the result to
the user. I admit it&#x27;s weird to bake printing right into the language
instead of making it a library function. Doing so is a concession to the
fact that we&#x27;re building this interpreter one chapter at a time and want to
be able to play with it before it&#x27;s all done. To make print a library
function, we&#x27;d have to wait until we had all of the machinery for defining
and calling functions <span name="print">before</span> we could witness any
side effects.</p>
<aside name="print">
<p>I will note with only a modicum of defensiveness that BASIC and Python
have dedicated <code>print</code> statements and they are real languages. Granted,
Python did remove their <code>print</code> statement in 3.0...</p>
</aside>
</li>
</ol>
<p>New syntax means new grammar rules. In this chapter, we finally gain the ability
to parse an entire Lox script. Since Lox is an imperative, dynamically typed
language, the &quot;top level&quot; of a script is simply a list of statements. The new
rules are:</p>
<div class="language-ebnf codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ebnf codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">program        → statement* EOF ;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">statement      → exprStmt</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | printStmt ;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">exprStmt       → expression &quot;;&quot; ;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">printStmt      → &quot;print&quot; expression &quot;;&quot; ;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The first rule is now <code>program</code>, which is the starting point for the grammar and
represents a complete Lox script or REPL entry. A program is a list of
statements followed by the special &quot;end of file&quot; token. The mandatory end token
ensures the parser consumes the entire input and doesn&#x27;t silently ignore
erroneous unconsumed tokens at the end of a script.</p>
<p>Right now, <code>statement</code> only has two cases for the two kinds of statements we&#x27;ve
described. We&#x27;ll fill in more later in this chapter and in the following ones.
The next step is turning this grammar into something we can store in memory --
syntax trees.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="statement-syntax-trees">Statement syntax trees<a href="#statement-syntax-trees" class="hash-link" aria-label="Statement syntax trees的直接链接" title="Statement syntax trees的直接链接">​</a></h3>
<p>There is no place in the grammar where both an expression and a statement are
allowed. The operands of, say, <code>+</code> are always expressions, never statements. The
body of a <code>while</code> loop is always a statement.</p>
<p>Since the two syntaxes are disjoint, we don&#x27;t need a single base class that they
all inherit from. Splitting expressions and statements into separate class
hierarchies enables the Java compiler to help us find dumb mistakes like passing
a statement to a Java method that expects an expression.</p>
<p>That means a new base class for statements. As our elders did before us, we will
use the cryptic name &quot;Stmt&quot;. With great <span name="foresight">foresight</span>,
I have designed our little AST metaprogramming script in anticipation of this.
That&#x27;s why we passed in &quot;Expr&quot; as a parameter to <code>defineAst()</code>. Now we add
another call to define Stmt and its <span name="stmt-ast">subclasses</span>.</p>
<aside name="foresight">
<p>Not really foresight: I wrote all the code for the book before I sliced it into
chapters.</p>
</aside>
<p>^code stmt-ast (2 before, 1 after)</p>
<aside name="stmt-ast">
<p>The generated code for the new nodes is in <a href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii.html">Appendix II</a>: <a href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii.html#expression-statement">Expression statement</a>, <a href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii.html#print-statement">Print statement</a>.</p>
</aside>
<p>Run the AST generator script and behold the resulting &quot;Stmt.java&quot; file with the
syntax tree classes we need for expression and <code>print</code> statements. Don&#x27;t forget
to add the file to your IDE project or makefile or whatever.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parsing-statements">Parsing statements<a href="#parsing-statements" class="hash-link" aria-label="Parsing statements的直接链接" title="Parsing statements的直接链接">​</a></h3>
<p>The parser&#x27;s <code>parse()</code> method that parses and returns a single expression was a
temporary hack to get the last chapter up and running. Now that our grammar has
the correct starting rule, <code>program</code>, we can turn <code>parse()</code> into the real deal.</p>
<p>^code parse</p>
<aside name="parse-error-handling">
<p>What about the code we had in here for catching <code>ParseError</code> exceptions? We&#x27;ll
put better parse error handling in place soon when we add support for additional
statement types.</p>
</aside>
<p>This parses a series of statements, as many as it can find until it hits the end
of the input. This is a pretty direct translation of the <code>program</code> rule into
recursive descent style. We must also chant a minor prayer to the Java verbosity
gods since we are using ArrayList now.</p>
<p>^code parser-imports (2 before, 1 after)</p>
<p>A program is a list of statements, and we parse one of those statements using
this method:</p>
<p>^code parse-statement</p>
<p>A little bare bones, but we&#x27;ll fill it in with more statement types later. We
determine which specific statement rule is matched by looking at the current
token. A <code>print</code> token means it&#x27;s obviously a <code>print</code> statement.</p>
<p>If the next token doesn&#x27;t look like any known kind of statement, we assume it
must be an expression statement. That&#x27;s the typical final fallthrough case when
parsing a statement, since it&#x27;s hard to proactively recognize an expression from
its first token.</p>
<p>Each statement kind gets its own method. First <code>print</code>:</p>
<p>^code parse-print-statement</p>
<p>Since we already matched and consumed the <code>print</code> token itself, we don&#x27;t need to
do that here. We parse the subsequent expression, consume the terminating
semicolon, and emit the syntax tree.</p>
<p>If we didn&#x27;t match a <code>print</code> statement, we must have one of these:</p>
<p>^code parse-expression-statement</p>
<p>Similar to the previous method, we parse an expression followed by a semicolon.
We wrap that Expr in a Stmt of the right type and return it.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="executing-statements">Executing statements<a href="#executing-statements" class="hash-link" aria-label="Executing statements的直接链接" title="Executing statements的直接链接">​</a></h3>
<p>We&#x27;re running through the previous couple of chapters in microcosm, working our
way through the front end. Our parser can now produce statement syntax trees, so
the next and final step is to interpret them. As in expressions, we use the
Visitor pattern, but we have a new visitor interface, Stmt.Visitor, to
implement since statements have their own base class.</p>
<p>We add that to the list of interfaces Interpreter implements.</p>
<p>^code interpreter (1 after)</p>
<aside name="void">
<p>Java doesn&#x27;t let you use lowercase &quot;void&quot; as a generic type argument for obscure
reasons having to do with type erasure and the stack. Instead, there is a
separate &quot;Void&quot; type specifically for this use. Sort of a &quot;boxed void&quot;, like
&quot;Integer&quot; is for &quot;int&quot;.</p>
</aside>
<p>Unlike expressions, statements produce no values, so the return type of the
visit methods is Void, not Object. We have two statement types, and we need a
visit method for each. The easiest is expression statements.</p>
<p>^code visit-expression-stmt</p>
<p>We evaluate the inner expression using our existing <code>evaluate()</code> method and
<span name="discard">discard</span> the value. Then we return <code>null</code>. Java
requires that to satisfy the special capitalized Void return type. Weird, but
what can you do?</p>
<aside name="discard">
<p>Appropriately enough, we discard the value returned by <code>evaluate()</code> by placing
that call inside a <em>Java</em> expression statement.</p>
</aside>
<p>The <code>print</code> statement&#x27;s visit method isn&#x27;t much different.</p>
<p>^code visit-print</p>
<p>Before discarding the expression&#x27;s value, we convert it to a string using the
<code>stringify()</code> method we introduced in the last chapter and then dump it to
stdout.</p>
<p>Our interpreter is able to visit statements now, but we have some work to do to
feed them to it. First, modify the old <code>interpret()</code> method in the Interpreter
class to accept a list of statements -- in other words, a program.</p>
<p>^code interpret</p>
<p>This replaces the old code which took a single expression. The new code relies
on this tiny helper method:</p>
<p>^code execute</p>
<p>That&#x27;s the statement analogue to the <code>evaluate()</code> method we have for
expressions. Since we&#x27;re working with lists now, we need to let Java know.</p>
<p>^code import-list (2 before, 2 after)</p>
<p>The main Lox class is still trying to parse a single expression and pass it to
the interpreter. We fix the parsing line like so:</p>
<p>^code parse-statements (1 before, 2 after)</p>
<p>And then replace the call to the interpreter with this:</p>
<p>^code interpret-statements (2 before, 1 after)</p>
<p>Basically just plumbing the new syntax through. OK, fire up the interpreter and
give it a try. At this point, it&#x27;s worth sketching out a little Lox program in a
text file to run as a script. Something like:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">print &quot;one&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print true;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print 2 + 1;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>It almost looks like a real program! Note that the REPL, too, now requires you
to enter a full statement instead of a simple expression. Don&#x27;t forget your
semicolons.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="global-variables">Global Variables<a href="#global-variables" class="hash-link" aria-label="Global Variables的直接链接" title="Global Variables的直接链接">​</a></h2>
<p>Now that we have statements, we can start working on state. Before we get into
all of the complexity of lexical scoping, we&#x27;ll start off with the easiest kind
of variables -- <span name="globals">globals</span>. We need two new constructs.</p>
<ol>
<li>
<p>A <strong>variable declaration</strong> statement brings a new variable into the world.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var beverage = &quot;espresso&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>This creates a new binding that associates a name (here &quot;beverage&quot;) with a
value (here, the string <code>&quot;espresso&quot;</code>).</p>
</li>
<li>
<p>Once that&#x27;s done, a <strong>variable expression</strong> accesses that binding. When the
identifier &quot;beverage&quot; is used as an expression, it looks up the value bound
to that name and returns it.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">print beverage; // &quot;espresso&quot;.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ol>
<p>Later, we&#x27;ll add assignment and block scope, but that&#x27;s enough to get moving.</p>
<aside name="globals">
<p>Global state gets a bad rap. Sure, lots of global state -- especially <em>mutable</em>
state -- makes it hard to maintain large programs. It&#x27;s good software
engineering to minimize how much you use.</p>
<p>But when you&#x27;re slapping together a simple programming language or, heck, even
learning your first language, the flat simplicity of global variables helps. My
first language was BASIC and, though I outgrew it eventually, it was nice that I
didn&#x27;t have to wrap my head around scoping rules before I could make a computer
do fun stuff.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="variable-syntax">Variable syntax<a href="#variable-syntax" class="hash-link" aria-label="Variable syntax的直接链接" title="Variable syntax的直接链接">​</a></h3>
<p>As before, we&#x27;ll work through the implementation from front to back, starting
with the syntax. Variable declarations are statements, but they are different
from other statements, and we&#x27;re going to split the statement grammar in two to
handle them. That&#x27;s because the grammar restricts where some kinds of statements
are allowed.</p>
<p>The clauses in control flow statements -- think the then and else branches of
an <code>if</code> statement or the body of a <code>while</code> -- are each a single statement. But
that statement is not allowed to be one that declares a name. This is OK:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">if (monday) print &quot;Ugh, already?&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>But this is not:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">if (monday) var beverage = &quot;espresso&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We <em>could</em> allow the latter, but it&#x27;s confusing. What is the scope of that
<code>beverage</code> variable? Does it persist after the <code>if</code> statement? If so, what is
its value on days other than Monday? Does the variable exist at all on those
days?</p>
<p>Code like this is weird, so C, Java, and friends all disallow it. It&#x27;s as if
there are two levels of <span name="brace">&quot;precedence&quot;</span> for statements.
Some places where a statement is allowed -- like inside a block or at the top
level -- allow any kind of statement, including declarations. Others allow only
the &quot;higher&quot; precedence statements that don&#x27;t declare names.</p>
<aside name="brace">
<p>In this analogy, block statements work sort of like parentheses do for
expressions. A block is itself in the &quot;higher&quot; precedence level and can be used
anywhere, like in the clauses of an <code>if</code> statement. But the statements it
<em>contains</em> can be lower precedence. You&#x27;re allowed to declare variables and
other names inside the block. The curlies let you escape back into the full
statement grammar from a place where only some statements are allowed.</p>
</aside>
<p>To accommodate the distinction, we add another rule for kinds of statements that
declare names.</p>
<div class="language-ebnf codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ebnf codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">program        → declaration* EOF ;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">declaration    → varDecl</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | statement ;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">statement      → exprStmt</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | printStmt ;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Declaration statements go under the new <code>declaration</code> rule. Right now, it&#x27;s only
variables, but later it will include functions and classes. Any place where a
declaration is allowed also allows non-declaring statements, so the
<code>declaration</code> rule falls through to <code>statement</code>. Obviously, you can declare
stuff at the top level of a script, so <code>program</code> routes to the new rule.</p>
<p>The rule for declaring a variable looks like:</p>
<div class="language-ebnf codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ebnf codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">varDecl        → &quot;var&quot; IDENTIFIER ( &quot;=&quot; expression )? &quot;;&quot; ;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Like most statements, it starts with a leading keyword. In this case, <code>var</code>.
Then an identifier token for the name of the variable being declared, followed
by an optional initializer expression. Finally, we put a bow on it with the
semicolon.</p>
<p>To access a variable, we define a new kind of primary expression.</p>
<div class="language-ebnf codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ebnf codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">primary        → &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | NUMBER | STRING</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | &quot;(&quot; expression &quot;)&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | IDENTIFIER ;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>That <code>IDENTIFIER</code> clause matches a single identifier token, which is understood
to be the name of the variable being accessed.</p>
<p>These new grammar rules get their corresponding syntax trees. Over in the AST
generator, we add a <span name="var-stmt-ast">new statement</span> node for a
variable declaration.</p>
<p>^code var-stmt-ast (1 before, 1 after)</p>
<aside name="var-stmt-ast">
<p>The generated code for the new node is in <a href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii.html#variable-statement">Appendix II</a>.</p>
</aside>
<p>It stores the name token so we know what it&#x27;s declaring, along with the
initializer expression. (If there isn&#x27;t an initializer, that field is <code>null</code>.)</p>
<p>Then we add an expression node for accessing a variable.</p>
<p>^code var-expr (1 before, 1 after)</p>
<p><span name="var-expr-ast">It&#x27;s</span> simply a wrapper around the token for the
variable name. That&#x27;s it. As always, don&#x27;t forget to run the AST generator
script so that you get updated &quot;Expr.java&quot; and &quot;Stmt.java&quot; files.</p>
<aside name="var-expr-ast">
<p>The generated code for the new node is in <a href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii.html#variable-expression">Appendix II</a>.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parsing-variables">Parsing variables<a href="#parsing-variables" class="hash-link" aria-label="Parsing variables的直接链接" title="Parsing variables的直接链接">​</a></h3>
<p>Before we parse variable statements, we need to shift around some code to make
room for the new <code>declaration</code> rule in the grammar. The top level of a program
is now a list of declarations, so the entrypoint method to the parser changes.</p>
<p>^code parse-declaration (3 before, 4 after)</p>
<p>That calls this new method:</p>
<p>^code declaration</p>
<p>Hey, do you remember way back in that <a href="/docs/Craftinginterpreters/not-translated-yet/parsing-expressions.html">earlier chapter</a> when we put the
infrastructure in place to do error recovery? We are finally ready to hook that
up.</p>
<p>This <code>declaration()</code> method is the method we call repeatedly when parsing a
series of statements in a block or a script, so it&#x27;s the right place to
synchronize when the parser goes into panic mode. The whole body of this method
is wrapped in a try block to catch the exception thrown when the parser begins
error recovery. This gets it back to trying to parse the beginning of the next
statement or declaration.</p>
<p>The real parsing happens inside the try block. First, it looks to see if we&#x27;re
at a variable declaration by looking for the leading <code>var</code> keyword. If not, it
falls through to the existing <code>statement()</code> method that parses <code>print</code> and
expression statements.</p>
<p>Remember how <code>statement()</code> tries to parse an expression statement if no other
statement matches? And <code>expression()</code> reports a syntax error if it can&#x27;t parse
an expression at the current token? That chain of calls ensures we report an
error if a valid declaration or statement isn&#x27;t parsed.</p>
<p>When the parser matches a <code>var</code> token, it branches to:</p>
<p>^code parse-var-declaration</p>
<p>As always, the recursive descent code follows the grammar rule. The parser has
already matched the <code>var</code> token, so next it requires and consumes an identifier
token for the variable name.</p>
<p>Then, if it sees an <code>=</code> token, it knows there is an initializer expression and
parses it. Otherwise, it leaves the initializer <code>null</code>. Finally, it consumes the
required semicolon at the end of the statement. All this gets wrapped in a
Stmt.Var syntax tree node and we&#x27;re groovy.</p>
<p>Parsing a variable expression is even easier. In <code>primary()</code>, we look for an
identifier token.</p>
<p>^code parse-identifier (2 before, 2 after)</p>
<p>That gives us a working front end for declaring and using variables. All that&#x27;s
left is to feed it into the interpreter. Before we get to that, we need to talk
about where variables live in memory.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="environments">Environments<a href="#environments" class="hash-link" aria-label="Environments的直接链接" title="Environments的直接链接">​</a></h2>
<p>The bindings that associate variables to values need to be stored somewhere.
Ever since the Lisp folks invented parentheses, this data structure has been
called an <span name="env"><strong>environment</strong></span>.</p>
<img decoding="async" loading="lazy" src="image/statements-and-state/environment.png" alt="An environment containing two bindings." class="img_ev3q">
<aside name="env">
<p>I like to imagine the environment literally, as a sylvan wonderland where
variables and values frolic.</p>
</aside>
<p>You can think of it like a <span name="map">map</span> where the keys are
variable names and the values are the variable&#x27;s, uh, values. In fact, that&#x27;s
how we&#x27;ll implement it in Java. We could stuff that map and the code to manage
it right into Interpreter, but since it forms a nicely delineated concept, we&#x27;ll
pull it out into its own class.</p>
<p>Start a new file and add:</p>
<aside name="map">
<p>Java calls them <strong>maps</strong> or <strong>hashmaps</strong>. Other languages call them <strong>hash
tables</strong>, <strong>dictionaries</strong> (Python and C#), <strong>hashes</strong> (Ruby and Perl),
<strong>tables</strong> (Lua), or <strong>associative arrays</strong> (PHP). Way back when, they were
known as <strong>scatter tables</strong>.</p>
</aside>
<p>^code environment-class</p>
<p>There&#x27;s a Java Map in there to store the bindings. It uses bare strings for the
keys, not tokens. A token represents a unit of code at a specific place in the
source text, but when it comes to looking up variables, all identifier tokens
with the same name should refer to the same variable (ignoring scope for now).
Using the raw string ensures all of those tokens refer to the same map key.</p>
<p>There are two operations we need to support. First, a variable definition binds
a new name to a value.</p>
<p>^code environment-define</p>
<p>Not exactly brain surgery, but we have made one interesting semantic choice.
When we add the key to the map, we don&#x27;t check to see if it&#x27;s already present.
That means that this program works:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;before&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a; // &quot;before&quot;.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;after&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a; // &quot;after&quot;.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>A variable statement doesn&#x27;t just define a <em>new</em> variable, it can also be used
to <em>re</em>define an existing variable. We could <span name="scheme">choose</span>
to make this an error instead. The user may not intend to redefine an existing
variable. (If they did mean to, they probably would have used assignment, not
<code>var</code>.) Making redefinition an error would help them find that bug.</p>
<p>However, doing so interacts poorly with the REPL. In the middle of a REPL
session, it&#x27;s nice to not have to mentally track which variables you&#x27;ve already
defined. We could allow redefinition in the REPL but not in scripts, but then
users would have to learn two sets of rules, and code copied and pasted from one
form to the other might not work.</p>
<aside name="scheme">
<p>My rule about variables and scoping is, &quot;When in doubt, do what Scheme does&quot;.
The Scheme folks have probably spent more time thinking about variable scope
than we ever will -- one of the main goals of Scheme was to introduce lexical
scoping to the world -- so it&#x27;s hard to go wrong if you follow in their
footsteps.</p>
<p>Scheme allows redefining variables at the top level.</p>
</aside>
<p>So, to keep the two modes consistent, we&#x27;ll allow it -- at least for global
variables. Once a variable exists, we need a way to look it up.</p>
<p>^code environment-get (2 before, 1 after)</p>
<p>This is a little more semantically interesting. If the variable is found, it
simply returns the value bound to it. But what if it&#x27;s not? Again, we have a
choice:</p>
<ul>
<li>
<p>Make it a syntax error.</p>
</li>
<li>
<p>Make it a runtime error.</p>
</li>
<li>
<p>Allow it and return some default value like <code>nil</code>.</p>
</li>
</ul>
<p>Lox is pretty lax, but the last option is a little <em>too</em> permissive to me.
Making it a syntax error -- a compile-time error -- seems like a smart choice.
Using an undefined variable is a bug, and the sooner you detect the mistake, the
better.</p>
<p>The problem is that <em>using</em> a variable isn&#x27;t the same as <em>referring</em> to it. You
can refer to a variable in a chunk of code without immediately evaluating it if
that chunk of code is wrapped inside a function. If we make it a static error to
<em>mention</em> a variable before it&#x27;s been declared, it becomes much harder to define
recursive functions.</p>
<p>We could accommodate single recursion -- a function that calls itself -- by
declaring the function&#x27;s own name before we examine its body. But that doesn&#x27;t
help with mutually recursive procedures that call each other. Consider:</p>
<p><span name="contrived"></span></p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun isOdd(n) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (n == 0) return false;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return isEven(n - 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun isEven(n) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (n == 0) return true;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return isOdd(n - 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<aside name="contrived">
<p>Granted, this is probably not the most efficient way to tell if a number is even
or odd (not to mention the bad things that happen if you pass a non-integer or
negative number to them). Bear with me.</p>
</aside>
<p>The <code>isEven()</code> function isn&#x27;t defined by the <span name="declare">time</span> we
are looking at the body of <code>isOdd()</code> where it&#x27;s called. If we swap the order of
the two functions, then <code>isOdd()</code> isn&#x27;t defined when we&#x27;re looking at
<code>isEven()</code>&#x27;s body.</p>
<aside name="declare">
<p>Some statically typed languages like Java and C# solve this by specifying that
the top level of a program isn&#x27;t a sequence of imperative statements. Instead, a
program is a set of declarations which all come into being simultaneously. The
implementation declares <em>all</em> of the names before looking at the bodies of <em>any</em>
of the functions.</p>
<p>Older languages like C and Pascal don&#x27;t work like this. Instead, they force you
to add explicit <em>forward declarations</em> to declare a name before it&#x27;s fully
defined. That was a concession to the limited computing power at the time. They
wanted to be able to compile a source file in one single pass through the text,
so those compilers couldn&#x27;t gather up all of the declarations first before
processing function bodies.</p>
</aside>
<p>Since making it a <em>static</em> error makes recursive declarations too difficult,
we&#x27;ll defer the error to runtime. It&#x27;s OK to refer to a variable before it&#x27;s
defined as long as you don&#x27;t <em>evaluate</em> the reference. That lets the program
for even and odd numbers work, but you&#x27;d get a runtime error in:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;too late!&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>As with type errors in the expression evaluation code, we report a runtime error
by throwing an exception. The exception contains the variable&#x27;s token so we can
tell the user where in their code they messed up.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="interpreting-global-variables">Interpreting global variables<a href="#interpreting-global-variables" class="hash-link" aria-label="Interpreting global variables的直接链接" title="Interpreting global variables的直接链接">​</a></h3>
<p>The Interpreter class gets an instance of the new Environment class.</p>
<p>^code environment-field (2 before, 1 after)</p>
<p>We store it as a field directly in Interpreter so that the variables stay in
memory as long as the interpreter is still running.</p>
<p>We have two new syntax trees, so that&#x27;s two new visit methods. The first is for
declaration statements.</p>
<p>^code visit-var</p>
<p>If the variable has an initializer, we evaluate it. If not, we have another
choice to make. We could have made this a syntax error in the parser by
<em>requiring</em> an initializer. Most languages don&#x27;t, though, so it feels a little
harsh to do so in Lox.</p>
<p>We could make it a runtime error. We&#x27;d let you define an uninitialized variable,
but if you accessed it before assigning to it, a runtime error would occur. It&#x27;s
not a bad idea, but most dynamically typed languages don&#x27;t do that. Instead,
we&#x27;ll keep it simple and say that Lox sets a variable to <code>nil</code> if it isn&#x27;t
explicitly initialized.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a; // &quot;nil&quot;.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Thus, if there isn&#x27;t an initializer, we set the value to <code>null</code>, which is the
Java representation of Lox&#x27;s <code>nil</code> value. Then we tell the environment to bind
the variable to that value.</p>
<p>Next, we evaluate a variable expression.</p>
<p>^code visit-variable</p>
<p>This simply forwards to the environment which does the heavy lifting to make
sure the variable is defined. With that, we&#x27;ve got rudimentary variables
working. Try this out:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var b = 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a + b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We can&#x27;t reuse <em>code</em> yet, but we can start to build up programs that reuse
<em>data</em>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="assignment">Assignment<a href="#assignment" class="hash-link" aria-label="Assignment的直接链接" title="Assignment的直接链接">​</a></h2>
<p>It&#x27;s possible to create a language that has variables but does not let you
reassign -- or <strong>mutate</strong> -- them. Haskell is one example. SML supports only
mutable references and arrays -- variables cannot be reassigned. Rust steers you
away from mutation by requiring a <code>mut</code> modifier to enable assignment.</p>
<p>Mutating a variable is a side effect and, as the name suggests, some language
folks think side effects are <span name="pure">dirty</span> or inelegant. Code
should be pure math that produces values -- crystalline, unchanging ones -- like
an act of divine creation. Not some grubby automaton that beats blobs of data
into shape, one imperative grunt at a time.</p>
<aside name="pure">
<p>I find it delightful that the same group of people who pride themselves on
dispassionate logic are also the ones who can&#x27;t resist emotionally loaded terms
for their work: &quot;pure&quot;, &quot;side effect&quot;, &quot;lazy&quot;, &quot;persistent&quot;, &quot;first-class&quot;,
&quot;higher-order&quot;.</p>
</aside>
<p>Lox is not so austere. Lox is an imperative language, and mutation comes with
the territory. Adding support for assignment doesn&#x27;t require much work. Global
variables already support redefinition, so most of the machinery is there now.
Mainly, we&#x27;re missing an explicit assignment notation.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="assignment-syntax">Assignment syntax<a href="#assignment-syntax" class="hash-link" aria-label="Assignment syntax的直接链接" title="Assignment syntax的直接链接">​</a></h3>
<p>That little <code>=</code> syntax is more complex than it might seem. Like most C-derived
languages, assignment is an <span name="assign">expression</span> and not a
statement. As in C, it is the lowest precedence expression form. That means the
rule slots between <code>expression</code> and <code>equality</code> (the next lowest precedence
expression).</p>
<aside name="assign">
<p>In some other languages, like Pascal, Python, and Go, assignment is a statement.</p>
</aside>
<div class="language-ebnf codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ebnf codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">expression     → assignment ;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">assignment     → IDENTIFIER &quot;=&quot; assignment</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | equality ;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>This says an <code>assignment</code> is either an identifier followed by an <code>=</code> and an
expression for the value, or an <code>equality</code> (and thus any other) expression.
Later, <code>assignment</code> will get more complex when we add property setters on
objects, like:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">instance.field = &quot;value&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The easy part is adding the <span name="assign-ast">new syntax tree node</span>.</p>
<p>^code assign-expr (1 before, 1 after)</p>
<aside name="assign-ast">
<p>The generated code for the new node is in <a href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii.html#assign-expression">Appendix II</a>.</p>
</aside>
<p>It has a token for the variable being assigned to, and an expression for the new
value. After you run the AstGenerator to get the new Expr.Assign class, swap out
the body of the parser&#x27;s existing <code>expression()</code> method to match the updated
rule.</p>
<p>^code expression (1 before, 1 after)</p>
<p>Here is where it gets tricky. A single token lookahead recursive descent parser
can&#x27;t see far enough to tell that it&#x27;s parsing an assignment until <em>after</em> it
has gone through the left-hand side and stumbled onto the <code>=</code>. You might wonder
why it even needs to. After all, we don&#x27;t know we&#x27;re parsing a <code>+</code> expression
until after we&#x27;ve finished parsing the left operand.</p>
<p>The difference is that the left-hand side of an assignment isn&#x27;t an expression
that evaluates to a value. It&#x27;s a sort of pseudo-expression that evaluates to a
&quot;thing&quot; you can assign to. Consider:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;before&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">a = &quot;value&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>On the second line, we don&#x27;t <em>evaluate</em> <code>a</code> (which would return the string
&quot;before&quot;). We figure out what variable <code>a</code> refers to so we know where to store
the right-hand side expression&#x27;s value. The <a href="https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue" target="_blank" rel="noopener noreferrer">classic terms</a> for these
two <span name="l-value">constructs</span> are <strong>l-value</strong> and <strong>r-value</strong>. All
of the expressions that we&#x27;ve seen so far that produce values are r-values. An
l-value &quot;evaluates&quot; to a storage location that you can assign into.</p>
<aside name="l-value">
<p>In fact, the names come from assignment expressions: <em>l</em>-values appear on the
<em>left</em> side of the <code>=</code> in an assignment, and <em>r</em>-values on the <em>right</em>.</p>
</aside>
<p>We want the syntax tree to reflect that an l-value isn&#x27;t evaluated like a normal
expression. That&#x27;s why the Expr.Assign node has a <em>Token</em> for the left-hand
side, not an Expr. The problem is that the parser doesn&#x27;t know it&#x27;s parsing an
l-value until it hits the <code>=</code>. In a complex l-value, that may occur <span name="many">many</span> tokens later.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">makeList().head.next = node;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<aside name="many">
<p>Since the receiver of a field assignment can be any expression, and expressions
can be as long as you want to make them, it may take an <em>unbounded</em> number of
tokens of lookahead to find the <code>=</code>.</p>
</aside>
<p>We have only a single token of lookahead, so what do we do? We use a little
trick, and it looks like this:</p>
<p>^code parse-assignment</p>
<p>Most of the code for parsing an assignment expression looks similar to that of
the other binary operators like <code>+</code>. We parse the left-hand side, which can be
any expression of higher precedence. If we find an <code>=</code>, we parse the right-hand
side and then wrap it all up in an assignment expression tree node.</p>
<aside name="no-throw">
<p>We <em>report</em> an error if the left-hand side isn&#x27;t a valid assignment target, but
we don&#x27;t <em>throw</em> it because the parser isn&#x27;t in a confused state where we need
to go into panic mode and synchronize.</p>
</aside>
<p>One slight difference from binary operators is that we don&#x27;t loop to build up a
sequence of the same operator. Since assignment is right-associative, we instead
recursively call <code>assignment()</code> to parse the right-hand side.</p>
<p>The trick is that right before we create the assignment expression node, we look
at the left-hand side expression and figure out what kind of assignment target
it is. We convert the r-value expression node into an l-value representation.</p>
<p>This conversion works because it turns out that every valid assignment target
happens to also be <span name="converse">valid syntax</span> as a normal
expression. Consider a complex field assignment like:</p>
<aside name="converse">
<p>You can still use this trick even if there are assignment targets that are not
valid expressions. Define a <strong>cover grammar</strong>, a looser grammar that accepts
all of the valid expression <em>and</em> assignment target syntaxes. When you hit
an <code>=</code>, report an error if the left-hand side isn&#x27;t within the valid assignment
target grammar. Conversely, if you <em>don&#x27;t</em> hit an <code>=</code>, report an error if the
left-hand side isn&#x27;t a valid <em>expression</em>.</p>
</aside>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">newPoint(x + 2, 0).y = 3;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The left-hand side of that assignment could also work as a valid expression.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">newPoint(x + 2, 0).y;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The first example sets the field, the second gets it.</p>
<p>This means we can parse the left-hand side <em>as if it were</em> an expression and
then after the fact produce a syntax tree that turns it into an assignment
target. If the left-hand side expression isn&#x27;t a <span name="paren">valid</span>
assignment target, we fail with a syntax error. That ensures we report an error
on code like this:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">a + b = c;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<aside name="paren">
<p>Way back in the parsing chapter, I said we represent parenthesized expressions
in the syntax tree because we&#x27;ll need them later. This is why. We need to be
able to distinguish these cases:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">a = 3;   // OK.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">(a) = 3; // Error.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</aside>
<p>Right now, the only valid target is a simple variable expression, but we&#x27;ll add
fields later. The end result of this trick is an assignment expression tree node
that knows what it is assigning to and has an expression subtree for the value
being assigned. All with only a single token of lookahead and no backtracking.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="assignment-semantics">Assignment semantics<a href="#assignment-semantics" class="hash-link" aria-label="Assignment semantics的直接链接" title="Assignment semantics的直接链接">​</a></h3>
<p>We have a new syntax tree node, so our interpreter gets a new visit method.</p>
<p>^code visit-assign</p>
<p>For obvious reasons, it&#x27;s similar to variable declaration. It evaluates the
right-hand side to get the value, then stores it in the named variable. Instead
of using <code>define()</code> on Environment, it calls this new method:</p>
<p>^code environment-assign</p>
<p>The key difference between assignment and definition is that assignment is not
<span name="new">allowed</span> to create a <em>new</em> variable. In terms of our
implementation, that means it&#x27;s a runtime error if the key doesn&#x27;t already exist
in the environment&#x27;s variable map.</p>
<aside name="new">
<p>Unlike Python and Ruby, Lox doesn&#x27;t do <a href="#design-note">implicit variable declaration</a>.</p>
</aside>
<p>The last thing the <code>visit()</code> method does is return the assigned value. That&#x27;s
because assignment is an expression that can be nested inside other expressions,
like so:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a = 2; // &quot;2&quot;.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Our interpreter can now create, read, and modify variables. It&#x27;s about as
sophisticated as early <span name="basic">BASICs</span>. Global variables are
simple, but writing a large program when any two chunks of code can accidentally
step on each other&#x27;s state is no fun. We want <em>local</em> variables, which means
it&#x27;s time for <em>scope</em>.</p>
<aside name="basic">
<p>Maybe a little better than that. Unlike some old BASICs, Lox can handle variable
names longer than two characters.</p>
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="scope">Scope<a href="#scope" class="hash-link" aria-label="Scope的直接链接" title="Scope的直接链接">​</a></h2>
<p>A <strong>scope</strong> defines a region where a name maps to a certain entity. Multiple
scopes enable the same name to refer to different things in different contexts.
In my house, &quot;Bob&quot; usually refers to me. But maybe in your town you know a
different Bob. Same name, but different dudes based on where you say it.</p>
<p><span name="lexical"><strong>Lexical scope</strong></span> (or the less commonly heard
<strong>static scope</strong>) is a specific style of scoping where the text of the program
itself shows where a scope begins and ends. In Lox, as in most modern languages,
variables are lexically scoped. When you see an expression that uses some
variable, you can figure out which variable declaration it refers to just by
statically reading the code.</p>
<aside name="lexical">
<p>&quot;Lexical&quot; comes from the Greek &quot;lexikos&quot; which means &quot;related to words&quot;. When we
use it in programming languages, it usually means a thing you can figure out
from source code itself without having to execute anything.</p>
<p>Lexical scope came onto the scene with ALGOL. Earlier languages were often
dynamically scoped. Computer scientists back then believed dynamic scope was
faster to execute. Today, thanks to early Scheme hackers, we know that isn&#x27;t
true. If anything, it&#x27;s the opposite.</p>
<p>Dynamic scope for variables lives on in some corners. Emacs Lisp defaults to
dynamic scope for variables. The <a href="http://clojuredocs.org/clojure.core/binding" target="_blank" rel="noopener noreferrer"><code>binding</code></a> macro in Clojure provides
it. The widely disliked <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noopener noreferrer"><code>with</code> statement</a> in JavaScript turns properties
on an object into dynamically scoped variables.</p>
</aside>
<p>For example:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;first&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print a; // &quot;first&quot;.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;second&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print a; // &quot;second&quot;.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Here, we have two blocks with a variable <code>a</code> declared in each of them. You and
I can tell just from looking at the code that the use of <code>a</code> in the first
<code>print</code> statement refers to the first <code>a</code>, and the second one refers to the
second.</p>
<img decoding="async" loading="lazy" src="image/statements-and-state/blocks.png" alt="An environment for each &#x27;a&#x27;." class="img_ev3q">
<p>This is in contrast to <strong>dynamic scope</strong> where you don&#x27;t know what a name refers
to until you execute the code. Lox doesn&#x27;t have dynamically scoped <em>variables</em>,
but methods and fields on objects are dynamically scoped.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Saxophone {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  play() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print &quot;Careless Whisper&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class GolfClub {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  play() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print &quot;Fore!&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun playIt(thing) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  thing.play();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>When <code>playIt()</code> calls <code>thing.play()</code>, we don&#x27;t know if we&#x27;re about to hear
&quot;Careless Whisper&quot; or &quot;Fore!&quot; It depends on whether you pass a Saxophone or a
GolfClub to the function, and we don&#x27;t know that until runtime.</p>
<p>Scope and environments are close cousins. The former is the theoretical concept,
and the latter is the machinery that implements it. As our interpreter works its
way through code, syntax tree nodes that affect scope will change the
environment. In a C-ish syntax like Lox&#x27;s, scope is controlled by curly-braced
blocks. (That&#x27;s why we call it <strong>block scope</strong>.)</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;in block&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a; // Error! No more &quot;a&quot;.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The beginning of a block introduces a new local scope, and that scope ends when
execution passes the closing <code>}</code>. Any variables declared inside the block
disappear.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nesting-and-shadowing">Nesting and shadowing<a href="#nesting-and-shadowing" class="hash-link" aria-label="Nesting and shadowing的直接链接" title="Nesting and shadowing的直接链接">​</a></h3>
<p>A first cut at implementing block scope might work like this:</p>
<ol>
<li>
<p>As we visit each statement inside the block, keep track of any variables
declared.</p>
</li>
<li>
<p>After the last statement is executed, tell the environment to delete all of
those variables.</p>
</li>
</ol>
<p>That would work for the previous example. But remember, one motivation for
local scope is encapsulation -- a block of code in one corner of the program
shouldn&#x27;t interfere with some other block. Check this out:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// How loud?</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var volume = 11;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// Silence.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">volume = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// Calculate size of 3x4x5 cuboid.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var volume = 3 * 4 * 5;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print volume;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Look at the block where we calculate the volume of the cuboid using a local
declaration of <code>volume</code>. After the block exits, the interpreter will delete the
<em>global</em> <code>volume</code> variable. That ain&#x27;t right. When we exit the block, we should
remove any variables declared inside the block, but if there is a variable with
the same name declared outside of the block, <em>that&#x27;s a different variable</em>. It
shouldn&#x27;t get touched.</p>
<p>When a local variable has the same name as a variable in an enclosing scope, it
<strong>shadows</strong> the outer one. Code inside the block can&#x27;t see it any more -- it is
hidden in the &quot;shadow&quot; cast by the inner one -- but it&#x27;s still there.</p>
<p>When we enter a new block scope, we need to preserve variables defined in outer
scopes so they are still around when we exit the inner block. We do that by
defining a fresh environment for each block containing only the variables
defined in that scope. When we exit the block, we discard its environment and
restore the previous one.</p>
<p>We also need to handle enclosing variables that are <em>not</em> shadowed.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var global = &quot;outside&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var local = &quot;inside&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print global + local;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Here, <code>global</code> lives in the outer global environment and <code>local</code> is defined
inside the block&#x27;s environment. In that <code>print</code> statement, both of those
variables are in scope. In order to find them, the interpreter must search not
only the current innermost environment, but also any enclosing ones.</p>
<p>We implement this by <span name="cactus">chaining</span> the environments
together. Each environment has a reference to the environment of the immediately
enclosing scope. When we look up a variable, we walk that chain from innermost
out until we find the variable. Starting at the inner scope is how we make local
variables shadow outer ones.</p>
<img decoding="async" loading="lazy" src="image/statements-and-state/chaining.png" alt="Environments for each scope, linked together." class="img_ev3q">
<aside name="cactus">
<p>While the interpreter is running, the environments form a linear list of
objects, but consider the full set of environments created during the entire
execution. An outer scope may have multiple blocks nested within it, and each
will point to the outer one, giving a tree-like structure, though only one path
through the tree exists at a time.</p>
<p>The boring name for this is a <a href="https://en.wikipedia.org/wiki/Parent_pointer_tree" target="_blank" rel="noopener noreferrer"><strong>parent-pointer tree</strong></a>, but I
much prefer the evocative <strong>cactus stack</strong>.</p>
<img decoding="async" loading="lazy" class="above img_ev3q" src="image/statements-and-state/cactus.png" alt="Each branch points to its parent. The root is global scope.">
</aside>
<p>Before we add block syntax to the grammar, we&#x27;ll beef up our Environment class
with support for this nesting. First, we give each environment a reference to
its enclosing one.</p>
<p>^code enclosing-field (1 before, 1 after)</p>
<p>This field needs to be initialized, so we add a couple of constructors.</p>
<p>^code environment-constructors</p>
<p>The no-argument constructor is for the global scope&#x27;s environment, which ends
the chain. The other constructor creates a new local scope nested inside the
given outer one.</p>
<p>We don&#x27;t have to touch the <code>define()</code> method -- a new variable is always
declared in the current innermost scope. But variable lookup and assignment work
with existing variables and they need to walk the chain to find them. First,
lookup:</p>
<p>^code environment-get-enclosing (2 before, 3 after)</p>
<p>If the variable isn&#x27;t found in this environment, we simply try the enclosing
one. That in turn does the same thing <span name="recurse">recursively</span>,
so this will ultimately walk the entire chain. If we reach an environment with
no enclosing one and still don&#x27;t find the variable, then we give up and report
an error as before.</p>
<p>Assignment works the same way.</p>
<aside name="recurse">
<p>It&#x27;s likely faster to iteratively walk the chain, but I think the recursive
solution is prettier. We&#x27;ll do something <em>much</em> faster in clox.</p>
</aside>
<p>^code environment-assign-enclosing (4 before, 1 after)</p>
<p>Again, if the variable isn&#x27;t in this environment, it checks the outer one,
recursively.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="block-syntax-and-semantics">Block syntax and semantics<a href="#block-syntax-and-semantics" class="hash-link" aria-label="Block syntax and semantics的直接链接" title="Block syntax and semantics的直接链接">​</a></h3>
<p>Now that Environments nest, we&#x27;re ready to add blocks to the language. Behold
the grammar:</p>
<div class="language-ebnf codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ebnf codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">statement      → exprStmt</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | printStmt</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">               | block ;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">block          → &quot;{&quot; declaration* &quot;}&quot; ;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>A block is a (possibly empty) series of statements or declarations surrounded by
curly braces. A block is itself a statement and can appear anywhere a statement
is allowed. The <span name="block-ast">syntax tree</span> node looks like this:</p>
<p>^code block-ast (1 before, 1 after)</p>
<aside name="block-ast">
<p>The generated code for the new node is in <a href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii.html#block-statement">Appendix II</a>.</p>
</aside>
<p><span name="generate">It</span> contains the list of statements that are inside
the block. Parsing is straightforward. Like other statements, we detect the
beginning of a block by its leading token -- in this case the <code>{</code>. In the
<code>statement()</code> method, we add:</p>
<aside name="generate">
<p>As always, don&#x27;t forget to run &quot;GenerateAst.java&quot;.</p>
</aside>
<p>^code parse-block (1 before, 2 after)</p>
<p>All the real work happens here:</p>
<p>^code block</p>
<p>We <span name="list">create</span> an empty list and then parse statements and
add them to the list until we reach the end of the block, marked by the closing
<code>}</code>. Note that the loop also has an explicit check for <code>isAtEnd()</code>. We have to
be careful to avoid infinite loops, even when parsing invalid code. If the user
forgets a closing <code>}</code>, the parser needs to not get stuck.</p>
<aside name="list">
<p>Having <code>block()</code> return the raw list of statements and leaving it to
<code>statement()</code> to wrap the list in a Stmt.Block looks a little odd. I did it that
way because we&#x27;ll reuse <code>block()</code> later for parsing function bodies and we don&#x27;t
want that body wrapped in a Stmt.Block.</p>
</aside>
<p>That&#x27;s it for syntax. For semantics, we add another visit method to Interpreter.</p>
<p>^code visit-block</p>
<p>To execute a block, we create a new environment for the block&#x27;s scope and pass
it off to this other method:</p>
<p>^code execute-block</p>
<p>This new method executes a list of statements in the context of a given <span name="param">environment</span>. Up until now, the <code>environment</code> field in
Interpreter always pointed to the same environment -- the global one. Now, that
field represents the <em>current</em> environment. That&#x27;s the environment that
corresponds to the innermost scope containing the code to be executed.</p>
<p>To execute code within a given scope, this method updates the interpreter&#x27;s
<code>environment</code> field, visits all of the statements, and then restores the
previous value. As is always good practice in Java, it restores the previous
environment using a finally clause. That way it gets restored even if an
exception is thrown.</p>
<aside name="param">
<p>Manually changing and restoring a mutable <code>environment</code> field feels inelegant.
Another classic approach is to explicitly pass the environment as a parameter to
each visit method. To &quot;change&quot; the environment, you pass a different one as you
recurse down the tree. You don&#x27;t have to restore the old one, since the new one
lives on the Java stack and is implicitly discarded when the interpreter returns
from the block&#x27;s visit method.</p>
<p>I considered that for jlox, but it&#x27;s kind of tedious and verbose adding an
environment parameter to every single visit method. To keep the book a little
simpler, I went with the mutable field.</p>
</aside>
<p>Surprisingly, that&#x27;s all we need to do in order to fully support local
variables, nesting, and shadowing. Go ahead and try this out:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;global a&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var b = &quot;global b&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var c = &quot;global c&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;outer a&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var b = &quot;outer b&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var a = &quot;inner a&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print b;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print c;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print b;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print c;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print b;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print c;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Our little interpreter can remember things now. We are inching closer to
something resembling a full-featured programming language.</p>
<div class="challenges">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h2>
<ol>
<li>
<p>The REPL no longer supports entering a single expression and automatically
printing its result value. That&#x27;s a drag. Add support to the REPL to let
users type in both statements and expressions. If they enter a statement,
execute it. If they enter an expression, evaluate it and display the result
value.</p>
</li>
<li>
<p>Maybe you want Lox to be a little more explicit about variable
initialization. Instead of implicitly initializing variables to <code>nil</code>, make
it a runtime error to access a variable that has not been initialized or
assigned to, as in:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// No initializers.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var b;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">a = &quot;assigned&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a; // OK, was assigned first.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print b; // Error!</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>What does the following program do?</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = a + 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>What did you <em>expect</em> it to do? Is it what you think it should do? What
does analogous code in other languages you are familiar with do? What do
you think users will expect this to do?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="design-note-implicit-variable-declaration">Design Note: Implicit Variable Declaration<a href="#design-note-implicit-variable-declaration" class="hash-link" aria-label="Design Note: Implicit Variable Declaration的直接链接" title="Design Note: Implicit Variable Declaration的直接链接">​</a></h2>
<p>Lox has distinct syntax for declaring a new variable and assigning to an
existing one. Some languages collapse those to only assignment syntax. Assigning
to a non-existent variable automatically brings it into being. This is called
<strong>implicit variable declaration</strong> and exists in Python, Ruby, and CoffeeScript,
among others. JavaScript has an explicit syntax to declare variables, but can
also create new variables on assignment. Visual Basic has <a href="https://msdn.microsoft.com/en-us/library/xe53dz5w(v=vs.100).aspx" target="_blank" rel="noopener noreferrer">an option to enable
or disable implicit variables</a>.</p>
<p>When the same syntax can assign or create a variable, each language must decide
what happens when it isn&#x27;t clear about which behavior the user intends. In
particular, each language must choose how implicit declaration interacts with
shadowing, and which scope an implicitly declared variable goes into.</p>
<ul>
<li>
<p>In Python, assignment always creates a variable in the current function&#x27;s
scope, even if there is a variable with the same name declared outside of
the function.</p>
</li>
<li>
<p>Ruby avoids some ambiguity by having different naming rules for local and
global variables. However, blocks in Ruby (which are more like closures than
like &quot;blocks&quot; in C) have their own scope, so it still has the problem.
Assignment in Ruby assigns to an existing variable outside of the current
block if there is one with the same name. Otherwise, it creates a new
variable in the current block&#x27;s scope.</p>
</li>
<li>
<p>CoffeeScript, which takes after Ruby in many ways, is similar. It explicitly
disallows shadowing by saying that assignment always assigns to a variable
in an outer scope if there is one, all the way up to the outermost global
scope. Otherwise, it creates the variable in the current function scope.</p>
</li>
<li>
<p>In JavaScript, assignment modifies an existing variable in any enclosing
scope, if found. If not, it implicitly creates a new variable in the
<em>global</em> scope.</p>
</li>
</ul>
<p>The main advantage to implicit declaration is simplicity. There&#x27;s less syntax
and no &quot;declaration&quot; concept to learn. Users can just start assigning stuff and
the language figures it out.</p>
<p>Older, statically typed languages like C benefit from explicit declaration
because they give the user a place to tell the compiler what type each variable
has and how much storage to allocate for it. In a dynamically typed,
garbage-collected language, that isn&#x27;t really necessary, so you can get away
with making declarations implicit. It feels a little more &quot;scripty&quot;, more &quot;you
know what I mean&quot;.</p>
<p>But is that a good idea? Implicit declaration has some problems.</p>
<ul>
<li>
<p>A user may intend to assign to an existing variable, but may have misspelled
it. The interpreter doesn&#x27;t know that, so it goes ahead and silently creates
some new variable and the variable the user wanted to assign to still has
its old value. This is particularly heinous in JavaScript where a typo will
create a <em>global</em> variable, which may in turn interfere with other code.</p>
</li>
<li>
<p>JS, Ruby, and CoffeeScript use the presence of an existing variable with the
same name -- even in an outer scope -- to determine whether or not an
assignment creates a new variable or assigns to an existing one. That means
adding a new variable in a surrounding scope can change the meaning of
existing code. What was once a local variable may silently turn into an
assignment to that new outer variable.</p>
</li>
<li>
<p>In Python, you may <em>want</em> to assign to some variable outside of the current
function instead of creating a new variable in the current one, but you
can&#x27;t.</p>
</li>
</ul>
<p>Over time, the languages I know with implicit variable declaration ended up
adding more features and complexity to deal with these problems.</p>
<ul>
<li>
<p>Implicit declaration of global variables in JavaScript is universally
considered a mistake today. &quot;Strict mode&quot; disables it and makes it a compile
error.</p>
</li>
<li>
<p>Python added a <code>global</code> statement to let you explicitly assign to a global
variable from within a function. Later, as functional programming and nested
functions became more popular, they added a similar <code>nonlocal</code> statement to
assign to variables in enclosing functions.</p>
</li>
<li>
<p>Ruby extended its block syntax to allow declaring certain variables to be
explicitly local to the block even if the same name exists in an outer
scope.</p>
</li>
</ul>
<p>Given those, I think the simplicity argument is mostly lost. There is an
argument that implicit declaration is the right <em>default</em> but I personally find
that less compelling.</p>
<p>My opinion is that implicit declaration made sense in years past when most
scripting languages were heavily imperative and code was pretty flat. As
programmers have gotten more comfortable with deep nesting, functional
programming, and closures, it&#x27;s become much more common to want access to
variables in outer scopes. That makes it more likely that users will run into
the tricky cases where it&#x27;s not clear whether they intend their assignment to
create a new variable or reuse a surrounding one.</p>
<p>So I prefer explicitly declaring variables, which is why Lox requires it.</p>
</div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/statements-and-state.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Craftinginterpreters/not-translated-yet/scanning"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">scanning</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Craftinginterpreters/not-translated-yet/strings"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">strings</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#statements" class="table-of-contents__link toc-highlight">Statements</a><ul><li><a href="#statement-syntax-trees" class="table-of-contents__link toc-highlight">Statement syntax trees</a></li><li><a href="#parsing-statements" class="table-of-contents__link toc-highlight">Parsing statements</a></li><li><a href="#executing-statements" class="table-of-contents__link toc-highlight">Executing statements</a></li></ul></li><li><a href="#global-variables" class="table-of-contents__link toc-highlight">Global Variables</a><ul><li><a href="#variable-syntax" class="table-of-contents__link toc-highlight">Variable syntax</a></li><li><a href="#parsing-variables" class="table-of-contents__link toc-highlight">Parsing variables</a></li></ul></li><li><a href="#environments" class="table-of-contents__link toc-highlight">Environments</a><ul><li><a href="#interpreting-global-variables" class="table-of-contents__link toc-highlight">Interpreting global variables</a></li></ul></li><li><a href="#assignment" class="table-of-contents__link toc-highlight">Assignment</a><ul><li><a href="#assignment-syntax" class="table-of-contents__link toc-highlight">Assignment syntax</a></li><li><a href="#assignment-semantics" class="table-of-contents__link toc-highlight">Assignment semantics</a></li></ul></li><li><a href="#scope" class="table-of-contents__link toc-highlight">Scope</a><ul><li><a href="#nesting-and-shadowing" class="table-of-contents__link toc-highlight">Nesting and shadowing</a></li><li><a href="#block-syntax-and-semantics" class="table-of-contents__link toc-highlight">Block syntax and semantics</a></li></ul></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li><li><a href="#design-note-implicit-variable-declaration" class="table-of-contents__link toc-highlight">Design Note: Implicit Variable Declaration</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>