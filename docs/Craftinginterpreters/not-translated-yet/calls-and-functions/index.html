<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Craftinginterpreters/not-translated-yet/calls-and-functions" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">calls-and-functions | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/calls-and-functions"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="calls-and-functions | My Site"><meta data-rh="true" name="description" content="Any problem in computer science can be solved with another level of"><meta data-rh="true" property="og:description" content="Any problem in computer science can be solved with another level of"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/calls-and-functions"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/calls-and-functions" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/calls-and-functions" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0d35426a.css">
<script src="/assets/js/runtime~main.0868a236.js" defer="defer"></script>
<script src="/assets/js/main.f1c02528.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/english">English</a><button aria-label="展开侧边栏分类 &#x27;English&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/crafting-interpreter">Crafting-interpreter</a><button aria-label="折叠侧边栏分类 &#x27;Crafting-interpreter&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/welcome">Welcome</a><button aria-label="展开侧边栏分类 &#x27;Welcome&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/not-translated-yet">not-translated-yet</a><button aria-label="折叠侧边栏分类 &#x27;not-translated-yet&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-bytecode-virtual-machine">a-bytecode-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-tree-walk-interpreter">a-tree-walk-interpreter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine">a-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/acknowledgements">acknowledgements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-i">appendix-i</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii">appendix-ii</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/backmatter">backmatter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/calls-and-functions">calls-and-functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode">chunks-of-bytecode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes-and-instances">classes-and-instances</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes">classes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/closures">closures</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/compiling-expressions">compiling-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/contents">contents</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/control-flow">control-flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/dedication">dedication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions">evaluating-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/functions">functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection">garbage-collection</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/global-variables">global-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/hash-tables">hash-tables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/inheritance">inheritance</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth">jumping-back-and-forth</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/local-variables">local-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/methods-and-initializers">methods-and-initializers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/optimization">optimization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/parsing-expressions">parsing-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/representing-code">representing-code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding">resolving-and-binding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand">scanning-on-demand</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning">scanning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/statements-and-state">statements-and-state</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/strings">strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/superclasses">superclasses</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/the-lox-language">the-lox-language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/types-of-values">types-of-values</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/crafting-interpreter"><span itemprop="name">Crafting-interpreter</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/not-translated-yet"><span itemprop="name">not-translated-yet</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">calls-and-functions</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>calls-and-functions</h1></header><blockquote>
<p>Any problem in computer science can be solved with another level of
indirection. Except for the problem of too many layers of indirection.</p>
<p><cite>David Wheeler</cite></p>
</blockquote>
<p>This chapter is a beast. I try to break features into bite-sized pieces, but
sometimes you gotta swallow the whole <span name="eat">meal</span>. Our next
task is functions. We could start with only function declarations, but that&#x27;s
not very useful when you can&#x27;t call them. We could do calls, but there&#x27;s nothing
to call. And all of the runtime support needed in the VM to support both of
those isn&#x27;t very rewarding if it isn&#x27;t hooked up to anything you can see. So
we&#x27;re going to do it all. It&#x27;s a lot, but we&#x27;ll feel good when we&#x27;re done.</p>
<aside name="eat">
<p>Eating -- consumption -- is a weird metaphor for a creative act. But most of the
biological processes that produce &quot;output&quot; are a little less, ahem, decorous.</p>
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="function-objects">Function Objects<a href="#function-objects" class="hash-link" aria-label="Function Objects的直接链接" title="Function Objects的直接链接">​</a></h2>
<p>The most interesting structural change in the VM is around the stack. We already
<em>have</em> a stack for local variables and temporaries, so we&#x27;re partway there. But
we have no notion of a <em>call</em> stack. Before we can make much progress, we&#x27;ll
have to fix that. But first, let&#x27;s write some code. I always feel better once I
start moving. We can&#x27;t do much without having some kind of representation for
functions, so we&#x27;ll start there. From the VM&#x27;s perspective, what is a function?</p>
<p>A function has a body that can be executed, so that means some bytecode. We
could compile the entire program and all of its function declarations into one
big monolithic Chunk. Each function would have a pointer to the first
instruction of its code inside the Chunk.</p>
<p>This is roughly how compilation to native code works where you end up with one
solid blob of machine code. But for our bytecode VM, we can do something a
little higher level. I think a cleaner model is to give each function its own
Chunk. We&#x27;ll want some other metadata too, so let&#x27;s go ahead and stuff it all in
a struct now.</p>
<p>^code obj-function (2 before, 2 after)</p>
<p>Functions are first class in Lox, so they need to be actual Lox objects. Thus
ObjFunction has the same Obj header that all object types share. The <code>arity</code>
field stores the number of parameters the function expects. Then, in addition to
the chunk, we store the function&#x27;s <span name="name">name</span>. That will be
handy for reporting readable runtime errors.</p>
<aside name="name">
<p>Humans don&#x27;t seem to find numeric bytecode offsets particularly illuminating in
crash dumps.</p>
</aside>
<p>This is the first time the &quot;object&quot; module has needed to reference Chunk, so we
get an include.</p>
<p>^code object-include-chunk (1 before, 1 after)</p>
<p>Like we did with strings, we define some accessories to make Lox functions
easier to work with in C. Sort of a poor man&#x27;s object orientation. First, we&#x27;ll
declare a C function to create a new Lox function.</p>
<p>^code new-function-h (3 before, 1 after)</p>
<p>The implementation is over here:</p>
<p>^code new-function</p>
<p>We use our friend <code>ALLOCATE_OBJ()</code> to allocate memory and initialize the
object&#x27;s header so that the VM knows what type of object it is. Instead of
passing in arguments to initialize the function like we did with ObjString, we
set the function up in a sort of blank state -- zero arity, no name, and no
code. That will get filled in later after the function is created.</p>
<p>Since we have a new kind of object, we need a new object type in the enum.</p>
<p>^code obj-type-function (1 before, 2 after)</p>
<p>When we&#x27;re done with a function object, we must return the bits it borrowed back
to the operating system.</p>
<p>^code free-function (1 before, 1 after)</p>
<p>This switch case is <span name="free-name">responsible</span> for freeing the
ObjFunction itself as well as any other memory it owns. Functions own their
chunk, so we call Chunk&#x27;s destructor-like function.</p>
<aside name="free-name">
<p>We don&#x27;t need to explicitly free the function&#x27;s name because it&#x27;s an ObjString.
That means we can let the garbage collector manage its lifetime for us. Or, at
least, we&#x27;ll be able to once we <a href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection.html">implement a garbage collector</a>.</p>
</aside>
<p>Lox lets you print any object, and functions are first-class objects, so we
need to handle them too.</p>
<p>^code print-function (1 before, 1 after)</p>
<p>This calls out to:</p>
<p>^code print-function-helper</p>
<p>Since a function knows its name, it may as well say it.</p>
<p>Finally, we have a couple of macros for converting values to functions. First,
make sure your value actually <em>is</em> a function.</p>
<p>^code is-function (2 before, 1 after)</p>
<p>Assuming that evaluates to true, you can then safely cast the Value to an
ObjFunction pointer using this:</p>
<p>^code as-function (2 before, 1 after)</p>
<p>With that, our object model knows how to represent functions. I&#x27;m feeling warmed
up now. You ready for something a little harder?</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="compiling-to-function-objects">Compiling to Function Objects<a href="#compiling-to-function-objects" class="hash-link" aria-label="Compiling to Function Objects的直接链接" title="Compiling to Function Objects的直接链接">​</a></h2>
<p>Right now, our compiler assumes it is always compiling to one single chunk. With
each function&#x27;s code living in separate chunks, that gets more complex. When the
compiler reaches a function declaration, it needs to emit code into the
function&#x27;s chunk when compiling its body. At the end of the function body, the
compiler needs to return to the previous chunk it was working with.</p>
<p>That&#x27;s fine for code inside function bodies, but what about code that isn&#x27;t? The
&quot;top level&quot; of a Lox program is also imperative code and we need a chunk to
compile that into. We can simplify the compiler and VM by placing that top-level
code inside an automatically defined function too. That way, the compiler is
always within some kind of function body, and the VM always runs code by
invoking a function. It&#x27;s as if the entire program is <span name="wrap">wrapped</span> inside an implicit <code>main()</code> function.</p>
<aside name="wrap">
<p>One semantic corner where that analogy breaks down is global variables. They
have special scoping rules different from local variables, so in that way, the
top level of a script isn&#x27;t like a function body.</p>
</aside>
<p>Before we get to user-defined functions, then, let&#x27;s do the reorganization to
support that implicit top-level function. It starts with the Compiler struct.
Instead of pointing directly to a Chunk that the compiler writes to, it instead
has a reference to the function object being built.</p>
<p>^code function-fields (1 before, 1 after)</p>
<p>We also have a little FunctionType enum. This lets the compiler tell when it&#x27;s
compiling top-level code versus the body of a function. Most of the compiler
doesn&#x27;t care about this -- that&#x27;s why it&#x27;s a useful abstraction -- but in one or
two places the distinction is meaningful. We&#x27;ll get to one later.</p>
<p>^code function-type-enum</p>
<p>Every place in the compiler that was writing to the Chunk now needs to go
through that <code>function</code> pointer. Fortunately, many <span name="current">chapters</span> ago, we encapsulated access to the chunk in the
<code>currentChunk()</code> function. We only need to fix that and the rest of the compiler
is happy.</p>
<aside name="current">
<p>It&#x27;s almost like I had a crystal ball that could see into the future and knew
we&#x27;d need to change the code later. But, really, it&#x27;s because I wrote all the
code for the book before any of the text.</p>
</aside>
<p>^code current-chunk (1 before, 2 after)</p>
<p>The current chunk is always the chunk owned by the function we&#x27;re in the middle
of compiling. Next, we need to actually create that function. Previously, the VM
passed a Chunk to the compiler which filled it with code. Instead, the compiler
will create and return a function that contains the compiled top-level code --
which is all we support right now -- of the user&#x27;s program.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="creating-functions-at-compile-time">Creating functions at compile time<a href="#creating-functions-at-compile-time" class="hash-link" aria-label="Creating functions at compile time的直接链接" title="Creating functions at compile time的直接链接">​</a></h3>
<p>We start threading this through in <code>compile()</code>, which is the main entry point
into the compiler.</p>
<p>^code call-init-compiler (1 before, 2 after)</p>
<p>There are a bunch of changes in how the compiler is initialized. First, we
initialize the new Compiler fields.</p>
<p>^code init-compiler (1 after)</p>
<p>Then we allocate a new function object to compile into.</p>
<p>^code init-function (1 before, 1 after)</p>
<p><span name="null"></span></p>
<aside name="null">
<p>I know, it looks dumb to null the <code>function</code> field only to immediately assign it
a value a few lines later. More garbage collection-related paranoia.</p>
</aside>
<p>Creating an ObjFunction in the compiler might seem a little strange. A function
object is the <em>runtime</em> representation of a function, but here we are creating
it at compile time. The way to think of it is that a function is similar to a
string or number literal. It forms a bridge between the compile time and runtime
worlds. When we get to function <em>declarations</em>, those really <em>are</em> literals
-- they are a notation that produces values of a built-in type. So the <span name="closure">compiler</span> creates function objects during compilation.
Then, at runtime, they are simply invoked.</p>
<aside name="closure">
<p>We can create functions at compile time because they contain only data available
at compile time. The function&#x27;s code, name, and arity are all fixed. When we add
closures in the <a href="/docs/Craftinginterpreters/not-translated-yet/closures.html">next chapter</a>, which capture variables at runtime,
the story gets more complex.</p>
</aside>
<p>Here is another strange piece of code:</p>
<p>^code init-function-slot (1 before, 1 after)</p>
<p>Remember that the compiler&#x27;s <code>locals</code> array keeps track of which stack slots are
associated with which local variables or temporaries. From now on, the compiler
implicitly claims stack slot zero for the VM&#x27;s own internal use. We give it an
empty name so that the user can&#x27;t write an identifier that refers to it. I&#x27;ll
explain what this is about when it becomes useful.</p>
<p>That&#x27;s the initialization side. We also need a couple of changes on the other
end when we finish compiling some code.</p>
<p>^code end-compiler (1 after)</p>
<p>Previously, when <code>interpret()</code> called into the compiler, it passed in a Chunk to
be written to. Now that the compiler creates the function object itself, we
return that function. We grab it from the current compiler here:</p>
<p>^code end-function (1 before, 1 after)</p>
<p>And then return it to <code>compile()</code> like so:</p>
<p>^code return-function (1 before, 1 after)</p>
<p>Now is a good time to make another tweak in this function. Earlier, we added
some diagnostic code to have the VM dump the disassembled bytecode so we could
debug the compiler. We should fix that to keep working now that the generated
chunk is wrapped in a function.</p>
<p>^code disassemble-end (2 before, 2 after)</p>
<p>Notice the check in here to see if the function&#x27;s name is <code>NULL</code>? User-defined
functions have names, but the implicit function we create for the top-level code
does not, and we need to handle that gracefully even in our own diagnostic code.
Speaking of which:</p>
<p>^code print-script (1 before, 1 after)</p>
<p>There&#x27;s no way for a <em>user</em> to get a reference to the top-level function and try
to print it, but our <code>DEBUG_TRACE_EXECUTION</code> <span name="debug">diagnostic</span> code that prints the entire stack can and does.</p>
<aside name="debug">
<p>It is no fun if the diagnostic code we use to find bugs itself causes the VM to
segfault!</p>
</aside>
<p>Bumping up a level to <code>compile()</code>, we adjust its signature.</p>
<p>^code compile-h (2 before, 2 after)</p>
<p>Instead of taking a chunk, now it returns a function. Over in the
implementation:</p>
<p>^code compile-signature (1 after)</p>
<p>Finally we get to some actual code. We change the very end of the function to
this:</p>
<p>^code call-end-compiler (4 before, 1 after)</p>
<p>We get the function object from the compiler. If there were no compile errors,
we return it. Otherwise, we signal an error by returning <code>NULL</code>. This way, the
VM doesn&#x27;t try to execute a function that may contain invalid bytecode.</p>
<p>Eventually, we will update <code>interpret()</code> to handle the new declaration of
<code>compile()</code>, but first we have some other changes to make.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="call-frames">Call Frames<a href="#call-frames" class="hash-link" aria-label="Call Frames的直接链接" title="Call Frames的直接链接">​</a></h2>
<p>It&#x27;s time for a big conceptual leap. Before we can implement function
declarations and calls, we need to get the VM ready to handle them. There are
two main problems we need to worry about:</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="allocating-local-variables">Allocating local variables<a href="#allocating-local-variables" class="hash-link" aria-label="Allocating local variables的直接链接" title="Allocating local variables的直接链接">​</a></h3>
<p>The compiler allocates stack slots for local variables. How should that work
when the set of local variables in a program is distributed across multiple
functions?</p>
<p>One option would be to keep them totally separate. Each function would get its
own dedicated set of slots in the VM stack that it would own <span name="static">forever</span>, even when the function isn&#x27;t being called. Each
local variable in the entire program would have a bit of memory in the VM that
it keeps to itself.</p>
<aside name="static">
<p>It&#x27;s basically what you&#x27;d get if you declared every local variable in a C
program using <code>static</code>.</p>
</aside>
<p>Believe it or not, early programming language implementations worked this way.
The first Fortran compilers statically allocated memory for each variable. The
obvious problem is that it&#x27;s really inefficient. Most functions are not in the
middle of being called at any point in time, so sitting on unused memory for
them is wasteful.</p>
<p>The more fundamental problem, though, is recursion. With recursion, you can be
&quot;in&quot; multiple calls to the same function at the same time. Each needs its <span name="fortran">own</span> memory for its local variables. In jlox, we solved
this by dynamically allocating memory for an environment each time a function
was called or a block entered. In clox, we don&#x27;t want that kind of performance
cost on every function call.</p>
<aside name="fortran">
<p>Fortran avoided this problem by disallowing recursion entirely. Recursion was
considered an advanced, esoteric feature at the time.</p>
</aside>
<p>Instead, our solution lies somewhere between Fortran&#x27;s static allocation and
jlox&#x27;s dynamic approach. The value stack in the VM works on the observation that
local variables and temporaries behave in a last-in first-out fashion.
Fortunately for us, that&#x27;s still true even when you add function calls into the
mix. Here&#x27;s an example:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun first() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  second();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var b = 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun second() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var c = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var d = 4;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">first();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Step through the program and look at which variables are in memory at each point
in time:</p>
<img decoding="async" loading="lazy" src="image/calls-and-functions/calls.png" alt="Tracing through the execution of the previous program, showing the stack of variables at each step." class="img_ev3q">
<p>As execution flows through the two calls, every local variable obeys the
principle that any variable declared after it will be discarded before the first
variable needs to be. This is true even across calls. We know we&#x27;ll be done with
<code>c</code> and <code>d</code> before we are done with <code>a</code>. It seems we should be able to allocate
local variables on the VM&#x27;s value stack.</p>
<p>Ideally, we still determine <em>where</em> on the stack each variable will go at
compile time. That keeps the bytecode instructions for working with variables
simple and fast. In the above example, we could <span name="imagine">imagine</span> doing so in a straightforward way, but that
doesn&#x27;t always work out. Consider:</p>
<aside name="imagine">
<p>I say &quot;imagine&quot; because the compiler can&#x27;t actually figure this out. Because
functions are first class in Lox, we can&#x27;t determine which functions call which
others at compile time.</p>
</aside>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun first() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  second();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var b = 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  second();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun second() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var c = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var d = 4;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">first();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>In the first call to <code>second()</code>, <code>c</code> and <code>d</code> would go into slots 1 and 2. But in
the second call, we need to have made room for <code>b</code>, so <code>c</code> and <code>d</code> need to be in
slots 2 and 3. Thus the compiler can&#x27;t pin down an exact slot for each local
variable across function calls. But <em>within</em> a given function, the <em>relative</em>
locations of each local variable are fixed. Variable <code>d</code> is always in the slot
right after <code>c</code>. This is the key insight.</p>
<p>When a function is called, we don&#x27;t know where the top of the stack will be
because it can be called from different contexts. But, wherever that top happens
to be, we do know where all of the function&#x27;s local variables will be relative
to that starting point. So, like many problems, we solve our allocation problem
with a level of indirection.</p>
<p>At the beginning of each function call, the VM records the location of the first
slot where that function&#x27;s own locals begin. The instructions for working with
local variables access them by a slot index relative to that, instead of
relative to the bottom of the stack like they do today. At compile time, we
calculate those relative slots. At runtime, we convert that relative slot to an
absolute stack index by adding the function call&#x27;s starting slot.</p>
<p>It&#x27;s as if the function gets a &quot;window&quot; or &quot;frame&quot; within the larger stack where
it can store its locals. The position of the <strong>call frame</strong> is determined at
runtime, but within and relative to that region, we know where to find things.</p>
<img decoding="async" loading="lazy" src="image/calls-and-functions/window.png" alt="The stack at the two points when second() is called, with a window hovering over each one showing the pair of stack slots used by the function." class="img_ev3q">
<p>The historical name for this recorded location where the function&#x27;s locals start
is a <strong>frame pointer</strong> because it points to the beginning of the function&#x27;s call
frame. Sometimes you hear <strong>base pointer</strong>, because it points to the base stack
slot on top of which all of the function&#x27;s variables live.</p>
<p>That&#x27;s the first piece of data we need to track. Every time we call a function,
the VM determines the first stack slot where that function&#x27;s variables begin.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="return-addresses">Return addresses<a href="#return-addresses" class="hash-link" aria-label="Return addresses的直接链接" title="Return addresses的直接链接">​</a></h3>
<p>Right now, the VM works its way through the instruction stream by incrementing
the <code>ip</code> field. The only interesting behavior is around control flow
instructions which offset the <code>ip</code> by larger amounts. <em>Calling</em> a function is
pretty straightforward -- simply set <code>ip</code> to point to the first instruction in
that function&#x27;s chunk. But what about when the function is done?</p>
<p>The VM needs to <span name="return">return</span> back to the chunk where the
function was called from and resume execution at the instruction immediately
after the call. Thus, for each function call, we need to track where we jump
back to when the call completes. This is called a <strong>return address</strong> because
it&#x27;s the address of the instruction that the VM returns to after the call.</p>
<p>Again, thanks to recursion, there may be multiple return addresses for a single
function, so this is a property of each <em>invocation</em> and not the function
itself.</p>
<aside name="return">
<p>The authors of early Fortran compilers had a clever trick for implementing
return addresses. Since they <em>didn&#x27;t</em> support recursion, any given function
needed only a single return address at any point in time. So when a function was
called at runtime, the program would <em>modify its own code</em> to change a jump
instruction at the end of the function to jump back to its caller. Sometimes the
line between genius and madness is hair thin.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-call-stack">The call stack<a href="#the-call-stack" class="hash-link" aria-label="The call stack的直接链接" title="The call stack的直接链接">​</a></h3>
<p>So for each live function invocation -- each call that hasn&#x27;t returned yet -- we
need to track where on the stack that function&#x27;s locals begin, and where the
caller should resume. We&#x27;ll put this, along with some other stuff, in a new
struct.</p>
<p>^code call-frame (1 before, 2 after)</p>
<p>A CallFrame represents a single ongoing function call. The <code>slots</code> field points
into the VM&#x27;s value stack at the first slot that this function can use. I gave
it a plural name because -- thanks to C&#x27;s weird &quot;pointers are sort of arrays&quot;
thing -- we&#x27;ll treat it like an array.</p>
<p>The implementation of return addresses is a little different from what I
described above. Instead of storing the return address in the callee&#x27;s frame,
the caller stores its own <code>ip</code>. When we return from a function, the VM will jump
to the <code>ip</code> of the caller&#x27;s CallFrame and resume from there.</p>
<p>I also stuffed a pointer to the function being called in here. We&#x27;ll use that to
look up constants and for a few other things.</p>
<p>Each time a function is called, we create one of these structs. We could <span name="heap">dynamically</span> allocate them on the heap, but that&#x27;s slow.
Function calls are a core operation, so they need to be as fast as possible.
Fortunately, we can make the same observation we made for variables: function
calls have stack semantics. If <code>first()</code> calls <code>second()</code>, the call to
<code>second()</code> will complete before <code>first()</code> does.</p>
<aside name="heap">
<p>Many Lisp implementations dynamically allocate stack frames because it
simplifies implementing <a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="noopener noreferrer">continuations</a>. If your language supports
continuations, then function calls do <em>not</em> always have stack semantics.</p>
</aside>
<p>So over in the VM, we create an array of these CallFrame structs up front and
treat it as a stack, like we do with the value array.</p>
<p>^code frame-array (1 before, 1 after)</p>
<p>This array replaces the <code>chunk</code> and <code>ip</code> fields we used to have directly in the
VM. Now each CallFrame has its own <code>ip</code> and its own pointer to the ObjFunction
that it&#x27;s executing. From there, we can get to the function&#x27;s chunk.</p>
<p>The new <code>frameCount</code> field in the VM stores the current height of the CallFrame
stack -- the number of ongoing function calls. To keep clox simple, the array&#x27;s
capacity is fixed. This means, as in many language implementations, there is a
maximum call depth we can handle. For clox, it&#x27;s defined here:</p>
<p>^code frame-max (2 before, 2 after)</p>
<p>We also redefine the value stack&#x27;s <span name="plenty">size</span> in terms of
that to make sure we have plenty of stack slots even in very deep call trees.
When the VM starts up, the CallFrame stack is empty.</p>
<aside name="plenty">
<p>It is still possible to overflow the stack if enough function calls use enough
temporaries in addition to locals. A robust implementation would guard against
this, but I&#x27;m trying to keep things simple.</p>
</aside>
<p>^code reset-frame-count (1 before, 1 after)</p>
<p>The &quot;vm.h&quot; header needs access to ObjFunction, so we add an include.</p>
<p>^code vm-include-object (2 before, 1 after)</p>
<p>Now we&#x27;re ready to move over to the VM&#x27;s implementation file. We&#x27;ve got some
grunt work ahead of us. We&#x27;ve moved <code>ip</code> out of the VM struct and into
CallFrame. We need to fix every line of code in the VM that touches <code>ip</code> to
handle that. Also, the instructions that access local variables by stack slot
need to be updated to do so relative to the current CallFrame&#x27;s <code>slots</code> field.</p>
<p>We&#x27;ll start at the top and plow through it.</p>
<p>^code run (1 before, 1 after)</p>
<p>First, we store the current topmost CallFrame in a <span name="local">local</span> variable inside the main bytecode execution function.
Then we replace the bytecode access macros with versions that access <code>ip</code>
through that variable.</p>
<aside name="local">
<p>We could access the current frame by going through the CallFrame array every
time, but that&#x27;s verbose. More importantly, storing the frame in a local
variable encourages the C compiler to keep that pointer in a register. That
speeds up access to the frame&#x27;s <code>ip</code>. There&#x27;s no <em>guarantee</em> that the compiler
will do this, but there&#x27;s a good chance it will.</p>
</aside>
<p>Now onto each instruction that needs a little tender loving care.</p>
<p>^code push-local (2 before, 1 after)</p>
<p>Previously, <code>OP_GET_LOCAL</code> read the given local slot directly from the VM&#x27;s
stack array, which meant it indexed the slot starting from the bottom of the
stack. Now, it accesses the current frame&#x27;s <code>slots</code> array, which means it
accesses the given numbered slot relative to the beginning of that frame.</p>
<p>Setting a local variable works the same way.</p>
<p>^code set-local (2 before, 1 after)</p>
<p>The jump instructions used to modify the VM&#x27;s <code>ip</code> field. Now, they do the same
for the current frame&#x27;s <code>ip</code>.</p>
<p>^code jump (2 before, 1 after)</p>
<p>Same with the conditional jump:</p>
<p>^code jump-if-false (2 before, 1 after)</p>
<p>And our backward-jumping loop instruction:</p>
<p>^code loop (2 before, 1 after)</p>
<p>We have some diagnostic code that prints each instruction as it executes to help
us debug our VM. That needs to work with the new structure too.</p>
<p>^code trace-execution (1 before, 1 after)</p>
<p>Instead of passing in the VM&#x27;s <code>chunk</code> and <code>ip</code> fields, now we read from the
current CallFrame.</p>
<p>You know, that wasn&#x27;t too bad, actually. Most instructions just use the macros
so didn&#x27;t need to be touched. Next, we jump up a level to the code that calls
<code>run()</code>.</p>
<p>^code interpret-stub (1 before, 2 after)</p>
<p>We finally get to wire up our earlier compiler changes to the back-end changes
we just made. First, we pass the source code to the compiler. It returns us a
new ObjFunction containing the compiled top-level code. If we get <code>NULL</code> back,
it means there was some compile-time error which the compiler has already
reported. In that case, we bail out since we can&#x27;t run anything.</p>
<p>Otherwise, we store the function on the stack and prepare an initial CallFrame
to execute its code. Now you can see why the compiler sets aside stack slot zero
-- that stores the function being called. In the new CallFrame, we point to the
function, initialize its <code>ip</code> to point to the beginning of the function&#x27;s
bytecode, and set up its stack window to start at the very bottom of the VM&#x27;s
value stack.</p>
<p>This gets the interpreter ready to start executing code. After finishing, the VM
used to free the hardcoded chunk. Now that the ObjFunction owns that code, we
don&#x27;t need to do that anymore, so the end of <code>interpret()</code> is simply this:</p>
<p>^code end-interpret (2 before, 1 after)</p>
<p>The last piece of code referring to the old VM fields is <code>runtimeError()</code>. We&#x27;ll
revisit that later in the chapter, but for now let&#x27;s change it to this:</p>
<p>^code runtime-error-temp (2 before, 1 after)</p>
<p>Instead of reading the chunk and <code>ip</code> directly from the VM, it pulls those from
the topmost CallFrame on the stack. That should get the function working again
and behaving as it did before.</p>
<p>Assuming we did all of that correctly, we got clox back to a runnable
state. Fire it up and it does... exactly what it did before. We haven&#x27;t added
any new features yet, so this is kind of a let down. But all of the
infrastructure is there and ready for us now. Let&#x27;s take advantage of it.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="function-declarations">Function Declarations<a href="#function-declarations" class="hash-link" aria-label="Function Declarations的直接链接" title="Function Declarations的直接链接">​</a></h2>
<p>Before we can do call expressions, we need something to call, so we&#x27;ll do
function declarations first. The <span name="fun">fun</span> starts with a
keyword.</p>
<aside name="fun">
<p>Yes, I am going to make a dumb joke about the <code>fun</code> keyword every time it
comes up.</p>
</aside>
<p>^code match-fun (1 before, 1 after)</p>
<p>That passes control to here:</p>
<p>^code fun-declaration</p>
<p>Functions are first-class values, and a function declaration simply creates and
stores one in a newly declared variable. So we parse the name just like any
other variable declaration. A function declaration at the top level will bind
the function to a global variable. Inside a block or other function, a function
declaration creates a local variable.</p>
<p>In an earlier chapter, I explained how variables <a href="/docs/Craftinginterpreters/not-translated-yet/local-variables.html#another-scope-edge-case">get defined in two
stages</a>. This ensures you can&#x27;t access a variable&#x27;s value inside the
variable&#x27;s own initializer. That would be bad because the variable doesn&#x27;t
<em>have</em> a value yet.</p>
<p>Functions don&#x27;t suffer from this problem. It&#x27;s safe for a function to refer to
its own name inside its body. You can&#x27;t <em>call</em> the function and execute the body
until after it&#x27;s fully defined, so you&#x27;ll never see the variable in an
uninitialized state. Practically speaking, it&#x27;s useful to allow this in order to
support recursive local functions.</p>
<p>To make that work, we mark the function declaration&#x27;s variable &quot;initialized&quot; as
soon as we compile the name, before we compile the body. That way the name can
be referenced inside the body without generating an error.</p>
<p>We do need one check, though.</p>
<p>^code check-depth (1 before, 1 after)</p>
<p>Before, we called <code>markInitialized()</code> only when we already knew we were in a
local scope. Now, a top-level function declaration will also call this function.
When that happens, there is no local variable to mark initialized -- the
function is bound to a global variable.</p>
<p>Next, we compile the function itself -- its parameter list and block body. For
that, we use a separate helper function. That helper generates code that
leaves the resulting function object on top of the stack. After that, we call
<code>defineVariable()</code> to store that function back into the variable we declared for
it.</p>
<p>I split out the code to compile the parameters and body because we&#x27;ll reuse it
later for parsing method declarations inside classes. Let&#x27;s build it
incrementally, starting with this:</p>
<p>^code compile-function</p>
<aside name="no-end-scope">
<p>This <code>beginScope()</code> doesn&#x27;t have a corresponding <code>endScope()</code> call. Because we
end Compiler completely when we reach the end of the function body, there&#x27;s no
need to close the lingering outermost scope.</p>
</aside>
<p>For now, we won&#x27;t worry about parameters. We parse an empty pair of parentheses
followed by the body. The body starts with a left curly brace, which we parse
here. Then we call our existing <code>block()</code> function, which knows how to compile
the rest of a block including the closing brace.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-stack-of-compilers">A stack of compilers<a href="#a-stack-of-compilers" class="hash-link" aria-label="A stack of compilers的直接链接" title="A stack of compilers的直接链接">​</a></h3>
<p>The interesting parts are the compiler stuff at the top and bottom. The Compiler
struct stores data like which slots are owned by which local variables, how many
blocks of nesting we&#x27;re currently in, etc. All of that is specific to a single
function. But now the front end needs to handle compiling multiple functions
<span name="nested">nested</span> within each other.</p>
<aside name="nested">
<p>Remember that the compiler treats top-level code as the body of an implicit
function, so as soon as we add <em>any</em> function declarations, we&#x27;re in a world of
nested functions.</p>
</aside>
<p>The trick for managing that is to create a separate Compiler for each function
being compiled. When we start compiling a function declaration, we create a new
Compiler on the C stack and initialize it. <code>initCompiler()</code> sets that Compiler
to be the current one. Then, as we compile the body, all of the functions that
emit bytecode write to the chunk owned by the new Compiler&#x27;s function.</p>
<p>After we reach the end of the function&#x27;s block body, we call <code>endCompiler()</code>.
That yields the newly compiled function object, which we store as a constant in
the <em>surrounding</em> function&#x27;s constant table. But, wait, how do we get back to
the surrounding function? We lost it when <code>initCompiler()</code> overwrote the current
compiler pointer.</p>
<p>We fix that by treating the series of nested Compiler structs as a stack. Unlike
the Value and CallFrame stacks in the VM, we won&#x27;t use an array. Instead, we use
a linked list. Each Compiler points back to the Compiler for the function that
encloses it, all the way back to the root Compiler for the top-level code.</p>
<p>^code enclosing-field (2 before, 1 after)</p>
<p>Inside the Compiler struct, we can&#x27;t reference the Compiler <em>typedef</em> since that
declaration hasn&#x27;t finished yet. Instead, we give a name to the struct itself
and use that for the field&#x27;s type. C is weird.</p>
<p>When initializing a new Compiler, we capture the about-to-no-longer-be-current
one in that pointer.</p>
<p>^code store-enclosing (1 before, 1 after)</p>
<p>Then when a Compiler finishes, it pops itself off the stack by restoring the
previous compiler to be the new current one.</p>
<p>^code restore-enclosing (2 before, 1 after)</p>
<p>Note that we don&#x27;t even need to <span name="compiler">dynamically</span>
allocate the Compiler structs. Each is stored as a local variable in the C stack
-- either in <code>compile()</code> or <code>function()</code>. The linked list of Compilers threads
through the C stack. The reason we can get an unbounded number of them is
because our compiler uses recursive descent, so <code>function()</code> ends up calling
itself recursively when you have nested function declarations.</p>
<aside name="compiler">
<p>Using the native stack for Compiler structs does mean our compiler has a
practical limit on how deeply nested function declarations can be. Go too far
and you could overflow the C stack. If we want the compiler to be more robust
against pathological or even malicious code -- a real concern for tools like
JavaScript VMs -- it would be good to have our compiler artificially limit the
amount of function nesting it permits.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="function-parameters">Function parameters<a href="#function-parameters" class="hash-link" aria-label="Function parameters的直接链接" title="Function parameters的直接链接">​</a></h3>
<p>Functions aren&#x27;t very useful if you can&#x27;t pass arguments to them, so let&#x27;s do
parameters next.</p>
<p>^code parameters (1 before, 1 after)</p>
<p>Semantically, a parameter is simply a local variable declared in the outermost
lexical scope of the function body. We get to use the existing compiler support
for declaring named local variables to parse and compile parameters. Unlike
local variables, which have initializers, there&#x27;s no code here to initialize the
parameter&#x27;s value. We&#x27;ll see how they are initialized later when we do argument
passing in function calls.</p>
<p>While we&#x27;re at it, we note the function&#x27;s arity by counting how many parameters
we parse. The other piece of metadata we store with a function is its name. When
compiling a function declaration, we call <code>initCompiler()</code> right after we parse
the function&#x27;s name. That means we can grab the name right then from the
previous token.</p>
<p>^code init-function-name (1 before, 2 after)</p>
<p>Note that we&#x27;re careful to create a copy of the name string. Remember, the
lexeme points directly into the original source code string. That string may get
freed once the code is finished compiling. The function object we create in the
compiler outlives the compiler and persists until runtime. So it needs its own
heap-allocated name string that it can keep around.</p>
<p>Rad. Now we can compile function declarations, like this:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun areWeHavingItYet() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print &quot;Yes we are!&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print areWeHavingItYet;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We just can&#x27;t do anything <span name="useful">useful</span> with them.</p>
<aside name="useful">
<p>We can print them! I guess that&#x27;s not very useful, though.</p>
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="function-calls">Function Calls<a href="#function-calls" class="hash-link" aria-label="Function Calls的直接链接" title="Function Calls的直接链接">​</a></h2>
<p>By the end of this section, we&#x27;ll start to see some interesting behavior. The
next step is calling functions. We don&#x27;t usually think of it this way, but a
function call expression is kind of an infix <code>(</code> operator. You have a
high-precedence expression on the left for the thing being called -- usually
just a single identifier. Then the <code>(</code> in the middle, followed by the argument
expressions separated by commas, and a final <code>)</code> to wrap it up at the end.</p>
<p>That odd grammatical perspective explains how to hook the syntax into our
parsing table.</p>
<p>^code infix-left-paren (1 before, 1 after)</p>
<p>When the parser encounters a left parenthesis following an expression, it
dispatches to a new parser function.</p>
<p>^code compile-call</p>
<p>We&#x27;ve already consumed the <code>(</code> token, so next we compile the arguments using a
separate <code>argumentList()</code> helper. That function returns the number of arguments
it compiled. Each argument expression generates code that leaves its value on
the stack in preparation for the call. After that, we emit a new <code>OP_CALL</code>
instruction to invoke the function, using the argument count as an operand.</p>
<p>We compile the arguments using this friend:</p>
<p>^code argument-list</p>
<p>That code should look familiar from jlox. We chew through arguments as long as
we find commas after each expression. Once we run out, we consume the final
closing parenthesis and we&#x27;re done.</p>
<p>Well, almost. Back in jlox, we added a compile-time check that you don&#x27;t pass
more than 255 arguments to a call. At the time, I said that was because clox
would need a similar limit. Now you can see why -- since we stuff the argument
count into the bytecode as a single-byte operand, we can only go up to 255. We
need to verify that in this compiler too.</p>
<p>^code arg-limit (1 before, 1 after)</p>
<p>That&#x27;s the front end. Let&#x27;s skip over to the back end, with a quick stop in the
middle to declare the new instruction.</p>
<p>^code op-call (1 before, 1 after)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="binding-arguments-to-parameters">Binding arguments to parameters<a href="#binding-arguments-to-parameters" class="hash-link" aria-label="Binding arguments to parameters的直接链接" title="Binding arguments to parameters的直接链接">​</a></h3>
<p>Before we get to the implementation, we should think about what the stack looks
like at the point of a call and what we need to do from there. When we reach the
call instruction, we have already executed the expression for the function being
called, followed by its arguments. Say our program looks like this:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun sum(a, b, c) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return a + b + c;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print 4 + sum(5, 6, 7);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>If we pause the VM right on the <code>OP_CALL</code> instruction for that call to <code>sum()</code>,
the stack looks like this:</p>
<img decoding="async" loading="lazy" src="image/calls-and-functions/argument-stack.png" alt="Stack: 4, fn sum, 5, 6, 7." class="img_ev3q">
<p>Picture this from the perspective of <code>sum()</code> itself. When the compiler compiled
<code>sum()</code>, it automatically allocated slot zero. Then, after that, it allocated
local slots for the parameters <code>a</code>, <code>b</code>, and <code>c</code>, in order. To perform a call to
<code>sum()</code>, we need a CallFrame initialized with the function being called and a
region of stack slots that it can use. Then we need to collect the arguments
passed to the function and get them into the corresponding slots for the
parameters.</p>
<p>When the VM starts executing the body of <code>sum()</code>, we want its stack window to
look like this:</p>
<img decoding="async" loading="lazy" src="image/calls-and-functions/parameter-window.png" alt="The same stack with the sum() function&#x27;s call frame window surrounding fn sum, 5, 6, and 7." class="img_ev3q">
<p>Do you notice how the argument slots that the caller sets up and the parameter
slots the callee needs are both in exactly the right order? How convenient! This
is no coincidence. When I talked about each CallFrame having its own window into
the stack, I never said those windows must be <em>disjoint</em>. There&#x27;s nothing
preventing us from overlapping them, like this:</p>
<img decoding="async" loading="lazy" src="image/calls-and-functions/overlapping-windows.png" alt="The same stack with the top-level call frame covering the entire stack and the sum() function&#x27;s call frame window surrounding fn sum, 5, 6, and 7." class="img_ev3q">
<p><span name="lua">The</span> top of the caller&#x27;s stack contains the function
being called followed by the arguments in order. We know the caller doesn&#x27;t have
any other slots above those in use because any temporaries needed when
evaluating argument expressions have been discarded by now. The bottom of the
callee&#x27;s stack overlaps so that the parameter slots exactly line up with where
the argument values already live.</p>
<aside name="lua">
<p>Different bytecode VMs and real CPU architectures have different <em>calling
conventions</em>, which is the specific mechanism they use to pass arguments, store
the return address, etc. The mechanism I use here is based on Lua&#x27;s clean, fast
virtual machine.</p>
</aside>
<p>This means that we don&#x27;t need to do <em>any</em> work to &quot;bind an argument to a
parameter&quot;. There&#x27;s no copying values between slots or across environments. The
arguments are already exactly where they need to be. It&#x27;s hard to beat that for
performance.</p>
<p>Time to implement the call instruction.</p>
<p>^code interpret-call (1 before, 1 after)</p>
<p>We need to know the function being called and the number of arguments passed to
it. We get the latter from the instruction&#x27;s operand. That also tells us where
to find the function on the stack by counting past the argument slots from the
top of the stack. We hand that data off to a separate <code>callValue()</code> function. If
that returns <code>false</code>, it means the call caused some sort of runtime error. When
that happens, we abort the interpreter.</p>
<p>If <code>callValue()</code> is successful, there will be a new frame on the CallFrame stack
for the called function. The <code>run()</code> function has its own cached pointer to the
current frame, so we need to update that.</p>
<p>^code update-frame-after-call (2 before, 1 after)</p>
<p>Since the bytecode dispatch loop reads from that <code>frame</code> variable, when the VM
goes to execute the next instruction, it will read the <code>ip</code> from the newly
called function&#x27;s CallFrame and jump to its code. The work for executing that
call begins here:</p>
<p>^code call-value</p>
<aside name="switch">
<p>Using a <code>switch</code> statement to check a single type is overkill now, but will make
sense when we add cases to handle other callable types.</p>
</aside>
<p>There&#x27;s more going on here than just initializing a new CallFrame. Because Lox
is dynamically typed, there&#x27;s nothing to prevent a user from writing bad code
like:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var notAFunction = 123;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">notAFunction();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>If that happens, the runtime needs to safely report an error and halt. So the
first thing we do is check the type of the value that we&#x27;re trying to call. If
it&#x27;s not a function, we error out. Otherwise, the actual call happens here:</p>
<p>^code call</p>
<p>This simply initializes the next CallFrame on the stack. It stores a pointer to
the function being called and points the frame&#x27;s <code>ip</code> to the beginning of the
function&#x27;s bytecode. Finally, it sets up the <code>slots</code> pointer to give the frame
its window into the stack. The arithmetic there ensures that the arguments
already on the stack line up with the function&#x27;s parameters:</p>
<img decoding="async" loading="lazy" src="image/calls-and-functions/arithmetic.png" alt="The arithmetic to calculate frame-&gt;slots from stackTop and argCount." class="img_ev3q">
<p>The funny little <code>- 1</code> is to account for stack slot zero which the compiler set
aside for when we add methods later. The parameters start at slot one so we
make the window start one slot earlier to align them with the arguments.</p>
<p>Before we move on, let&#x27;s add the new instruction to our disassembler.</p>
<p>^code disassemble-call (1 before, 1 after)</p>
<p>And one more quick side trip. Now that we have a handy function for initiating a
CallFrame, we may as well use it to set up the first frame for executing the
top-level code.</p>
<p>^code interpret (1 before, 2 after)</p>
<p>OK, now back to calls...</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="runtime-error-checking">Runtime error checking<a href="#runtime-error-checking" class="hash-link" aria-label="Runtime error checking的直接链接" title="Runtime error checking的直接链接">​</a></h3>
<p>The overlapping stack windows work based on the assumption that a call passes
exactly one argument for each of the function&#x27;s parameters. But, again, because
Lox ain&#x27;t statically typed, a foolish user could pass too many or too few
arguments. In Lox, we&#x27;ve defined that to be a runtime error, which we report
like so:</p>
<p>^code check-arity (1 before, 1 after)</p>
<p>Pretty straightforward. This is why we store the arity of each function inside
the ObjFunction for it.</p>
<p>There&#x27;s another error we need to report that&#x27;s less to do with the user&#x27;s
foolishness than our own. Because the CallFrame array has a fixed size, we need
to ensure a deep call chain doesn&#x27;t overflow it.</p>
<p>^code check-overflow (2 before, 1 after)</p>
<p>In practice, if a program gets anywhere close to this limit, there&#x27;s most likely
a bug in some runaway recursive code.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="printing-stack-traces">Printing stack traces<a href="#printing-stack-traces" class="hash-link" aria-label="Printing stack traces的直接链接" title="Printing stack traces的直接链接">​</a></h3>
<p>While we&#x27;re on the subject of runtime errors, let&#x27;s spend a little time making
them more useful. Stopping on a runtime error is important to prevent the VM
from crashing and burning in some ill-defined way. But simply aborting doesn&#x27;t
help the user fix their code that <em>caused</em> that error.</p>
<p>The classic tool to aid debugging runtime failures is a <strong>stack trace</strong> -- a
print out of each function that was still executing when the program died, and
where the execution was at the point that it died. Now that we have a call stack
and we&#x27;ve conveniently stored each function&#x27;s name, we can show that entire
stack when a runtime error disrupts the harmony of the user&#x27;s existence. It
looks like this:</p>
<p>^code runtime-error-stack (2 before, 2 after)</p>
<aside name="minus">
<p>The <code>- 1</code> is because the IP is already sitting on the next instruction to be
executed but we want the stack trace to point to the previous failed
instruction.</p>
</aside>
<p>After printing the error message itself, we walk the call stack from <span name="top">top</span> (the most recently called function) to bottom (the
top-level code). For each frame, we find the line number that corresponds to the
current <code>ip</code> inside that frame&#x27;s function. Then we print that line number along
with the function name.</p>
<aside name="top">
<p>There is some disagreement on which order stack frames should be shown in a
trace. Most put the innermost function as the first line and work their way
towards the bottom of the stack. Python prints them out in the opposite order.
So reading from top to bottom tells you how your program got to where it is, and
the last line is where the error actually occurred.</p>
<p>There&#x27;s a logic to that style. It ensures you can always see the innermost
function even if the stack trace is too long to fit on one screen. On the other
hand, the &quot;<a href="https://en.wikipedia.org/wiki/Inverted_pyramid_(journalism)" target="_blank" rel="noopener noreferrer">inverted pyramid</a>&quot; from journalism tells us we should put the most
important information <em>first</em> in a block of text. In a stack trace, that&#x27;s the
function where the error actually occurred. Most other language implementations
do that.</p>
</aside>
<p>For example, if you run this broken program:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun a() { b(); }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun b() { c(); }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun c() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  c(&quot;too&quot;, &quot;many&quot;);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">a();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>It prints out:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Expected 0 arguments but got 2.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">[line 4] in c()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">[line 2] in b()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">[line 1] in a()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">[line 7] in script</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>That doesn&#x27;t look too bad, does it?</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="returning-from-functions">Returning from functions<a href="#returning-from-functions" class="hash-link" aria-label="Returning from functions的直接链接" title="Returning from functions的直接链接">​</a></h3>
<p>We&#x27;re getting close. We can call functions, and the VM will execute them. But we
can&#x27;t <em>return</em> from them yet. We&#x27;ve had an <code>OP_RETURN</code> instruction for quite
some time, but it&#x27;s always had some kind of temporary code hanging out in it
just to get us out of the bytecode loop. The time has arrived for a real
implementation.</p>
<p>^code interpret-return (1 before, 1 after)</p>
<p>When a function returns a value, that value will be on top of the stack. We&#x27;re
about to discard the called function&#x27;s entire stack window, so we pop that
return value off and hang on to it. Then we discard the CallFrame for the
returning function. If that was the very last CallFrame, it means we&#x27;ve finished
executing the top-level code. The entire program is done, so we pop the main
script function from the stack and then exit the interpreter.</p>
<p>Otherwise, we discard all of the slots the callee was using for its parameters
and local variables. That includes the same slots the caller used to pass the
arguments. Now that the call is done, the caller doesn&#x27;t need them anymore. This
means the top of the stack ends up right at the beginning of the returning
function&#x27;s stack window.</p>
<p>We push the return value back onto the stack at that new, lower location. Then
we update the <code>run()</code> function&#x27;s cached pointer to the current frame. Just like
when we began a call, on the next iteration of the bytecode dispatch loop, the
VM will read <code>ip</code> from that frame, and execution will jump back to the caller,
right where it left off, immediately after the <code>OP_CALL</code> instruction.</p>
<img decoding="async" loading="lazy" src="image/calls-and-functions/return.png" alt="Each step of the return process: popping the return value, discarding the call frame, pushing the return value." class="img_ev3q">
<p>Note that we assume here that the function <em>did</em> actually return a value, but
a function can implicitly return by reaching the end of its body:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun noReturn() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print &quot;Do stuff&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // No return here.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print noReturn(); // ???</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We need to handle that correctly too. The language is specified to implicitly
return <code>nil</code> in that case. To make that happen, we add this:</p>
<p>^code return-nil (1 before, 2 after)</p>
<p>The compiler calls <code>emitReturn()</code> to write the <code>OP_RETURN</code> instruction at the
end of a function body. Now, before that, it emits an instruction to push <code>nil</code>
onto the stack. And with that, we have working function calls! They can even
take parameters! It almost looks like we know what we&#x27;re doing here.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="return-statements">Return Statements<a href="#return-statements" class="hash-link" aria-label="Return Statements的直接链接" title="Return Statements的直接链接">​</a></h2>
<p>If you want a function that returns something other than the implicit <code>nil</code>, you
need a <code>return</code> statement. Let&#x27;s get that working.</p>
<p>^code match-return (1 before, 1 after)</p>
<p>When the compiler sees a <code>return</code> keyword, it goes here:</p>
<p>^code return-statement</p>
<p>The return value expression is optional, so the parser looks for a semicolon
token to tell if a value was provided. If there is no return value, the
statement implicitly returns <code>nil</code>. We implement that by calling <code>emitReturn()</code>,
which emits an <code>OP_NIL</code> instruction. Otherwise, we compile the return value
expression and return it with an <code>OP_RETURN</code> instruction.</p>
<p>This is the same <code>OP_RETURN</code> instruction we&#x27;ve already implemented -- we don&#x27;t
need any new runtime code. This is quite a difference from jlox. There, we had
to use exceptions to unwind the stack when a <code>return</code> statement was executed.
That was because you could return from deep inside some nested blocks. Since
jlox recursively walks the AST, that meant there were a bunch of Java method
calls we needed to escape out of.</p>
<p>Our bytecode compiler flattens that all out. We do recursive descent during
parsing, but at runtime, the VM&#x27;s bytecode dispatch loop is completely flat.
There is no recursion going on at the C level at all. So returning, even from
within some nested blocks, is as straightforward as returning from the end of
the function&#x27;s body.</p>
<p>We&#x27;re not totally done, though. The new <code>return</code> statement gives us a new
compile error to worry about. Returns are useful for returning from functions
but the top level of a Lox program is imperative code too. You shouldn&#x27;t be able
to <span name="worst">return</span> from there.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">return &quot;What?!&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<aside name="worst">
<p>Allowing <code>return</code> at the top level isn&#x27;t the worst idea in the world. It would
give you a natural way to terminate a script early. You could maybe even use a
returned number to indicate the process&#x27;s exit code.</p>
</aside>
<p>We&#x27;ve specified that it&#x27;s a compile error to have a <code>return</code> statement outside
of any function, which we implement like so:</p>
<p>^code return-from-script (1 before, 1 after)</p>
<p>This is one of the reasons we added that FunctionType enum to the compiler.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="native-functions">Native Functions<a href="#native-functions" class="hash-link" aria-label="Native Functions的直接链接" title="Native Functions的直接链接">​</a></h2>
<p>Our VM is getting more powerful. We&#x27;ve got functions, calls, parameters,
returns. You can define lots of different functions that can call each other in
interesting ways. But, ultimately, they can&#x27;t really <em>do</em> anything. The only
user-visible thing a Lox program can do, regardless of its complexity, is print.
To add more capabilities, we need to expose them to the user.</p>
<p>A programming language implementation reaches out and touches the material world
through <strong>native functions</strong>. If you want to be able to write programs that
check the time, read user input, or access the file system, we need to add
native functions -- callable from Lox but implemented in C -- that expose those
capabilities.</p>
<p>At the language level, Lox is fairly complete -- it&#x27;s got closures, classes,
inheritance, and other fun stuff. One reason it feels like a toy language is
because it has almost no native capabilities. We could turn it into a real
language by adding a long list of them.</p>
<p>However, grinding through a pile of OS operations isn&#x27;t actually very
educational. Once you&#x27;ve seen how to bind one piece of C code to Lox, you get
the idea. But you do need to see <em>one</em>, and even a single native function
requires us to build out all the machinery for interfacing Lox with C. So we&#x27;ll
go through that and do all the hard work. Then, when that&#x27;s done, we&#x27;ll add one
tiny native function just to prove that it works.</p>
<p>The reason we need new machinery is because, from the implementation&#x27;s
perspective, native functions are different from Lox functions. When they are
called, they don&#x27;t push a CallFrame, because there&#x27;s no bytecode code for that
frame to point to. They have no bytecode chunk. Instead, they somehow reference
a piece of native C code.</p>
<p>We handle this in clox by defining native functions as an entirely different
object type.</p>
<p>^code obj-native (1 before, 2 after)</p>
<p>The representation is simpler than ObjFunction -- merely an Obj header and a
pointer to the C function that implements the native behavior. The native
function takes the argument count and a pointer to the first argument on the
stack. It accesses the arguments through that pointer. Once it&#x27;s done, it
returns the result value.</p>
<p>As always, a new object type carries some accoutrements with it. To create an
ObjNative, we declare a constructor-like function.</p>
<p>^code new-native-h (1 before, 1 after)</p>
<p>We implement that like so:</p>
<p>^code new-native</p>
<p>The constructor takes a C function pointer to wrap in an ObjNative. It sets up
the object header and stores the function. For the header, we need a new object
type.</p>
<p>^code obj-type-native (2 before, 2 after)</p>
<p>The VM also needs to know how to deallocate a native function object.</p>
<p>^code free-native (1 before, 1 after)</p>
<p>There isn&#x27;t much here since ObjNative doesn&#x27;t own any extra memory. The other
capability all Lox objects support is being printed.</p>
<p>^code print-native (1 before, 1 after)</p>
<p>In order to support dynamic typing, we have a macro to see if a value is a
native function.</p>
<p>^code is-native (1 before, 1 after)</p>
<p>Assuming that returns true, this macro extracts the C function pointer from a
Value representing a native function:</p>
<p>^code as-native (1 before, 1 after)</p>
<p>All of this baggage lets the VM treat native functions like any other object.
You can store them in variables, pass them around, throw them birthday parties,
etc. Of course, the operation we actually care about is <em>calling</em> them -- using
one as the left-hand operand in a call expression.</p>
<p>Over in <code>callValue()</code> we add another type case.</p>
<p>^code call-native (2 before, 1 after)</p>
<p>If the object being called is a native function, we invoke the C function right
then and there. There&#x27;s no need to muck with CallFrames or anything. We just
hand off to C, get the result, and stuff it back in the stack. This makes native
functions as fast as we can get.</p>
<p>With this, users should be able to call native functions, but there aren&#x27;t any
to call. Without something like a foreign function interface, users can&#x27;t define
their own native functions. That&#x27;s our job as VM implementers. We&#x27;ll start with
a helper to define a new native function exposed to Lox programs.</p>
<p>^code define-native</p>
<p>It takes a pointer to a C function and the name it will be known as in Lox.
We wrap the function in an ObjNative and then store that in a global variable
with the given name.</p>
<p>You&#x27;re probably wondering why we push and pop the name and function on the
stack. That looks weird, right? This is the kind of stuff you have to worry
about when <span name="worry">garbage</span> collection gets involved. Both
<code>copyString()</code> and <code>newNative()</code> dynamically allocate memory. That means once we
have a GC, they can potentially trigger a collection. If that happens, we need
to ensure the collector knows we&#x27;re not done with the name and ObjFunction so
that it doesn&#x27;t free them out from under us. Storing them on the value stack
accomplishes that.</p>
<aside name="worry">
<p>Don&#x27;t worry if you didn&#x27;t follow all that. It will make a lot more sense once we
get around to <a href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection.html">implementing the GC</a>.</p>
</aside>
<p>It feels silly, but after all of that work, we&#x27;re going to add only one
little native function.</p>
<p>^code clock-native</p>
<p>This returns the elapsed time since the program started running, in seconds. It&#x27;s
handy for benchmarking Lox programs. In Lox, we&#x27;ll name it <code>clock()</code>.</p>
<p>^code define-native-clock (1 before, 1 after)</p>
<p>To get to the C standard library <code>clock()</code> function, the &quot;vm&quot; module needs an
include.</p>
<p>^code vm-include-time (1 before, 2 after)</p>
<p>That was a lot of material to work through, but we did it! Type this in and try
it out:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun fib(n) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  if (n &lt; 2) return n;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return fib(n - 2) + fib(n - 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var start = clock();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print fib(35);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print clock() - start;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We can write a really inefficient recursive Fibonacci function. Even better, we
can measure just <span name="faster"><em>how</em></span> inefficient it is. This is, of
course, not the smartest way to calculate a Fibonacci number. But it is a good
way to stress test a language implementation&#x27;s support for function calls. On my
machine, running this in clox is about five times faster than in jlox. That&#x27;s
quite an improvement.</p>
<aside name="faster">
<p>It&#x27;s a little slower than a comparable Ruby program run in Ruby 2.4.3p205, and
about 3x faster than one run in Python 3.7.3. And we still have a lot of simple
optimizations we can do in our VM.</p>
</aside>
<div class="challenges">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h2>
<ol>
<li>
<p>Reading and writing the <code>ip</code> field is one of the most frequent operations
inside the bytecode loop. Right now, we access it through a pointer to the
current CallFrame. That requires a pointer indirection which may force the
CPU to bypass the cache and hit main memory. That can be a real performance
sink.</p>
<p>Ideally, we&#x27;d keep the <code>ip</code> in a native CPU register. C doesn&#x27;t let us
<em>require</em> that without dropping into inline assembly, but we can structure
the code to encourage the compiler to make that optimization. If we store
the <code>ip</code> directly in a C local variable and mark it <code>register</code>, there&#x27;s a
good chance the C compiler will accede to our polite request.</p>
<p>This does mean we need to be careful to load and store the local <code>ip</code> back
into the correct CallFrame when starting and ending function calls.
Implement this optimization. Write a couple of benchmarks and see how it
affects the performance. Do you think the extra code complexity is worth it?</p>
</li>
<li>
<p>Native function calls are fast in part because we don&#x27;t validate that the
call passes as many arguments as the function expects. We really should, or
an incorrect call to a native function without enough arguments could cause
the function to read uninitialized memory. Add arity checking.</p>
</li>
<li>
<p>Right now, there&#x27;s no way for a native function to signal a runtime error.
In a real implementation, this is something we&#x27;d need to support because
native functions live in the statically typed world of C but are called
from dynamically typed Lox land. If a user, say, tries to pass a string to
<code>sqrt()</code>, that native function needs to report a runtime error.</p>
<p>Extend the native function system to support that. How does this capability
affect the performance of native calls?</p>
</li>
<li>
<p>Add some more native functions to do things you find useful. Write some
programs using those. What did you add? How do they affect the feel of the
language and how practical it is?</p>
</li>
</ol>
</div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/calls-and-functions.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Craftinginterpreters/not-translated-yet/backmatter"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">backmatter</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">chunks-of-bytecode</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#function-objects" class="table-of-contents__link toc-highlight">Function Objects</a></li><li><a href="#compiling-to-function-objects" class="table-of-contents__link toc-highlight">Compiling to Function Objects</a><ul><li><a href="#creating-functions-at-compile-time" class="table-of-contents__link toc-highlight">Creating functions at compile time</a></li></ul></li><li><a href="#call-frames" class="table-of-contents__link toc-highlight">Call Frames</a><ul><li><a href="#allocating-local-variables" class="table-of-contents__link toc-highlight">Allocating local variables</a></li><li><a href="#return-addresses" class="table-of-contents__link toc-highlight">Return addresses</a></li><li><a href="#the-call-stack" class="table-of-contents__link toc-highlight">The call stack</a></li></ul></li><li><a href="#function-declarations" class="table-of-contents__link toc-highlight">Function Declarations</a><ul><li><a href="#a-stack-of-compilers" class="table-of-contents__link toc-highlight">A stack of compilers</a></li><li><a href="#function-parameters" class="table-of-contents__link toc-highlight">Function parameters</a></li></ul></li><li><a href="#function-calls" class="table-of-contents__link toc-highlight">Function Calls</a><ul><li><a href="#binding-arguments-to-parameters" class="table-of-contents__link toc-highlight">Binding arguments to parameters</a></li><li><a href="#runtime-error-checking" class="table-of-contents__link toc-highlight">Runtime error checking</a></li><li><a href="#printing-stack-traces" class="table-of-contents__link toc-highlight">Printing stack traces</a></li><li><a href="#returning-from-functions" class="table-of-contents__link toc-highlight">Returning from functions</a></li></ul></li><li><a href="#return-statements" class="table-of-contents__link toc-highlight">Return Statements</a></li><li><a href="#native-functions" class="table-of-contents__link toc-highlight">Native Functions</a></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>