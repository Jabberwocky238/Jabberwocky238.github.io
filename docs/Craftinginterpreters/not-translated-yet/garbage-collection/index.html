<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Craftinginterpreters/not-translated-yet/garbage-collection" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">garbage-collection | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/garbage-collection"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="garbage-collection | My Site"><meta data-rh="true" name="description" content="I wanna, I wanna,"><meta data-rh="true" property="og:description" content="I wanna, I wanna,"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/garbage-collection"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/garbage-collection" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/garbage-collection" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0d35426a.css">
<script src="/assets/js/runtime~main.0868a236.js" defer="defer"></script>
<script src="/assets/js/main.f1c02528.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/english">English</a><button aria-label="展开侧边栏分类 &#x27;English&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/crafting-interpreter">Crafting-interpreter</a><button aria-label="折叠侧边栏分类 &#x27;Crafting-interpreter&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/welcome">Welcome</a><button aria-label="展开侧边栏分类 &#x27;Welcome&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/not-translated-yet">not-translated-yet</a><button aria-label="折叠侧边栏分类 &#x27;not-translated-yet&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-bytecode-virtual-machine">a-bytecode-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-tree-walk-interpreter">a-tree-walk-interpreter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine">a-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/acknowledgements">acknowledgements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-i">appendix-i</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii">appendix-ii</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/backmatter">backmatter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/calls-and-functions">calls-and-functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode">chunks-of-bytecode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes-and-instances">classes-and-instances</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes">classes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/closures">closures</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/compiling-expressions">compiling-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/contents">contents</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/control-flow">control-flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/dedication">dedication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions">evaluating-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/functions">functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection">garbage-collection</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/global-variables">global-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/hash-tables">hash-tables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/inheritance">inheritance</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth">jumping-back-and-forth</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/local-variables">local-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/methods-and-initializers">methods-and-initializers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/optimization">optimization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/parsing-expressions">parsing-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/representing-code">representing-code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding">resolving-and-binding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand">scanning-on-demand</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning">scanning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/statements-and-state">statements-and-state</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/strings">strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/superclasses">superclasses</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/the-lox-language">the-lox-language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/types-of-values">types-of-values</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/crafting-interpreter"><span itemprop="name">Crafting-interpreter</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/not-translated-yet"><span itemprop="name">not-translated-yet</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">garbage-collection</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>garbage-collection</h1></header><blockquote>
<p>I wanna, I wanna,<br>
I wanna, I wanna,<br>
I wanna be trash.<br></p>
<p><cite>The Whip, “Trash”</cite></p>
</blockquote>
<p>We say Lox is a &quot;high-level&quot; language because it frees programmers from worrying
about details irrelevant to the problem they&#x27;re solving. The user becomes an
executive, giving the machine abstract goals and letting the lowly computer
figure out how to get there.</p>
<p>Dynamic memory allocation is a perfect candidate for automation. It&#x27;s necessary
for a working program, tedious to do by hand, and yet still error-prone. The
inevitable mistakes can be catastrophic, leading to crashes, memory corruption,
or security violations. It&#x27;s the kind of risky-yet-boring work that machines
excel at over humans.</p>
<p>This is why Lox is a <strong>managed language</strong>, which means that the language
implementation manages memory allocation and freeing on the user&#x27;s behalf. When
a user performs an operation that requires some dynamic memory, the VM
automatically allocates it. The programmer never worries about deallocating
anything. The machine ensures any memory the program is using sticks around as
long as needed.</p>
<p>Lox provides the illusion that the computer has an infinite amount of memory.
Users can allocate and allocate and allocate and never once think about where
all these bytes are coming from. Of course, computers do not yet <em>have</em> infinite
memory. So the way managed languages maintain this illusion is by going behind
the programmer&#x27;s back and reclaiming memory that the program no longer needs.
The component that does this is called a <strong>garbage <span name="recycle">collector</span></strong>.</p>
<aside name="recycle">
<p>Recycling would really be a better metaphor for this. The GC doesn&#x27;t <em>throw
away</em> the memory, it reclaims it to be reused for new data. But managed
languages are older than Earth Day, so the inventors went with the analogy they
knew.</p>
<img decoding="async" loading="lazy" src="image/garbage-collection/recycle.png" class="above img_ev3q" alt="A recycle bin full of bits.">
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="reachability">Reachability<a href="#reachability" class="hash-link" aria-label="Reachability的直接链接" title="Reachability的直接链接">​</a></h2>
<p>This raises a surprisingly difficult question: how does a VM tell what memory is
<em>not</em> needed? Memory is only needed if it is read in the future, but short of
having a time machine, how can an implementation tell what code the program
<em>will</em> execute and which data it <em>will</em> use? Spoiler alert: VMs cannot travel
into the future. Instead, the language makes a <span name="conservative">conservative</span> approximation: it considers a piece of
memory to still be in use if it <em>could possibly</em> be read in the future.</p>
<aside name="conservative">
<p>I&#x27;m using &quot;conservative&quot; in the general sense. There is such a thing as a
&quot;conservative garbage collector&quot; which means something more specific. All
garbage collectors are &quot;conservative&quot; in that they keep memory alive if it
<em>could</em> be accessed, instead of having a Magic 8-Ball that lets them more
precisely know what data <em>will</em> be accessed.</p>
<p>A <strong>conservative GC</strong> is a special kind of collector that considers any piece of
memory to be a pointer if the value in there looks like it could be an address.
This is in contrast to a <strong>precise GC</strong> -- which is what we&#x27;ll implement -- that
knows exactly which words in memory are pointers and which store other kinds of
values like numbers or strings.</p>
</aside>
<p>That sounds <em>too</em> conservative. Couldn&#x27;t <em>any</em> bit of memory potentially be
read? Actually, no, at least not in a memory-safe language like Lox. Here&#x27;s an
example:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var a = &quot;first value&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">a = &quot;updated&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// GC here.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">print a;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Say we run the GC after the assignment has completed on the second line. The
string &quot;first value&quot; is still sitting in memory, but there is no way for the
user&#x27;s program to ever get to it. Once <code>a</code> got reassigned, the program lost any
reference to that string. We can safely free it. A value is <strong>reachable</strong> if
there is some way for a user program to reference it. Otherwise, like the string
&quot;first value&quot; here, it is <strong>unreachable</strong>.</p>
<p>Many values can be directly accessed by the VM. Take a look at:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var global = &quot;string&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var local = &quot;another&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print global + local;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Pause the program right after the two strings have been concatenated but before
the <code>print</code> statement has executed. The VM can reach <code>&quot;string&quot;</code> by looking
through the global variable table and finding the entry for <code>global</code>. It can
find <code>&quot;another&quot;</code> by walking the value stack and hitting the slot for the local
variable <code>local</code>. It can even find the concatenated string <code>&quot;stringanother&quot;</code>
since that temporary value is also sitting on the VM&#x27;s stack at the point when
we paused our program.</p>
<p>All of these values are called <strong>roots</strong>. A root is any object that the VM can
reach directly without going through a reference in some other object. Most
roots are global variables or on the stack, but as we&#x27;ll see, there are a couple
of other places the VM stores references to objects that it can find.</p>
<p>Other values can be found by going through a reference inside another value.
<span name="class">Fields</span> on instances of classes are the most obvious
case, but we don&#x27;t have those yet. Even without those, our VM still has indirect
references. Consider:</p>
<aside name="class">
<p>We&#x27;ll get there <a href="/docs/Craftinginterpreters/not-translated-yet/classes-and-instances.html">soon</a>, though!</p>
</aside>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun makeClosure() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;data&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun f() { print a; }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return f;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var closure = makeClosure();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // GC here.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  closure();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Say we pause the program on the marked line and run the garbage collector. When
the collector is done and the program resumes, it will call the closure, which
will in turn print <code>&quot;data&quot;</code>. So the collector needs to <em>not</em> free that string.
But here&#x27;s what the stack looks like when we pause the program:</p>
<img decoding="async" loading="lazy" src="image/garbage-collection/stack.png" alt="The stack, containing only the script and closure." class="img_ev3q">
<p>The <code>&quot;data&quot;</code> string is nowhere on it. It has already been hoisted off the stack
and moved into the closed upvalue that the closure uses. The closure itself is
on the stack. But to get to the string, we need to trace through the closure and
its upvalue array. Since it <em>is</em> possible for the user&#x27;s program to do that, all
of these indirectly accessible objects are also considered reachable.</p>
<img decoding="async" loading="lazy" src="image/garbage-collection/reachable.png" class="wide img_ev3q" alt="All of the referenced objects from the closure, and the path to the &#x27;data&#x27; string from the stack.">
<p>This gives us an inductive definition of reachability:</p>
<ul>
<li>
<p>All roots are reachable.</p>
</li>
<li>
<p>Any object referred to from a reachable object is itself reachable.</p>
</li>
</ul>
<p>These are the values that are still &quot;live&quot; and need to stay in memory. Any value
that <em>doesn&#x27;t</em> meet this definition is fair game for the collector to reap.
That recursive pair of rules hints at a recursive algorithm we can use to free
up unneeded memory:</p>
<ol>
<li>
<p>Starting with the roots, traverse through object references to find the
full set of reachable objects.</p>
</li>
<li>
<p>Free all objects <em>not</em> in that set.</p>
</li>
</ol>
<p>Many <span name="handbook">different</span> garbage collection algorithms are in
use today, but they all roughly follow that same structure. Some may interleave
the steps or mix them, but the two fundamental operations are there. They mostly
differ in <em>how</em> they perform each step.</p>
<aside name="handbook">
<p>If you want to explore other GC algorithms,
<a href="http://gchandbook.org/" target="_blank" rel="noopener noreferrer"><em>The Garbage Collection Handbook</em></a> (Jones, et al.) is the canonical
reference. For a large book on such a deep, narrow topic, it is quite enjoyable
to read. Or perhaps I have a strange idea of fun.</p>
</aside>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="mark-sweep-garbage-collection">Mark-Sweep Garbage Collection<a href="#mark-sweep-garbage-collection" class="hash-link" aria-label="Mark-Sweep Garbage Collection的直接链接" title="Mark-Sweep Garbage Collection的直接链接">​</a></h2>
<p>The first managed language was Lisp, the second &quot;high-level&quot; language to be
invented, right after Fortran. John McCarthy considered using manual memory
management or reference counting, but <span name="procrastination">eventually</span> settled on (and coined) garbage
collection -- once the program was out of memory, it would go back and find
unused storage it could reclaim.</p>
<aside name="procrastination">
<p>In John McCarthy&#x27;s &quot;History of Lisp&quot;, he notes: &quot;Once we decided on garbage
collection, its actual implementation could be postponed, because only toy
examples were being done.&quot; Our choice to procrastinate adding the GC to clox
follows in the footsteps of giants.</p>
</aside>
<p>He designed the very first, simplest garbage collection algorithm, called
<strong>mark-and-sweep</strong> or just <strong>mark-sweep</strong>. Its description fits in three short
paragraphs in the initial paper on Lisp. Despite its age and simplicity, the
same fundamental algorithm underlies many modern memory managers. Some corners
of CS seem to be timeless.</p>
<p>As the name implies, mark-sweep works in two phases:</p>
<ul>
<li>
<p><strong>Marking:</strong> We start with the roots and traverse or <span name="trace"><em>trace</em></span> through all of the objects those roots refer to.
This is a classic graph traversal of all of the reachable objects. Each time
we visit an object, we <em>mark</em> it in some way. (Implementations differ in how
they record the mark.)</p>
</li>
<li>
<p><strong>Sweeping:</strong> Once the mark phase completes, every reachable object
in the heap has been marked. That means any unmarked object is unreachable and
ripe for reclamation. We go through all the unmarked objects and free each
one.</p>
</li>
</ul>
<p>It looks something like this:</p>
<img decoding="async" loading="lazy" src="image/garbage-collection/mark-sweep.png" class="wide img_ev3q" alt="Starting from a graph of objects, first the reachable ones are marked, the remaining are swept, and then only the reachable remain.">
<aside name="trace">
<p>A <strong>tracing garbage collector</strong> is any algorithm that traces through the graph
of object references. This is in contrast with reference counting, which has a
different strategy for tracking the reachable objects.</p>
</aside>
<p>That&#x27;s what we&#x27;re gonna implement. Whenever we decide it&#x27;s time to reclaim some
bytes, we&#x27;ll trace everything and mark all the reachable objects, free what
didn&#x27;t get marked, and then resume the user&#x27;s program.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="collecting-garbage">Collecting garbage<a href="#collecting-garbage" class="hash-link" aria-label="Collecting garbage的直接链接" title="Collecting garbage的直接链接">​</a></h3>
<p>This entire chapter is about implementing this one <span name="one">function</span>:</p>
<aside name="one">
<p>Of course, we&#x27;ll end up adding a bunch of helper functions too.</p>
</aside>
<p>^code collect-garbage-h (1 before, 1 after)</p>
<p>We&#x27;ll work our way up to a full implementation starting with this empty shell:</p>
<p>^code collect-garbage</p>
<p>The first question you might ask is, When does this function get called? It
turns out that&#x27;s a subtle question that we&#x27;ll spend some time on later in the
chapter. For now we&#x27;ll sidestep the issue and build ourselves a handy diagnostic
tool in the process.</p>
<p>^code define-stress-gc (1 before, 2 after)</p>
<p>We&#x27;ll add an optional &quot;stress test&quot; mode for the garbage collector. When this
flag is defined, the GC runs as often as it possibly can. This is, obviously,
horrendous for performance. But it&#x27;s great for flushing out memory management
bugs that occur only when a GC is triggered at just the right moment. If <em>every</em>
moment triggers a GC, you&#x27;re likely to find those bugs.</p>
<p>^code call-collect (1 before, 1 after)</p>
<p>Whenever we call <code>reallocate()</code> to acquire more memory, we force a collection to
run. The if check is because <code>reallocate()</code> is also called to free or shrink an
allocation. We don&#x27;t want to trigger a GC for that -- in particular because the
GC itself will call <code>reallocate()</code> to free memory.</p>
<p>Collecting right before <span name="demand">allocation</span> is the classic way
to wire a GC into a VM. You&#x27;re already calling into the memory manager, so it&#x27;s
an easy place to hook in the code. Also, allocation is the only time when you
really <em>need</em> some freed up memory so that you can reuse it. If you <em>don&#x27;t</em> use
allocation to trigger a GC, you have to make sure every possible place in code
where you can loop and allocate memory also has a way to trigger the collector.
Otherwise, the VM can get into a starved state where it needs more memory but
never collects any.</p>
<aside name="demand">
<p>More sophisticated collectors might run on a separate thread or be interleaved
periodically during program execution -- often at function call boundaries or
when a backward jump occurs.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="debug-logging">Debug logging<a href="#debug-logging" class="hash-link" aria-label="Debug logging的直接链接" title="Debug logging的直接链接">​</a></h3>
<p>While we&#x27;re on the subject of diagnostics, let&#x27;s put some more in. A real
challenge I&#x27;ve found with garbage collectors is that they are opaque. We&#x27;ve been
running lots of Lox programs just fine without any GC <em>at all</em> so far. Once we
add one, how do we tell if it&#x27;s doing anything useful? Can we tell only if we
write programs that plow through acres of memory? How do we debug that?</p>
<p>An easy way to shine a light into the GC&#x27;s inner workings is with some logging.</p>
<p>^code define-log-gc (1 before, 2 after)</p>
<p>When this is enabled, clox prints information to the console when it does
something with dynamic memory.</p>
<p>We need a couple of includes.</p>
<p>^code debug-log-includes (1 before, 2 after)</p>
<p>We don&#x27;t have a collector yet, but we can start putting in some of the logging
now. We&#x27;ll want to know when a collection run starts.</p>
<p>^code log-before-collect (1 before, 1 after)</p>
<p>Eventually we will log some other operations during the collection, so we&#x27;ll
also want to know when the show&#x27;s over.</p>
<p>^code log-after-collect (2 before, 1 after)</p>
<p>We don&#x27;t have any code for the collector yet, but we do have functions for
allocating and freeing, so we can instrument those now.</p>
<p>^code debug-log-allocate (1 before, 1 after)</p>
<p>And at the end of an object&#x27;s lifespan:</p>
<p>^code log-free-object (1 before, 1 after)</p>
<p>With these two flags, we should be able to see that we&#x27;re making progress as we
work through the rest of the chapter.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="marking-the-roots">Marking the Roots<a href="#marking-the-roots" class="hash-link" aria-label="Marking the Roots的直接链接" title="Marking the Roots的直  接链接">​</a></h2>
<p>Objects are scattered across the heap like stars in the inky night sky. A
reference from one object to another forms a connection, and these
constellations are the graph that the mark phase traverses. Marking begins at
the roots.</p>
<p>^code call-mark-roots (3 before, 2 after)</p>
<p>Most roots are local variables or temporaries sitting right in the VM&#x27;s stack,
so we start by walking that.</p>
<p>^code mark-roots</p>
<p>To mark a Lox value, we use this new function:</p>
<p>^code mark-value-h (1 before, 1 after)</p>
<p>Its implementation is here:</p>
<p>^code mark-value</p>
<p>Some Lox values -- numbers, Booleans, and <code>nil</code> -- are stored directly inline in
Value and require no heap allocation. The garbage collector doesn&#x27;t need to
worry about them at all, so the first thing we do is ensure that the value is an
actual heap object. If so, the real work happens in this function:</p>
<p>^code mark-object-h (1 before, 1 after)</p>
<p>Which is defined here:</p>
<p>^code mark-object</p>
<p>The <code>NULL</code> check is unnecessary when called from <code>markValue()</code>. A Lox Value that
is some kind of Obj type will always have a valid pointer. But later we will
call this function directly from other code, and in some of those places, the
object being pointed to is optional.</p>
<p>Assuming we do have a valid object, we mark it by setting a flag. That new field
lives in the Obj header struct all objects share.</p>
<p>^code is-marked-field (1 before, 1 after)</p>
<p>Every new object begins life unmarked because we haven&#x27;t yet determined if it is
reachable or not.</p>
<p>^code init-is-marked (1 before, 2 after)</p>
<p>Before we go any farther, let&#x27;s add some logging to <code>markObject()</code>.</p>
<p>^code log-mark-object (2 before, 1 after)</p>
<p>This way we can see what the mark phase is doing. Marking the stack takes care
of local variables and temporaries. The other main source of roots are the
global variables.</p>
<p>^code mark-globals (2 before, 1 after)</p>
<p>Those live in a hash table owned by the VM, so we&#x27;ll declare another helper
function for marking all of the objects in a table.</p>
<p>^code mark-table-h (2 before, 2 after)</p>
<p>We implement that in the &quot;table&quot; module here:</p>
<p>^code mark-table</p>
<p>Pretty straightforward. We walk the entry array. For each one, we mark its
value. We also mark the key strings for each entry since the GC manages those
strings too.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="less-obvious-roots">Less obvious roots<a href="#less-obvious-roots" class="hash-link" aria-label="Less obvious roots的直接链接" title="Less obvious roots的直接链接">​</a></h3>
<p>Those cover the roots that we typically think of -- the values that are
obviously reachable because they&#x27;re stored in variables the user&#x27;s program can
see. But the VM has a few of its own hidey-holes where it squirrels away
references to values that it directly accesses.</p>
<p>Most function call state lives in the value stack, but the VM maintains a
separate stack of CallFrames. Each CallFrame contains a pointer to the closure
being called. The VM uses those pointers to access constants and upvalues, so
those closures need to be kept around too.</p>
<p>^code mark-closures (1 before, 2 after)</p>
<p>Speaking of upvalues, the open upvalue list is another set of values that the
VM can directly reach.</p>
<p>^code mark-open-upvalues (3 before, 2 after)</p>
<p>Remember also that a collection can begin during <em>any</em> allocation. Those
allocations don&#x27;t just happen while the user&#x27;s program is running. The compiler
itself periodically grabs memory from the heap for literals and the constant
table. If the GC runs while we&#x27;re in the middle of compiling, then any values
the compiler directly accesses need to be treated as roots too.</p>
<p>To keep the compiler module cleanly separated from the rest of the VM, we&#x27;ll do
that in a separate function.</p>
<p>^code call-mark-compiler-roots (1 before, 1 after)</p>
<p>It&#x27;s declared here:</p>
<p>^code mark-compiler-roots-h (1 before, 2 after)</p>
<p>Which means the &quot;memory&quot; module needs an include.</p>
<p>^code memory-include-compiler (2 before, 1 after)</p>
<p>And the definition is over in the &quot;compiler&quot; module.</p>
<p>^code mark-compiler-roots</p>
<p>Fortunately, the compiler doesn&#x27;t have too many values that it hangs on to. The
only object it uses is the ObjFunction it is compiling into. Since function
declarations can nest, the compiler has a linked list of those and we walk the
whole list.</p>
<p>Since the &quot;compiler&quot; module is calling <code>markObject()</code>, it also needs an include.</p>
<p>^code compiler-include-memory (1 before, 1 after)</p>
<p>Those are all the roots. After running this, every object that the VM -- runtime
and compiler -- can get to <em>without</em> going through some other object has its
mark bit set.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="tracing-object-references">Tracing Object References<a href="#tracing-object-references" class="hash-link" aria-label="Tracing Object References的直接链接" title="Tracing Object References的直接链接">​</a></h2>
<p>The next step in the marking process is tracing through the graph of references
between objects to find the indirectly reachable values. We don&#x27;t have instances
with fields yet, so there aren&#x27;t many objects that contain references, but we do
have <span name="some">some</span>. In particular, ObjClosure has the list of
ObjUpvalues it closes over as well as a reference to the raw ObjFunction that it
wraps. ObjFunction, in turn, has a constant table containing references to all
of the literals created in the function&#x27;s body. This is enough to build a fairly
complex web of objects for our collector to crawl through.</p>
<aside name="some">
<p>I slotted this chapter into the book right here specifically <em>because</em> we now
have closures which give us interesting objects for the garbage collector to
process.</p>
</aside>
<p>Now it&#x27;s time to implement that traversal. We can go breadth-first, depth-first,
or in some other order. Since we just need to find the <em>set</em> of all reachable
objects, the order we visit them <span name="dfs">mostly</span> doesn&#x27;t matter.</p>
<aside name="dfs">
<p>I say &quot;mostly&quot; because some garbage collectors move objects in the order that
they are visited, so traversal order determines which objects end up adjacent in
memory. That impacts performance because the CPU uses locality to determine
which memory to preload into the caches.</p>
<p>Even when traversal order does matter, it&#x27;s not clear which order is <em>best</em>.
It&#x27;s very difficult to determine which order objects will be used in in the
future, so it&#x27;s hard for the GC to know which order will help performance.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-tricolor-abstraction">The tricolor abstraction<a href="#the-tricolor-abstraction" class="hash-link" aria-label="The tricolor abstraction的直接链接" title="The tricolor abstraction的直接链接">​</a></h3>
<p>As the collector wanders through the graph of objects, we need to make sure it
doesn&#x27;t lose track of where it is or get stuck going in circles. This is
particularly a concern for advanced implementations like incremental GCs that
interleave marking with running pieces of the user&#x27;s program. The collector
needs to be able to pause and then pick up where it left off later.</p>
<p>To help us soft-brained humans reason about this complex process, VM hackers
came up with a metaphor called the <span name="color"></span><strong>tricolor
abstraction</strong>. Each object has a conceptual &quot;color&quot; that tracks what state the
object is in, and what work is left to do.</p>
<aside name="color">
<p>Advanced garbage collection algorithms often add other colors to the
abstraction. I&#x27;ve seen multiple shades of gray, and even purple in some designs.
My puce-chartreuse-fuchsia-malachite collector paper was, alas, not accepted for
publication.</p>
</aside>
<ul>
<li>
<p><strong><img decoding="async" loading="lazy" src="image/garbage-collection/white.png" alt="A white circle." class="dot img_ev3q"> White:</strong> At the beginning of a garbage collection, every
object is white. This color means we have not reached or processed the
object at all.</p>
</li>
<li>
<p><strong><img decoding="async" loading="lazy" src="image/garbage-collection/gray.png" alt="A gray circle." class="dot img_ev3q"> Gray:</strong> During marking, when we first reach an object, we
darken it gray. This color means we know the object itself is reachable and
should not be collected. But we have not yet traced <em>through</em> it to see what
<em>other</em> objects it references. In graph algorithm terms, this is the
<em>worklist</em> -- the set of objects we know about but haven&#x27;t processed yet.</p>
</li>
<li>
<p><strong><img decoding="async" loading="lazy" src="image/garbage-collection/black.png" alt="A black circle." class="dot img_ev3q"> Black:</strong> When
we take a gray object and mark all of the objects it references, we then
turn the gray object black. This color means the mark phase is done
processing that object.</p>
</li>
</ul>
<p>In terms of that abstraction, the marking process now looks like this:</p>
<ol>
<li>
<p>Start off with all objects white.</p>
</li>
<li>
<p>Find all the roots and mark them gray.</p>
</li>
<li>
<p>Repeat as long as there are still gray objects:</p>
<ol>
<li>
<p>Pick a gray object. Turn any white objects that the object mentions to
gray.</p>
</li>
<li>
<p>Mark the original gray object black.</p>
</li>
</ol>
</li>
</ol>
<p>I find it helps to visualize this. You have a web of objects with references
between them. Initially, they are all little white dots. Off to the side are
some incoming edges from the VM that point to the roots. Those roots turn gray.
Then each gray object&#x27;s siblings turn gray while the object itself turns black.
The full effect is a gray wavefront that passes through the graph, leaving a
field of reachable black objects behind it. Unreachable objects are not touched
by the wavefront and stay white.</p>
<img decoding="async" loading="lazy" src="image/garbage-collection/tricolor-trace.png" class="wide img_ev3q" alt="A gray wavefront working through a graph of nodes.">
<p>At the <span name="invariant">end</span>, you&#x27;re left with a sea of reached,
black objects sprinkled with islands of white objects that can be swept up and
freed. Once the unreachable objects are freed, the remaining objects -- all
black -- are reset to white for the next garbage collection cycle.</p>
<aside name="invariant">
<p>Note that at every step of this process no black node ever points to a white
node. This property is called the <strong>tricolor invariant</strong>. The traversal process
maintains this invariant to ensure that no reachable object is ever collected.</p>
</aside>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-worklist-for-gray-objects">A worklist for gray objects<a href="#a-worklist-for-gray-objects" class="hash-link" aria-label="A worklist for gray objects的直接链接" title="A worklist for gray objects的直接链接">​</a></h3>
<p>In our implementation we have already marked the roots. They&#x27;re all gray. The
next step is to start picking them and traversing their references. But we don&#x27;t
have any easy way to find them. We set a field on the object, but that&#x27;s it. We
don&#x27;t want to have to traverse the entire object list looking for objects with
that field set.</p>
<p>Instead, we&#x27;ll create a separate worklist to keep track of all of the gray
objects. When an object turns gray, in addition to setting the mark field we&#x27;ll
also add it to the worklist.</p>
<p>^code add-to-gray-stack (1 before, 1 after)</p>
<p>We could use any kind of data structure that lets us put items in and take them
out easily. I picked a stack because that&#x27;s the simplest to implement with a
dynamic array in C. It works mostly like other dynamic arrays we&#x27;ve built in
Lox, <em>except</em>, note that it calls the <em>system</em> <code>realloc()</code> function and not our
own <code>reallocate()</code> wrapper. The memory for the gray stack itself is <em>not</em>
managed by the garbage collector. We don&#x27;t want growing the gray stack during a
GC to cause the GC to recursively start a new GC. That could tear a hole in the
space-time continuum.</p>
<p>We&#x27;ll manage its memory ourselves, explicitly. The VM owns the gray stack.</p>
<p>^code vm-gray-stack (1 before, 1 after)</p>
<p>It starts out empty.</p>
<p>^code init-gray-stack (1 before, 2 after)</p>
<p>And we need to free it when the VM shuts down.</p>
<p>^code free-gray-stack (2 before, 1 after)</p>
<p><span name="robust">We</span> take full responsibility for this array. That
includes allocation failure. If we can&#x27;t create or grow the gray stack, then we
can&#x27;t finish the garbage collection. This is bad news for the VM, but
fortunately rare since the gray stack tends to be pretty small. It would be nice
to do something more graceful, but to keep the code in this book simple, we just
abort.</p>
<aside name="robust">
<p>To be more robust, we can allocate a &quot;rainy day fund&quot; block of memory when we
start the VM. If the gray stack allocation fails, we free the rainy day block
and try again. That may give us enough wiggle room on the heap to create the
gray stack, finish the GC, and free up more memory.</p>
</aside>
<p>^code exit-gray-stack (2 before, 1 after)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="processing-gray-objects">Processing gray objects<a href="#processing-gray-objects" class="hash-link" aria-label="Processing gray objects的直接链接" title="Processing gray objects的直接链接">​</a></h3>
<p>OK, now when we&#x27;re done marking the roots, we have both set a bunch of fields
and filled our work list with objects to chew through. It&#x27;s time for the next
phase.</p>
<p>^code call-trace-references (1 before, 2 after)</p>
<p>Here&#x27;s the implementation:</p>
<p>^code trace-references</p>
<p>It&#x27;s as close to that textual algorithm as you can get. Until the stack empties,
we keep pulling out gray objects, traversing their references, and then marking
them black. Traversing an object&#x27;s references may turn up new white objects that
get marked gray and added to the stack. So this function swings back and forth
between turning white objects gray and gray objects black, gradually advancing
the entire wavefront forward.</p>
<p>Here&#x27;s where we traverse a single object&#x27;s references:</p>
<p>^code blacken-object</p>
<p>Each object <span name="leaf">kind</span> has different fields that might
reference other objects, so we need a specific blob of code for each type. We
start with the easy ones -- strings and native function objects contain no
outgoing references so there is nothing to traverse.</p>
<aside name="leaf">
<p>An easy optimization we could do in <code>markObject()</code> is to skip adding strings and
native functions to the gray stack at all since we know they don&#x27;t need to be
processed. Instead, they could darken from white straight to black.</p>
</aside>
<p>Note that we don&#x27;t set any state in the traversed object itself. There is no
direct encoding of &quot;black&quot; in the object&#x27;s state. A black object is any object
whose <code>isMarked</code> field is <span name="field">set</span> and that is no longer in
the gray stack.</p>
<aside name="field">
<p>You may rightly wonder why we have the <code>isMarked</code> field at all. All in good
time, friend.</p>
</aside>
<p>Now let&#x27;s start adding in the other object types. The simplest is upvalues.</p>
<p>^code blacken-upvalue (2 before, 1 after)</p>
<p>When an upvalue is closed, it contains a reference to the closed-over value.
Since the value is no longer on the stack, we need to make sure we trace the
reference to it from the upvalue.</p>
<p>Next are functions.</p>
<p>^code blacken-function (1 before, 1 after)</p>
<p>Each function has a reference to an ObjString containing the function&#x27;s name.
More importantly, the function has a constant table packed full of references to
other objects. We trace all of those using this helper:</p>
<p>^code mark-array</p>
<p>The last object type we have now -- we&#x27;ll add more in later chapters -- is
closures.</p>
<p>^code blacken-closure (1 before, 1 after)</p>
<p>Each closure has a reference to the bare function it wraps, as well as an array
of pointers to the upvalues it captures. We trace all of those.</p>
<p>That&#x27;s the basic mechanism for processing a gray object, but there are two loose
ends to tie up. First, some logging.</p>
<p>^code log-blacken-object (1 before, 1 after)</p>
<p>This way, we can watch the tracing percolate through the object graph. Speaking
of which, note that I said <em>graph</em>. References between objects are directed, but
that doesn&#x27;t mean they&#x27;re <em>acyclic!</em> It&#x27;s entirely possible to have cycles of
objects. When that happens, we need to ensure our collector doesn&#x27;t get stuck in
an infinite loop as it continually re-adds the same series of objects to the
gray stack.</p>
<p>The fix is easy.</p>
<p>^code check-is-marked (1 before, 1 after)</p>
<p>If the object is already marked, we don&#x27;t mark it again and thus don&#x27;t add it to
the gray stack. This ensures that an already-gray object is not redundantly
added and that a black object is not inadvertently turned back to gray. In other
words, it keeps the wavefront moving forward through only the white objects.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="sweeping-unused-objects">Sweeping Unused Objects<a href="#sweeping-unused-objects" class="hash-link" aria-label="Sweeping Unused Objects的直接链接" title="Sweeping Unused Objects的直接链接">​</a></h2>
<p>When the loop in <code>traceReferences()</code> exits, we have processed all the objects we
could get our hands on. The gray stack is empty, and every object in the heap is
either black or white. The black objects are reachable, and we want to hang on to
them. Anything still white never got touched by the trace and is thus garbage.
All that&#x27;s left is to reclaim them.</p>
<p>^code call-sweep (1 before, 2 after)</p>
<p>All of the logic lives in one function.</p>
<p>^code sweep</p>
<p>I know that&#x27;s kind of a lot of code and pointer shenanigans, but there isn&#x27;t
much to it once you work through it. The outer <code>while</code> loop walks the linked
list of every object in the heap, checking their mark bits. If an object is
marked (black), we leave it alone and continue past it. If it is unmarked
(white), we unlink it from the list and free it using the <code>freeObject()</code>
function we already wrote.</p>
<img decoding="async" loading="lazy" src="image/garbage-collection/unlink.png" alt="A recycle bin full of bits." class="img_ev3q">
<p>Most of the other code in here deals with the fact that removing a node from a
singly linked list is cumbersome. We have to continuously remember the previous
node so we can unlink its next pointer, and we have to handle the edge case
where we are freeing the first node. But, otherwise, it&#x27;s pretty simple --
delete every node in a linked list that doesn&#x27;t have a bit set in it.</p>
<p>There&#x27;s one little addition:</p>
<p>^code unmark (1 before, 1 after)</p>
<p>After <code>sweep()</code> completes, the only remaining objects are the live black ones
with their mark bits set. That&#x27;s correct, but when the <em>next</em> collection cycle
starts, we need every object to be white. So whenever we reach a black object,
we go ahead and clear the bit now in anticipation of the next run.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="weak-references-and-the-string-pool">Weak references and the string pool<a href="#weak-references-and-the-string-pool" class="hash-link" aria-label="Weak references and the string pool的直接链接" title="Weak references and the string pool的直接链接">​</a></h3>
<p>We are almost done collecting. There is one remaining corner of the VM that has
some unusual requirements around memory. Recall that when we added strings to
clox we made the VM intern them all. That means the VM has a hash table
containing a pointer to every single string in the heap. The VM uses this to
de-duplicate strings.</p>
<p>During the mark phase, we deliberately did <em>not</em> treat the VM&#x27;s string table as
a source of roots. If we had, no <span name="intern">string</span> would <em>ever</em>
be collected. The string table would grow and grow and never yield a single byte
of memory back to the operating system. That would be bad.</p>
<aside name="intern">
<p>This can be a real problem. Java does not intern <em>all</em> strings, but it does
intern string <em>literals</em>. It also provides an API to add strings to the string
table. For many years, the capacity of that table was fixed, and strings added
to it could never be removed. If users weren&#x27;t careful about their use of
<code>String.intern()</code>, they could run out of memory and crash.</p>
<p>Ruby had a similar problem for years where symbols -- interned string-like
values -- were not garbage collected. Both eventually enabled the GC to collect
these strings.</p>
</aside>
<p>At the same time, if we <em>do</em> let the GC free strings, then the VM&#x27;s string table
will be left with dangling pointers to freed memory. That would be even worse.</p>
<p>The string table is special and we need special support for it. In particular,
it needs a special kind of reference. The table should be able to refer to a
string, but that link should not be considered a root when determining
reachability. That implies that the referenced object can be freed. When that
happens, the dangling reference must be fixed too, sort of like a magic,
self-clearing pointer. This particular set of semantics comes up frequently
enough that it has a name: a <a href="https://en.wikipedia.org/wiki/Weak_reference" target="_blank" rel="noopener noreferrer"><strong>weak reference</strong></a>.</p>
<p>We have already implicitly implemented half of the string table&#x27;s unique
behavior by virtue of the fact that we <em>don&#x27;t</em> traverse it during marking. That
means it doesn&#x27;t force strings to be reachable. The remaining piece is clearing
out any dangling pointers for strings that are freed.</p>
<p>To remove references to unreachable strings, we need to know which strings <em>are</em>
unreachable. We don&#x27;t know that until after the mark phase has completed. But we
can&#x27;t wait until after the sweep phase is done because by then the objects --
and their mark bits -- are no longer around to check. So the right time is
exactly between the marking and sweeping phases.</p>
<p>^code sweep-strings (1 before, 1 after)</p>
<p>The logic for removing the about-to-be-deleted strings exists in a new function
in the &quot;table&quot; module.</p>
<p>^code table-remove-white-h (2 before, 2 after)</p>
<p>The implementation is here:</p>
<p>^code table-remove-white</p>
<p>We walk every entry in the table. The string intern table uses only the key of
each entry -- it&#x27;s basically a hash <em>set</em> not a hash <em>map</em>. If the key string
object&#x27;s mark bit is not set, then it is a white object that is moments from
being swept away. We delete it from the hash table first and thus ensure we
won&#x27;t see any dangling pointers.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="when-to-collect">When to Collect<a href="#when-to-collect" class="hash-link" aria-label="When to Collect的直接链接" title="When to Collect的直接链接">​</a></h2>
<p>We have a fully functioning mark-sweep garbage collector now. When the stress
testing flag is enabled, it gets called all the time, and with the logging
enabled too, we can watch it do its thing and see that it is indeed reclaiming
memory. But, when the stress testing flag is off, it never runs at all. It&#x27;s
time to decide when the collector should be invoked during normal program
execution.</p>
<p>As far as I can tell, this question is poorly answered by the literature. When
garbage collectors were first invented, computers had a tiny, fixed amount of
memory. Many of the early GC papers assumed that you set aside a few thousand
words of memory -- in other words, most of it -- and invoked the collector
whenever you ran out. Simple.</p>
<p>Modern machines have gigs of physical RAM, hidden behind the operating system&#x27;s
even larger virtual memory abstraction, which is shared among a slew of other
programs all fighting for their chunk of memory. The operating system will let
your program request as much as it wants and then page in and out from the disc
when physical memory gets full. You never really &quot;run out&quot; of memory, you just
get slower and slower.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="latency-and-throughput">Latency and throughput<a href="#latency-and-throughput" class="hash-link" aria-label="Latency and throughput的直接链接" title="Latency and throughput的直接链接">​</a></h3>
<p>It no longer makes sense to wait until you &quot;have to&quot;, to run the GC, so we need
a more subtle timing strategy. To reason about this more precisely, it&#x27;s time to
introduce two fundamental numbers used when measuring a memory manager&#x27;s
performance: <em>throughput</em> and <em>latency</em>.</p>
<p>Every managed language pays a performance price compared to explicit,
user-authored deallocation. The time spent actually freeing memory is the same,
but the GC spends cycles figuring out <em>which</em> memory to free. That is time <em>not</em>
spent running the user&#x27;s code and doing useful work. In our implementation,
that&#x27;s the entirety of the mark phase. The goal of a sophisticated garbage
collector is to minimize that overhead.</p>
<p>There are two key metrics we can use to understand that cost better:</p>
<ul>
<li>
<p><strong>Throughput</strong> is the total fraction of time spent running user code versus
doing garbage collection work. Say you run a clox program for ten seconds
and it spends a second of that inside <code>collectGarbage()</code>. That means the
throughput is 90% -- it spent 90% of the time running the program and 10%
on GC overhead.</p>
<p>Throughput is the most fundamental measure because it tracks the total cost
of collection overhead. All else being equal, you want to maximize
throughput. Up until this chapter, clox had no GC at all and thus <span name="hundred">100%</span> throughput. That&#x27;s pretty hard to beat. Of
course, it came at the slight expense of potentially running out of memory
and crashing if the user&#x27;s program ran long enough. You can look at the goal
of a GC as fixing that &quot;glitch&quot; while sacrificing as little throughput as
possible.</p>
</li>
</ul>
<aside name="hundred">
<p>Well, not <em>exactly</em> 100%. It did still put the allocated objects into a linked
list, so there was some tiny overhead for setting those pointers.</p>
</aside>
<ul>
<li>
<p><strong>Latency</strong> is the longest <em>continuous</em> chunk of time where the user&#x27;s
program is completely paused while garbage collection happens. It&#x27;s a
measure of how &quot;chunky&quot; the collector is. Latency is an entirely different
metric than throughput.</p>
<p>Consider two runs of a clox program that both take ten seconds. In the first
run, the GC kicks in once and spends a solid second in <code>collectGarbage()</code> in
one massive collection. In the second run, the GC gets invoked five times,
each for a fifth of a second. The <em>total</em> amount of time spent collecting is
still a second, so the throughput is 90% in both cases. But in the second
run, the latency is only 1/5th of a second, five times less than in the
first.</p>
</li>
</ul>
<p><span name="latency"></span></p>
<img decoding="async" loading="lazy" src="image/garbage-collection/latency-throughput.png" alt="A bar representing execution time with slices for running user code and running the GC. The largest GC slice is latency. The size of all of the user code slices is throughput." class="img_ev3q">
<aside name="latency">
<p>The bar represents the execution of a program, divided into time spent running
user code and time spent in the GC. The size of the largest single slice of time
running the GC is the latency. The size of all of the user code slices added up
is the throughput.</p>
</aside>
<p>If you like analogies, imagine your program is a bakery selling fresh-baked
bread to customers. Throughput is the total number of warm, crusty baguettes you
can serve to customers in a single day. Latency is how long the unluckiest
customer has to wait in line before they get served.</p>
<p><span name="dishwasher">Running</span> the garbage collector is like shutting
down the bakery temporarily to go through all of the dishes, sort out the dirty
from the clean, and then wash the used ones. In our analogy, we don&#x27;t have
dedicated dishwashers, so while this is going on, no baking is happening. The
baker is washing up.</p>
<aside name="dishwasher">
<p>If each person represents a thread, then an obvious optimization is to have
separate threads running garbage collection, giving you a <strong>concurrent garbage
collector</strong>. In other words, hire some dishwashers to clean while others bake.
This is how very sophisticated GCs work because it does let the bakers
-- the worker threads -- keep running user code with little interruption.</p>
<p>However, coordination is required. You don&#x27;t want a dishwasher grabbing a bowl
out of a baker&#x27;s hands! This coordination adds overhead and a lot of complexity.
Concurrent collectors are fast, but challenging to implement correctly.</p>
<img decoding="async" loading="lazy" src="image/garbage-collection/baguette.png" class="above img_ev3q" alt="Un baguette.">
</aside>
<p>Selling fewer loaves of bread a day is bad, and making any particular customer
sit and wait while you clean all the dishes is too. The goal is to maximize
throughput and minimize latency, but there is no free lunch, even inside a
bakery. Garbage collectors make different trade-offs between how much throughput
they sacrifice and latency they tolerate.</p>
<p>Being able to make these trade-offs is useful because different user programs
have different needs. An overnight batch job that is generating a report from a
terabyte of data just needs to get as much work done as fast as possible.
Throughput is queen. Meanwhile, an app running on a user&#x27;s smartphone needs to
always respond immediately to user input so that dragging on the screen feels
<span name="butter">buttery</span> smooth. The app can&#x27;t freeze for a few
seconds while the GC mucks around in the heap.</p>
<aside name="butter">
<p>Clearly the baking analogy is going to my head.</p>
</aside>
<p>As a garbage collector author, you control some of the trade-off between
throughput and latency by your choice of collection algorithm. But even within a
single algorithm, we have a lot of control over <em>how frequently</em> the collector
runs.</p>
<p>Our collector is a <span name="incremental"><strong>stop-the-world GC</strong></span> which
means the user&#x27;s program is paused until the entire garbage collection process
has completed. If we wait a long time before we run the collector, then a large
number of dead objects will accumulate. That leads to a very long pause while
the collector runs, and thus high latency. So, clearly, we want to run the
collector really frequently.</p>
<aside name="incremental">
<p>In contrast, an <strong>incremental garbage collector</strong> can do a little collection,
then run some user code, then collect a little more, and so on.</p>
</aside>
<p>But every time the collector runs, it spends some time visiting live objects.
That doesn&#x27;t really <em>do</em> anything useful (aside from ensuring that they don&#x27;t
incorrectly get deleted). Time visiting live objects is time not freeing memory
and also time not running user code. If you run the GC <em>really</em> frequently, then
the user&#x27;s program doesn&#x27;t have enough time to even generate new garbage for the
VM to collect. The VM will spend all of its time obsessively revisiting the same
set of live objects over and over, and throughput will suffer. So, clearly, we
want to run the collector really <em>in</em>frequently.</p>
<p>In fact, we want something in the middle, and the frequency of when the
collector runs is one of our main knobs for tuning the trade-off between latency
and throughput.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="self-adjusting-heap">Self-adjusting heap<a href="#self-adjusting-heap" class="hash-link" aria-label="Self-adjusting heap的直接链接" title="Self-adjusting heap的直接链接">​</a></h3>
<p>We want our GC to run frequently enough to minimize latency but infrequently
enough to maintain decent throughput. But how do we find the balance between
these when we have no idea how much memory the user&#x27;s program needs and how
often it allocates? We could pawn the problem onto the user and force them to
pick by exposing GC tuning parameters. Many VMs do this. But if we, the GC
authors, don&#x27;t know how to tune it well, odds are good most users won&#x27;t either.
They deserve a reasonable default behavior.</p>
<p>I&#x27;ll be honest with you, this is not my area of expertise. I&#x27;ve talked to a
number of professional GC hackers -- this is something you can build an entire
career on -- and read a lot of the literature, and all of the answers I got
were... vague. The strategy I ended up picking is common, pretty simple, and (I
hope!) good enough for most uses.</p>
<p>The idea is that the collector frequency automatically adjusts based on the live
size of the heap. We track the total number of bytes of managed memory that the
VM has allocated. When it goes above some threshold, we trigger a GC. After
that, we note how many bytes of memory remain -- how many were <em>not</em> freed. Then
we adjust the threshold to some value larger than that.</p>
<p>The result is that as the amount of live memory increases, we collect less
frequently in order to avoid sacrificing throughput by re-traversing the growing
pile of live objects. As the amount of live memory goes down, we collect more
frequently so that we don&#x27;t lose too much latency by waiting too long.</p>
<p>The implementation requires two new bookkeeping fields in the VM.</p>
<p>^code vm-fields (1 before, 1 after)</p>
<p>The first is a running total of the number of bytes of managed memory the VM has
allocated. The second is the threshold that triggers the next collection. We
initialize them when the VM starts up.</p>
<p>^code init-gc-fields (1 before, 2 after)</p>
<p>The starting threshold here is <span name="lab">arbitrary</span>. It&#x27;s similar
to the initial capacity we picked for our various dynamic arrays. The goal is to
not trigger the first few GCs <em>too</em> quickly but also to not wait too long. If we
had some real-world Lox programs, we could profile those to tune this. But since
all we have are toy programs, I just picked a number.</p>
<aside name="lab">
<p>A challenge with learning garbage collectors is that it&#x27;s <em>very</em> hard to
discover the best practices in an isolated lab environment. You don&#x27;t see how a
collector actually performs unless you run it on the kind of large, messy
real-world programs it is actually intended for. It&#x27;s like tuning a rally car
-- you need to take it out on the course.</p>
</aside>
<p>Every time we allocate or free some memory, we adjust the counter by that delta.</p>
<p>^code updated-bytes-allocated (1 before, 1 after)</p>
<p>When the total crosses the limit, we run the collector.</p>
<p>^code collect-on-next (2 before, 1 after)</p>
<p>Now, finally, our garbage collector actually does something when the user runs a
program without our hidden diagnostic flag enabled. The sweep phase frees
objects by calling <code>reallocate()</code>, which lowers the value of <code>bytesAllocated</code>,
so after the collection completes, we know how many live bytes remain. We adjust
the threshold of the next GC based on that.</p>
<p>^code update-next-gc (1 before, 2 after)</p>
<p>The threshold is a multiple of the heap size. This way, as the amount of memory
the program uses grows, the threshold moves farther out to limit the total time
spent re-traversing the larger live set. Like other numbers in this chapter, the
scaling factor is basically arbitrary.</p>
<p>^code heap-grow-factor (1 before, 2 after)</p>
<p>You&#x27;d want to tune this in your implementation once you had some real programs
to benchmark it on. Right now, we can at least log some of the statistics that
we have. We capture the heap size before the collection.</p>
<p>^code log-before-size (1 before, 1 after)</p>
<p>And then print the results at the end.</p>
<p>^code log-collected-amount (1 before, 1 after)</p>
<p>This way we can see how much the garbage collector accomplished while it ran.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="garbage-collection-bugs">Garbage Collection Bugs<a href="#garbage-collection-bugs" class="hash-link" aria-label="Garbage Collection Bugs的直接链接" title="Garbage Collection Bugs的直接链接">​</a></h2>
<p>In theory, we are all done now. We have a GC. It kicks in periodically, collects
what it can, and leaves the rest. If this were a typical textbook, we would wipe
the dust from our hands and bask in the soft glow of the flawless marble edifice
we have created.</p>
<p>But I aim to teach you not just the theory of programming languages but the
sometimes painful reality. I am going to roll over a rotten log and show you the
nasty bugs that live under it, and garbage collector bugs really are some of the
grossest invertebrates out there.</p>
<p>The collector&#x27;s job is to free dead objects and preserve live ones. Mistakes are
easy to make in both directions. If the VM fails to free objects that aren&#x27;t
needed, it slowly leaks memory. If it frees an object that is in use, the user&#x27;s
program can access invalid memory. These failures often don&#x27;t immediately cause
a crash, which makes it hard for us to trace backward in time to find the bug.</p>
<p>This is made harder by the fact that we don&#x27;t know when the collector will run.
Any call that eventually allocates some memory is a place in the VM where a
collection could happen. It&#x27;s like musical chairs. At any point, the GC might
stop the music. Every single heap-allocated object that we want to keep needs to
find a chair quickly -- get marked as a root or stored as a reference in some
other object -- before the sweep phase comes to kick it out of the game.</p>
<p>How is it possible for the VM to use an object later -- one that the GC itself
doesn&#x27;t see? How can the VM find it? The most common answer is through a pointer
stored in some local variable on the C stack. The GC walks the <em>VM&#x27;s</em> value and
CallFrame stacks, but the C stack is <span name="c">hidden</span> to it.</p>
<aside name="c">
<p>Our GC can&#x27;t find addresses in the C stack, but many can. Conservative garbage
collectors look all through memory, including the native stack. The most
well-known of this variety is the <a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector" target="_blank" rel="noopener noreferrer"><strong>Boehm–Demers–Weiser garbage
collector</strong></a>, usually just called the &quot;Boehm collector&quot;. (The shortest
path to fame in CS is a last name that&#x27;s alphabetically early so that it shows
up first in sorted lists of names.)</p>
<p>Many precise GCs walk the C stack too. Even those have to be careful about
pointers to live objects that exist only in <em>CPU registers</em>.</p>
</aside>
<p>In previous chapters, we wrote seemingly pointless code that pushed an object
onto the VM&#x27;s value stack, did a little work, and then popped it right back off.
Most times, I said this was for the GC&#x27;s benefit. Now you see why. The code
between pushing and popping potentially allocates memory and thus can trigger a
GC. We had to make sure the object was on the value stack so that the
collector&#x27;s mark phase would find it and keep it alive.</p>
<p>I wrote the entire clox implementation before splitting it into chapters and
writing the prose, so I had plenty of time to find all of these corners and
flush out most of these bugs. The stress testing code we put in at the beginning
of this chapter and a pretty good test suite were very helpful.</p>
<p>But I fixed only <em>most</em> of them. I left a couple in because I want to give you a
hint of what it&#x27;s like to encounter these bugs in the wild. If you enable the
stress test flag and run some toy Lox programs, you can probably stumble onto a
few. Give it a try and <em>see if you can fix any yourself</em>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="adding-to-the-constant-table">Adding to the constant table<a href="#adding-to-the-constant-table" class="hash-link" aria-label="Adding to the constant table的直接链接" title="Adding to the constant table的直接链接">​</a></h3>
<p>You are very likely to hit the first bug. The constant table each chunk owns is
a dynamic array. When the compiler adds a new constant to the current function&#x27;s
table, that array may need to grow. The constant itself may also be some
heap-allocated object like a string or a nested function.</p>
<p>The new object being added to the constant table is passed to <code>addConstant()</code>.
At that moment, the object can be found only in the parameter to that function
on the C stack. That function appends the object to the constant table. If the
table doesn&#x27;t have enough capacity and needs to grow, it calls <code>reallocate()</code>.
That in turn triggers a GC, which fails to mark the new constant object and
thus sweeps it right before we have a chance to add it to the table. Crash.</p>
<p>The fix, as you&#x27;ve seen in other places, is to push the constant onto the stack
temporarily.</p>
<p>^code add-constant-push (1 before, 1 after)</p>
<p>Once the constant table contains the object, we pop it off the stack.</p>
<p>^code add-constant-pop (1 before, 1 after)</p>
<p>When the GC is marking roots, it walks the chain of compilers and marks each of
their functions, so the new constant is reachable now. We do need an include
to call into the VM from the &quot;chunk&quot; module.</p>
<p>^code chunk-include-vm (1 before, 2 after)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="interning-strings">Interning strings<a href="#interning-strings" class="hash-link" aria-label="Interning strings的直接链接" title="Interning strings的直接链接">​</a></h3>
<p>Here&#x27;s another similar one. All strings are interned in clox, so whenever we
create a new string, we also add it to the intern table. You can see where this
is going. Since the string is brand new, it isn&#x27;t reachable anywhere. And
resizing the string pool can trigger a collection. Again, we go ahead and stash
the string on the stack first.</p>
<p>^code push-string (2 before, 1 after)</p>
<p>And then pop it back off once it&#x27;s safely nestled in the table.</p>
<p>^code pop-string (1 before, 2 after)</p>
<p>This ensures the string is safe while the table is being resized. Once it
survives that, <code>allocateString()</code> will return it to some caller which can then
take responsibility for ensuring the string is still reachable before the next
heap allocation occurs.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="concatenating-strings">Concatenating strings<a href="#concatenating-strings" class="hash-link" aria-label="Concatenating strings的直接链接" title="Concatenating strings的直接链接">​</a></h3>
<p>One last example: Over in the interpreter, the <code>OP_ADD</code> instruction can be used
to concatenate two strings. As it does with numbers, it pops the two operands
from the stack, computes the result, and pushes that new value back onto the
stack. For numbers that&#x27;s perfectly safe.</p>
<p>But concatenating two strings requires allocating a new character array on the
heap, which can in turn trigger a GC. Since we&#x27;ve already popped the operand
strings by that point, they can potentially be missed by the mark phase and get
swept away. Instead of popping them off the stack eagerly, we peek them.</p>
<p>^code concatenate-peek (1 before, 2 after)</p>
<p>That way, they are still hanging out on the stack when we create the result
string. Once that&#x27;s done, we can safely pop them off and replace them with the
result.</p>
<p>^code concatenate-pop (1 before, 1 after)</p>
<p>Those were all pretty easy, especially because I <em>showed</em> you where the fix was.
In practice, <em>finding</em> them is the hard part. All you see is an object that
<em>should</em> be there but isn&#x27;t. It&#x27;s not like other bugs where you&#x27;re looking for
the code that <em>causes</em> some problem. You&#x27;re looking for the <em>absence</em> of code
which fails to <em>prevent</em> a problem, and that&#x27;s a much harder search.</p>
<p>But, for now at least, you can rest easy. As far as I know, we&#x27;ve found all of
the collection bugs in clox, and now we have a working, robust, self-tuning,
mark-sweep garbage collector.</p>
<div class="challenges">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h2>
<ol>
<li>
<p>The Obj header struct at the top of each object now has three fields:
<code>type</code>, <code>isMarked</code>, and <code>next</code>. How much memory do those take up (on your
machine)? Can you come up with something more compact? Is there a runtime
cost to doing so?</p>
</li>
<li>
<p>When the sweep phase traverses a live object, it clears the <code>isMarked</code>
field to prepare it for the next collection cycle. Can you come up with a
more efficient approach?</p>
</li>
<li>
<p>Mark-sweep is only one of a variety of garbage collection algorithms out
there. Explore those by replacing or augmenting the current collector with
another one. Good candidates to consider are reference counting, Cheney&#x27;s
algorithm, or the Lisp 2 mark-compact algorithm.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="design-note-generational-collectors">Design Note: Generational Collectors<a href="#design-note-generational-collectors" class="hash-link" aria-label="Design Note: Generational Collectors的直接链接" title="Design Note: Generational Collectors的直接链接">​</a></h2>
<p>A collector loses throughput if it spends a long time re-visiting objects that
are still alive. But it can increase latency if it avoids collecting and
accumulates a large pile of garbage to wade through. If only there were some way
to tell which objects were likely to be long-lived and which weren&#x27;t. Then the
GC could avoid revisiting the long-lived ones as often and clean up the
ephemeral ones more frequently.</p>
<p>It turns out there kind of is. Many years ago, GC researchers gathered metrics
on the lifetime of objects in real-world running programs. They tracked every
object when it was allocated, and eventually when it was no longer needed, and
then graphed out how long objects tended to live.</p>
<p>They discovered something they called the <strong>generational hypothesis</strong>, or the
much less tactful term <strong>infant mortality</strong>. Their observation was that most
objects are very short-lived but once they survive beyond a certain age, they
tend to stick around quite a long time. The longer an object <em>has</em> lived, the
longer it likely will <em>continue</em> to live. This observation is powerful because
it gave them a handle on how to partition objects into groups that benefit from
frequent collections and those that don&#x27;t.</p>
<p>They designed a technique called <strong>generational garbage collection</strong>. It works
like this: Every time a new object is allocated, it goes into a special,
relatively small region of the heap called the &quot;nursery&quot;. Since objects tend to
die young, the garbage collector is invoked <span name="nursery">frequently</span> over the objects just in this region.</p>
<aside name="nursery">
<p>Nurseries are also usually managed using a copying collector which is faster at
allocating and freeing objects than a mark-sweep collector.</p>
</aside>
<p>Each time the GC runs over the nursery is called a &quot;generation&quot;. Any objects
that are no longer needed get freed. Those that survive are now considered one
generation older, and the GC tracks this for each object. If an object survives
a certain number of generations -- often just a single collection -- it gets
<em>tenured</em>. At this point, it is copied out of the nursery into a much larger
heap region for long-lived objects. The garbage collector runs over that region
too, but much less frequently since odds are good that most of those objects
will still be alive.</p>
<p>Generational collectors are a beautiful marriage of empirical data -- the
observation that object lifetimes are <em>not</em> evenly distributed -- and clever
algorithm design that takes advantage of that fact. They&#x27;re also conceptually
quite simple. You can think of one as just two separately tuned GCs and a pretty
simple policy for moving objects from one to the other.</p>
</div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/garbage-collection.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Craftinginterpreters/not-translated-yet/functions"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">functions</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Craftinginterpreters/not-translated-yet/global-variables"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">global-variables</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#reachability" class="table-of-contents__link toc-highlight">Reachability</a></li><li><a href="#mark-sweep-garbage-collection" class="table-of-contents__link toc-highlight">Mark-Sweep Garbage Collection</a><ul><li><a href="#collecting-garbage" class="table-of-contents__link toc-highlight">Collecting garbage</a></li><li><a href="#debug-logging" class="table-of-contents__link toc-highlight">Debug logging</a></li></ul></li><li><a href="#marking-the-roots" class="table-of-contents__link toc-highlight">Marking the Roots</a><ul><li><a href="#less-obvious-roots" class="table-of-contents__link toc-highlight">Less obvious roots</a></li></ul></li><li><a href="#tracing-object-references" class="table-of-contents__link toc-highlight">Tracing Object References</a><ul><li><a href="#the-tricolor-abstraction" class="table-of-contents__link toc-highlight">The tricolor abstraction</a></li><li><a href="#a-worklist-for-gray-objects" class="table-of-contents__link toc-highlight">A worklist for gray objects</a></li><li><a href="#processing-gray-objects" class="table-of-contents__link toc-highlight">Processing gray objects</a></li></ul></li><li><a href="#sweeping-unused-objects" class="table-of-contents__link toc-highlight">Sweeping Unused Objects</a><ul><li><a href="#weak-references-and-the-string-pool" class="table-of-contents__link toc-highlight">Weak references and the string pool</a></li></ul></li><li><a href="#when-to-collect" class="table-of-contents__link toc-highlight">When to Collect</a><ul><li><a href="#latency-and-throughput" class="table-of-contents__link toc-highlight">Latency and throughput</a></li><li><a href="#self-adjusting-heap" class="table-of-contents__link toc-highlight">Self-adjusting heap</a></li></ul></li><li><a href="#garbage-collection-bugs" class="table-of-contents__link toc-highlight">Garbage Collection Bugs</a><ul><li><a href="#adding-to-the-constant-table" class="table-of-contents__link toc-highlight">Adding to the constant table</a></li><li><a href="#interning-strings" class="table-of-contents__link toc-highlight">Interning strings</a></li><li><a href="#concatenating-strings" class="table-of-contents__link toc-highlight">Concatenating strings</a></li></ul></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li><li><a href="#design-note-generational-collectors" class="table-of-contents__link toc-highlight">Design Note: Generational Collectors</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>