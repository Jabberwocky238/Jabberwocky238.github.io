<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Craftinginterpreters/not-translated-yet/closures" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">closures | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jabberwocky238.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/closures"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="closures | My Site"><meta data-rh="true" name="description" content="As the man said, for every complex problem there&#x27;s a simple solution, and it&#x27;s"><meta data-rh="true" property="og:description" content="As the man said, for every complex problem there&#x27;s a simple solution, and it&#x27;s"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/closures"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/closures" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/closures" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0d35426a.css">
<script src="/assets/js/runtime~main.0868a236.js" defer="defer"></script>
<script src="/assets/js/main.f1c02528.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/english">English</a><button aria-label="展开侧边栏分类 &#x27;English&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/crafting-interpreter">Crafting-interpreter</a><button aria-label="折叠侧边栏分类 &#x27;Crafting-interpreter&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/welcome">Welcome</a><button aria-label="展开侧边栏分类 &#x27;Welcome&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/not-translated-yet">not-translated-yet</a><button aria-label="折叠侧边栏分类 &#x27;not-translated-yet&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-bytecode-virtual-machine">a-bytecode-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-tree-walk-interpreter">a-tree-walk-interpreter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/a-virtual-machine">a-virtual-machine</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/acknowledgements">acknowledgements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-i">appendix-i</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/appendix-ii">appendix-ii</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/backmatter">backmatter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/calls-and-functions">calls-and-functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/chunks-of-bytecode">chunks-of-bytecode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes-and-instances">classes-and-instances</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/classes">classes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/closures">closures</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/compiling-expressions">compiling-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/contents">contents</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/control-flow">control-flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/dedication">dedication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/evaluating-expressions">evaluating-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/functions">functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection">garbage-collection</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/global-variables">global-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/hash-tables">hash-tables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/inheritance">inheritance</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/jumping-back-and-forth">jumping-back-and-forth</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/local-variables">local-variables</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/methods-and-initializers">methods-and-initializers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/optimization">optimization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/parsing-expressions">parsing-expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/representing-code">representing-code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/resolving-and-binding">resolving-and-binding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning-on-demand">scanning-on-demand</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/scanning">scanning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/statements-and-state">statements-and-state</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/strings">strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/superclasses">superclasses</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/the-lox-language">the-lox-language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Craftinginterpreters/not-translated-yet/types-of-values">types-of-values</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/crafting-interpreter"><span itemprop="name">Crafting-interpreter</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/not-translated-yet"><span itemprop="name">not-translated-yet</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">closures</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>closures</h1></header><blockquote>
<p>As the man said, for every complex problem there&#x27;s a simple solution, and it&#x27;s
wrong.</p>
<p><cite>Umberto Eco, <em>Foucault&#x27;s Pendulum</em></cite></p>
</blockquote>
<p>Thanks to our diligent labor in <a href="/docs/Craftinginterpreters/not-translated-yet/calls-and-functions.html">the last chapter</a>, we have a virtual
machine with working functions. What it lacks is closures. Aside from global
variables, which are their own breed of animal, a function has no way to
reference a variable declared outside of its own body.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var x = &quot;global&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = &quot;outer&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  inner();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">outer();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Run this example now and it prints &quot;global&quot;. It&#x27;s supposed to print &quot;outer&quot;. To
fix this, we need to include the entire lexical scope of all surrounding
functions when resolving a variable.</p>
<p>This problem is harder in clox than it was in jlox because our bytecode VM
stores locals on a stack. We used a stack because I claimed locals have stack
semantics -- variables are discarded in the reverse order that they are created.
But with closures, that&#x27;s only <em>mostly</em> true.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun makeClosure() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var local = &quot;local&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun closure() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print local;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return closure;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var closure = makeClosure();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closure();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The outer function <code>makeClosure()</code> declares a variable, <code>local</code>. It also creates
an inner function, <code>closure()</code> that captures that variable. Then <code>makeClosure()</code>
returns a reference to that function. Since the closure <span name="flying">escapes</span> while holding on to the local variable, <code>local</code> must
outlive the function call where it was created.</p>
<aside name="flying">
<img decoding="async" loading="lazy" src="image/closures/flying.png" class="above img_ev3q" alt="A local variable flying away from the stack.">
<p>Oh no, it&#x27;s escaping!</p>
</aside>
<p>We could solve this problem by dynamically allocating memory for all local
variables. That&#x27;s what jlox does by putting everything in those Environment
objects that float around in Java&#x27;s heap. But we don&#x27;t want to. Using a <span name="stack">stack</span> is <em>really</em> fast. Most local variables are <em>not</em>
captured by closures and do have stack semantics. It would suck to make all of
those slower for the benefit of the rare local that is captured.</p>
<aside name="stack">
<p>There is a reason that C and Java use the stack for their local variables, after
all.</p>
</aside>
<p>This means a more complex approach than we used in our Java interpreter. Because
some locals have very different lifetimes, we will have two implementation
strategies. For locals that aren&#x27;t used in closures, we&#x27;ll keep them just as
they are on the stack. When a local is captured by a closure, we&#x27;ll adopt
another solution that lifts them onto the heap where they can live as long as
needed.</p>
<p>Closures have been around since the early Lisp days when bytes of memory and CPU
cycles were more precious than emeralds. Over the intervening decades, hackers
devised all <span name="lambda">manner</span> of ways to compile closures to
optimized runtime representations. Some are more efficient but require a more
complex compilation process than we could easily retrofit into clox.</p>
<aside name="lambda">
<p>Search for &quot;closure conversion&quot; or &quot;lambda lifting&quot; to start exploring.</p>
</aside>
<p>The technique I explain here comes from the design of the Lua VM. It is fast,
parsimonious with memory, and implemented with relatively little code. Even more
impressive, it fits naturally into the single-pass compilers clox and Lua both
use. It is somewhat intricate, though. It might take a while before all the
pieces click together in your mind. We&#x27;ll build them one step at a time, and
I&#x27;ll try to introduce the concepts in stages.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="closure-objects">Closure Objects<a href="#closure-objects" class="hash-link" aria-label="Closure Objects的直接链接" title="Closure Objects的直接链接">​</a></h2>
<p>Our VM represents functions at runtime using ObjFunction. These objects are
created by the front end during compilation. At runtime, all the VM does is load
the function object from a constant table and bind it to a name. There is no
operation to &quot;create&quot; a function at runtime. Much like string and number <span name="literal">literals</span>, they are constants instantiated purely at
compile time.</p>
<aside name="literal">
<p>In other words, a function declaration in Lox <em>is</em> a kind of literal -- a piece
of syntax that defines a constant value of a built-in type.</p>
</aside>
<p>That made sense because all of the data that composes a function is known at
compile time: the chunk of bytecode compiled from the function&#x27;s body, and the
constants used in the body. Once we introduce closures, though, that
representation is no longer sufficient. Take a gander at:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun makeClosure(value) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun closure() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print value;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return closure;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var doughnut = makeClosure(&quot;doughnut&quot;);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var bagel = makeClosure(&quot;bagel&quot;);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">doughnut();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">bagel();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The <code>makeClosure()</code> function defines and returns a function. We call it twice
and get two closures back. They are created by the same nested function
declaration, <code>closure</code>, but close over different values. When we call the two
closures, each prints a different string. That implies we need some runtime
representation for a closure that captures the local variables surrounding the
function as they exist when the function declaration is <em>executed</em>, not just
when it is compiled.</p>
<p>We&#x27;ll work our way up to capturing variables, but a good first step is defining
that object representation. Our existing ObjFunction type represents the <span name="raw">&quot;raw&quot;</span> compile-time state of a function declaration, since all
closures created from a single declaration share the same code and constants. At
runtime, when we execute a function declaration, we wrap the ObjFunction in a
new ObjClosure structure. The latter has a reference to the underlying bare
function along with runtime state for the variables the function closes over.</p>
<aside name="raw">
<p>The Lua implementation refers to the raw function object containing the bytecode
as a &quot;prototype&quot;, which is a great word to describe this, except that word also
gets overloaded to refer to <a href="https://en.wikipedia.org/wiki/Prototype-based_programming" target="_blank" rel="noopener noreferrer">prototypal inheritance</a>.</p>
</aside>
<img decoding="async" loading="lazy" src="image/closures/obj-closure.png" alt="An ObjClosure with a reference to an ObjFunction." class="img_ev3q">
<p>We&#x27;ll wrap every function in an ObjClosure, even if the function doesn&#x27;t
actually close over and capture any surrounding local variables. This is a
little wasteful, but it simplifies the VM because we can always assume that the
function we&#x27;re calling is an ObjClosure. That new struct starts out like this:</p>
<p>^code obj-closure</p>
<p>Right now, it simply points to an ObjFunction and adds the necessary object
header stuff. Grinding through the usual ceremony for adding a new object type
to clox, we declare a C function to create a new closure.</p>
<p>^code new-closure-h (2 before, 1 after)</p>
<p>Then we implement it here:</p>
<p>^code new-closure</p>
<p>It takes a pointer to the ObjFunction it wraps. It also initializes the type
field to a new type.</p>
<p>^code obj-type-closure (1 before, 1 after)</p>
<p>And when we&#x27;re done with a closure, we release its memory.</p>
<p>^code free-closure (1 before, 1 after)</p>
<p>We free only the ObjClosure itself, not the ObjFunction. That&#x27;s because the
closure doesn&#x27;t <em>own</em> the function. There may be multiple closures that all
reference the same function, and none of them claims any special privilege over
it. We can&#x27;t free the ObjFunction until <em>all</em> objects referencing it are gone --
including even the surrounding function whose constant table contains it.
Tracking that sounds tricky, and it is! That&#x27;s why we&#x27;ll write a garbage
collector soon to manage it for us.</p>
<p>We also have the usual <span name="macro">macros</span> for checking a value&#x27;s
type.</p>
<aside name="macro">
<p>Perhaps I should have defined a macro to make it easier to generate these
macros. Maybe that would be a little too meta.</p>
</aside>
<p>^code is-closure (2 before, 1 after)</p>
<p>And to cast a value:</p>
<p>^code as-closure (2 before, 1 after)</p>
<p>Closures are first-class objects, so you can print them.</p>
<p>^code print-closure (1 before, 1 after)</p>
<p>They display exactly as ObjFunction does. From the user&#x27;s perspective, the
difference between ObjFunction and ObjClosure is purely a hidden implementation
detail. With that out of the way, we have a working but empty representation for
closures.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="compiling-to-closure-objects">Compiling to closure objects<a href="#compiling-to-closure-objects" class="hash-link" aria-label="Compiling to closure objects的直接链接" title="Compiling to closure objects的直接链接">​</a></h3>
<p>We have closure objects, but our VM never creates them. The next step is getting
the compiler to emit instructions to tell the runtime when to create a new
ObjClosure to wrap a given ObjFunction. This happens right at the end of a
function declaration.</p>
<p>^code emit-closure (1 before, 1 after)</p>
<p>Before, the final bytecode for a function declaration was a single <code>OP_CONSTANT</code>
instruction to load the compiled function from the surrounding function&#x27;s
constant table and push it onto the stack. Now we have a new instruction.</p>
<p>^code closure-op (1 before, 1 after)</p>
<p>Like <code>OP_CONSTANT</code>, it takes a single operand that represents a constant table
index for the function. But when we get over to the runtime implementation, we
do something more interesting.</p>
<p>First, let&#x27;s be diligent VM hackers and slot in disassembler support for the
instruction.</p>
<p>^code disassemble-closure (2 before, 1 after)</p>
<p>There&#x27;s more going on here than we usually have in the disassembler. By the end
of the chapter, you&#x27;ll discover that <code>OP_CLOSURE</code> is quite an unusual
instruction. It&#x27;s straightforward right now -- just a single byte operand -- but
we&#x27;ll be adding to it. This code here anticipates that future.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="interpreting-function-declarations">Interpreting function declarations<a href="#interpreting-function-declarations" class="hash-link" aria-label="Interpreting function declarations的直接链接" title="Interpreting function declarations的直接链接">​</a></h3>
<p>Most of the work we need to do is in the runtime. We have to handle the new
instruction, naturally. But we also need to touch every piece of code in the VM
that works with ObjFunction and change it to use ObjClosure instead -- function
calls, call frames, etc. We&#x27;ll start with the instruction, though.</p>
<p>^code interpret-closure (1 before, 1 after)</p>
<p>Like the <code>OP_CONSTANT</code> instruction we used before, first we load the compiled
function from the constant table. The difference now is that we wrap that
function in a new ObjClosure and push the result onto the stack.</p>
<p>Once you have a closure, you&#x27;ll eventually want to call it.</p>
<p>^code call-value-closure (1 before, 1 after)</p>
<p>We remove the code for calling objects whose type is <code>OBJ_FUNCTION</code>. Since we
wrap all functions in ObjClosures, the runtime will never try to invoke a bare
ObjFunction anymore. Those objects live only in constant tables and get
immediately <span name="naked">wrapped</span> in closures before anything else
sees them.</p>
<aside name="naked">
<p>We don&#x27;t want any naked functions wandering around the VM! What would the
neighbors say?</p>
</aside>
<p>We replace the old code with very similar code for calling a closure instead.
The only difference is the type of object we pass to <code>call()</code>. The real changes
are over in that function. First, we update its signature.</p>
<p>^code call-signature (1 after)</p>
<p>Then, in the body, we need to fix everything that referenced the function to
handle the fact that we&#x27;ve introduced a layer of indirection. We start with the
arity checking:</p>
<p>^code check-arity (1 before, 1 after)</p>
<p>The only change is that we unwrap the closure to get to the underlying function.
The next thing <code>call()</code> does is create a new CallFrame. We change that code to
store the closure in the CallFrame and get the bytecode pointer from the
closure&#x27;s function.</p>
<p>^code call-init-closure (1 before, 1 after)</p>
<p>This necessitates changing the declaration of CallFrame too.</p>
<p>^code call-frame-closure (1 before, 1 after)</p>
<p>That change triggers a few other cascading changes. Every place in the VM that
accessed CallFrame&#x27;s function needs to use a closure instead. First, the macro
for reading a constant from the current function&#x27;s constant table:</p>
<p>^code read-constant (2 before, 2 after)</p>
<p>When <code>DEBUG_TRACE_EXECUTION</code> is enabled, it needs to get to the chunk from the
closure.</p>
<p>^code disassemble-instruction (1 before, 1 after)</p>
<p>Likewise when reporting a runtime error:</p>
<p>^code runtime-error-function (1 before, 1 after)</p>
<p>Almost there. The last piece is the blob of code that sets up the very first
CallFrame to begin executing the top-level code for a Lox script.</p>
<p>^code interpret (1 before, 2 after)</p>
<p><span name="pop">The</span> compiler still returns a raw ObjFunction when
compiling a script. That&#x27;s fine, but it means we need to wrap it in an
ObjClosure here, before the VM can execute it.</p>
<aside name="pop">
<p>The code looks a little silly because we still push the original ObjFunction
onto the stack. Then we pop it after creating the closure, only to then push the
closure. Why put the ObjFunction on there at all? As usual, when you see weird
stack stuff going on, it&#x27;s to keep the <a href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection.html">forthcoming garbage collector</a> aware
of some heap-allocated objects.</p>
</aside>
<p>We are back to a working interpreter. The <em>user</em> can&#x27;t tell any difference, but
the compiler now generates code telling the VM to create a closure for each
function declaration. Every time the VM executes a function declaration, it
wraps the ObjFunction in a new ObjClosure. The rest of the VM now handles those
ObjClosures floating around. That&#x27;s the boring stuff out of the way. Now we&#x27;re
ready to make these closures actually <em>do</em> something.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="upvalues">Upvalues<a href="#upvalues" class="hash-link" aria-label="Upvalues的直接链接" title="Upvalues的直接链接">​</a></h2>
<p>Our existing instructions for reading and writing local variables are limited to
a single function&#x27;s stack window. Locals from a surrounding function are outside
of the inner function&#x27;s window. We&#x27;re going to need some new instructions.</p>
<p>The easiest approach might be an instruction that takes a relative stack slot
offset that can reach <em>before</em> the current function&#x27;s window. That would work if
closed-over variables were always on the stack. But as we saw earlier, these
variables sometimes outlive the function where they are declared. That means
they won&#x27;t always be on the stack.</p>
<p>The next easiest approach, then, would be to take any local variable that gets
closed over and have it always live on the heap. When the local variable
declaration in the surrounding function is executed, the VM would allocate
memory for it dynamically. That way it could live as long as needed.</p>
<p>This would be a fine approach if clox didn&#x27;t have a single-pass compiler. But
that restriction we chose in our implementation makes things harder. Take a look
at this example:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = 1;    // (1)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  x = 2;        // (2)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun inner() { // (3)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  inner();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Here, the compiler compiles the declaration of <code>x</code> at <code>(1)</code> and emits code for
the assignment at <code>(2)</code>. It does that before reaching the declaration of
<code>inner()</code> at <code>(3)</code> and discovering that <code>x</code> is in fact closed over. We don&#x27;t
have an easy way to go back and fix that already-emitted code to treat <code>x</code>
specially. Instead, we want a solution that allows a closed-over variable to
live on the stack exactly like a normal local variable <em>until the point that it
is closed over</em>.</p>
<p>Fortunately, thanks to the Lua dev team, we have a solution. We use a level of
indirection that they call an <strong>upvalue</strong>. An upvalue refers to a local variable
in an enclosing function. Every closure maintains an array of upvalues, one for
each surrounding local variable that the closure uses.</p>
<p>The upvalue points back into the stack to where the variable it captured lives.
When the closure needs to access a closed-over variable, it goes through the
corresponding upvalue to reach it. When a function declaration is first executed
and we create a closure for it, the VM creates the array of upvalues and wires
them up to &quot;capture&quot; the surrounding local variables that the closure needs.</p>
<p>For example, if we throw this program at clox,</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun f() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>the compiler and runtime will conspire together to build up a set of objects in
memory like this:</p>
<img decoding="async" loading="lazy" src="image/closures/open-upvalue.png" alt="The object graph of the stack, ObjClosure, ObjFunction, and upvalue array." class="img_ev3q">
<p>That might look overwhelming, but fear not. We&#x27;ll work our way through it. The
important part is that upvalues serve as the layer of indirection needed to
continue to find a captured local variable even after it moves off the stack.
But before we get to all that, let&#x27;s focus on compiling captured variables.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="compiling-upvalues">Compiling upvalues<a href="#compiling-upvalues" class="hash-link" aria-label="Compiling upvalues的直接链接" title="Compiling upvalues的直接链接">​</a></h3>
<p>As usual, we want to do as much work as possible during compilation to keep
execution simple and fast. Since local variables are lexically scoped in Lox, we
have enough knowledge at compile time to resolve which surrounding local
variables a function accesses and where those locals are declared. That, in
turn, means we know <em>how many</em> upvalues a closure needs, <em>which</em> variables they
capture, and <em>which stack slots</em> contain those variables in the declaring
function&#x27;s stack window.</p>
<p>Currently, when the compiler resolves an identifier, it walks the block scopes
for the current function from innermost to outermost. If we don&#x27;t find the
variable in that function, we assume the variable must be a global. We don&#x27;t
consider the local scopes of enclosing functions -- they get skipped right over.
The first change, then, is inserting a resolution step for those outer local
scopes.</p>
<p>^code named-variable-upvalue (3 before, 1 after)</p>
<p>This new <code>resolveUpvalue()</code> function looks for a local variable declared in any
of the surrounding functions. If it finds one, it returns an &quot;upvalue index&quot; for
that variable. (We&#x27;ll get into what that means later.) Otherwise, it returns -1
to indicate the variable wasn&#x27;t found. If it was found, we use these two new
instructions for reading or writing to the variable through its upvalue:</p>
<p>^code upvalue-ops (1 before, 1 after)</p>
<p>We&#x27;re implementing this sort of top-down, so I&#x27;ll show you how these work at
runtime soon. The part to focus on now is how the compiler actually resolves the
identifier.</p>
<p>^code resolve-upvalue</p>
<p>We call this after failing to resolve a local variable in the current function&#x27;s
scope, so we know the variable isn&#x27;t in the current compiler. Recall that
Compiler stores a pointer to the Compiler for the enclosing function, and these
pointers form a linked chain that goes all the way to the root Compiler for the
top-level code. Thus, if the enclosing Compiler is <code>NULL</code>, we know we&#x27;ve reached
the outermost function without finding a local variable. The variable must be
<span name="undefined">global</span>, so we return -1.</p>
<aside name="undefined">
<p>It might end up being an entirely undefined variable and not even global. But in
Lox, we don&#x27;t detect that error until runtime, so from the compiler&#x27;s
perspective, it&#x27;s &quot;hopefully global&quot;.</p>
</aside>
<p>Otherwise, we try to resolve the identifier as a <em>local</em> variable in the
<em>enclosing</em> compiler. In other words, we look for it right outside the current
function. For example:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print x; // (1)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  inner();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>When compiling the identifier expression at <code>(1)</code>, <code>resolveUpvalue()</code> looks for
a local variable <code>x</code> declared in <code>outer()</code>. If found -- like it is in this
example -- then we&#x27;ve successfully resolved the variable. We create an upvalue
so that the inner function can access the variable through that. The upvalue is
created here:</p>
<p>^code add-upvalue</p>
<p>The compiler keeps an array of upvalue structures to track the closed-over
identifiers that it has resolved in the body of each function. Remember how the
compiler&#x27;s Local array mirrors the stack slot indexes where locals live at
runtime? This new upvalue array works the same way. The indexes in the
compiler&#x27;s array match the indexes where upvalues will live in the ObjClosure at
runtime.</p>
<p>This function adds a new upvalue to that array. It also keeps track of the
number of upvalues the function uses. It stores that count directly in the
ObjFunction itself because we&#x27;ll also <span name="bridge">need</span> that
number for use at runtime.</p>
<aside name="bridge">
<p>Like constants and function arity, the upvalue count is another one of those
little pieces of data that form the bridge between the compiler and runtime.</p>
</aside>
<p>The <code>index</code> field tracks the closed-over local variable&#x27;s slot index. That way
the compiler knows <em>which</em> variable in the enclosing function needs to be
captured. We&#x27;ll circle back to what that <code>isLocal</code> field is for before too long.
Finally, <code>addUpvalue()</code> returns the index of the created upvalue in the
function&#x27;s upvalue list. That index becomes the operand to the <code>OP_GET_UPVALUE</code>
and <code>OP_SET_UPVALUE</code> instructions.</p>
<p>That&#x27;s the basic idea for resolving upvalues, but the function isn&#x27;t fully
baked. A closure may reference the same variable in a surrounding function
multiple times. In that case, we don&#x27;t want to waste time and memory creating a
separate upvalue for each identifier expression. To fix that, before we add a
new upvalue, we first check to see if the function already has an upvalue that
closes over that variable.</p>
<p>^code existing-upvalue (1 before, 1 after)</p>
<p>If we find an upvalue in the array whose slot index matches the one we&#x27;re
adding, we just return that <em>upvalue</em> index and reuse it. Otherwise, we fall
through and add the new upvalue.</p>
<p>These two functions access and modify a bunch of new state, so let&#x27;s define
that. First, we add the upvalue count to ObjFunction.</p>
<p>^code upvalue-count (1 before, 1 after)</p>
<p>We&#x27;re conscientious C programmers, so we zero-initialize that when an
ObjFunction is first allocated.</p>
<p>^code init-upvalue-count (1 before, 1 after)</p>
<p>In the compiler, we add a field for the upvalue array.</p>
<p>^code upvalues-array (1 before, 1 after)</p>
<p>For simplicity, I gave it a fixed size. The <code>OP_GET_UPVALUE</code> and
<code>OP_SET_UPVALUE</code> instructions encode an upvalue index using a single byte
operand, so there&#x27;s a restriction on how many upvalues a function can have --
how many unique variables it can close over. Given that, we can afford a static
array that large. We also need to make sure the compiler doesn&#x27;t overflow that
limit.</p>
<p>^code too-many-upvalues (5 before, 1 after)</p>
<p>Finally, the Upvalue struct type itself.</p>
<p>^code upvalue-struct</p>
<p>The <code>index</code> field stores which local slot the upvalue is capturing. The
<code>isLocal</code> field deserves its own section, which we&#x27;ll get to next.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="flattening-upvalues">Flattening upvalues<a href="#flattening-upvalues" class="hash-link" aria-label="Flattening upvalues的直接链接" title="Flattening upvalues的直接链接">​</a></h3>
<p>In the example I showed before, the closure is accessing a variable declared in
the immediately enclosing function. Lox also supports accessing local variables
declared in <em>any</em> enclosing scope, as in:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun middle() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      print x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Here, we&#x27;re accessing <code>x</code> in <code>inner()</code>. That variable is defined not in
<code>middle()</code>, but all the way out in <code>outer()</code>. We need to handle cases like this
too. You <em>might</em> think that this isn&#x27;t much harder since the variable will
simply be somewhere farther down on the stack. But consider this <span name="devious">devious</span> example:</p>
<aside name="devious">
<p>If you work on programming languages long enough, you will develop a
finely honed skill at creating bizarre programs like this that are technically
valid but likely to trip up an implementation written by someone with a less
perverse imagination than you.</p>
</aside>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = &quot;value&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun middle() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      print x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print &quot;create inner closure&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return inner;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print &quot;return from outer&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return middle;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var mid = outer();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var in = mid();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">in();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>When you run this, it should print:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">return from outer</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">create inner closure</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">value</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>I know, it&#x27;s convoluted. The important part is that <code>outer()</code> -- where <code>x</code> is
declared -- returns and pops all of its variables off the stack before the
<em>declaration</em> of <code>inner()</code> executes. So, at the point in time that we create the
closure for <code>inner()</code>, <code>x</code> is already off the stack.</p>
<p>Here, I traced out the execution flow for you:</p>
<img decoding="async" loading="lazy" src="image/closures/execution-flow.png" alt="Tracing through the previous example program." class="img_ev3q">
<p>See how <code>x</code> is popped ① before it is captured ② and then later
accessed ③? We really have two problems:</p>
<ol>
<li>
<p>We need to resolve local variables that are declared in surrounding
functions beyond the immediately enclosing one.</p>
</li>
<li>
<p>We need to be able to capture variables that have already left the stack.</p>
</li>
</ol>
<p>Fortunately, we&#x27;re in the middle of adding upvalues to the VM, and upvalues are
explicitly designed for tracking variables that have escaped the stack. So, in a
clever bit of self-reference, we can use upvalues to allow upvalues to capture
variables declared outside of the immediately surrounding function.</p>
<p>The solution is to allow a closure to capture either a local variable or <em>an
existing upvalue</em> in the immediately enclosing function. If a deeply nested
function references a local variable declared several hops away, we&#x27;ll thread it
through all of the intermediate functions by having each function capture an
upvalue for the next function to grab.</p>
<img decoding="async" loading="lazy" src="image/closures/linked-upvalues.png" alt="An upvalue in inner() points to an upvalue in middle(), which points to a local variable in outer()." class="img_ev3q">
<p>In the above example, <code>middle()</code> captures the local variable <code>x</code> in the
immediately enclosing function <code>outer()</code> and stores it in its own upvalue. It
does this even though <code>middle()</code> itself doesn&#x27;t reference <code>x</code>. Then, when the
declaration of <code>inner()</code> executes, its closure grabs the <em>upvalue</em> from the
ObjClosure for <code>middle()</code> that captured <code>x</code>. A function captures -- either a
local or upvalue -- <em>only</em> from the immediately surrounding function, which is
guaranteed to still be around at the point that the inner function declaration
executes.</p>
<p>In order to implement this, <code>resolveUpvalue()</code> becomes recursive.</p>
<p>^code resolve-upvalue-recurse (4 before, 1 after)</p>
<p>It&#x27;s only another three lines of code, but I found this function really
challenging to get right the first time. This in spite of the fact that I wasn&#x27;t
inventing anything new, just porting the concept over from Lua. Most recursive
functions either do all their work before the recursive call (a <strong>pre-order
traversal</strong>, or &quot;on the way down&quot;), or they do all the work after the recursive
call (a <strong>post-order traversal</strong>, or &quot;on the way back up&quot;). This function does
both. The recursive call is right in the middle.</p>
<p>We&#x27;ll walk through it slowly. First, we look for a matching local variable in
the enclosing function. If we find one, we capture that local and return. That&#x27;s
the <span name="base">base</span> case.</p>
<aside name="base">
<p>The other base case, of course, is if there is no enclosing function. In that
case, the variable can&#x27;t be resolved lexically and is treated as global.</p>
</aside>
<p>Otherwise, we look for a local variable beyond the immediately enclosing
function. We do that by recursively calling <code>resolveUpvalue()</code> on the
<em>enclosing</em> compiler, not the current one. This series of <code>resolveUpvalue()</code>
calls works its way along the chain of nested compilers until it hits one of
the base cases -- either it finds an actual local variable to capture or it
runs out of compilers.</p>
<p>When a local variable is found, the most deeply <span name="outer">nested</span>
call to <code>resolveUpvalue()</code> captures it and returns the upvalue index. That
returns to the next call for the inner function declaration. That call captures
the <em>upvalue</em> from the surrounding function, and so on. As each nested call to
<code>resolveUpvalue()</code> returns, we drill back down into the innermost function
declaration where the identifier we are resolving appears. At each step along
the way, we add an upvalue to the intervening function and pass the resulting
upvalue index down to the next call.</p>
<aside name="outer">
<p>Each recursive call to <code>resolveUpvalue()</code> walks <em>out</em> one level of function
nesting. So an inner <em>recursive call</em> refers to an <em>outer</em> nested declaration.
The innermost recursive call to <code>resolveUpvalue()</code> that finds the local variable
will be for the <em>outermost</em> function, just inside the enclosing function where
that variable is actually declared.</p>
</aside>
<p>It might help to walk through the original example when resolving <code>x</code>:</p>
<img decoding="async" loading="lazy" src="image/closures/recursion.png" alt="Tracing through a recursive call to resolveUpvalue()." class="img_ev3q">
<p>Note that the new call to <code>addUpvalue()</code> passes <code>false</code> for the <code>isLocal</code>
parameter. Now you see that that flag controls whether the closure captures a
local variable or an upvalue from the surrounding function.</p>
<p>By the time the compiler reaches the end of a function declaration, every
variable reference has been resolved as either a local, an upvalue, or a global.
Each upvalue may in turn capture a local variable from the surrounding function,
or an upvalue in the case of transitive closures. We finally have enough data to
emit bytecode which creates a closure at runtime that captures all of the
correct variables.</p>
<p>^code capture-upvalues (1 before, 1 after)</p>
<p>The <code>OP_CLOSURE</code> instruction is unique in that it has a variably sized encoding.
For each upvalue the closure captures, there are two single-byte operands. Each
pair of operands specifies what that upvalue captures. If the first byte is one,
it captures a local variable in the enclosing function. If zero, it captures one
of the function&#x27;s upvalues. The next byte is the local slot or upvalue index to
capture.</p>
<p>This odd encoding means we need some bespoke support in the disassembly code
for <code>OP_CLOSURE</code>.</p>
<p>^code disassemble-upvalues (1 before, 1 after)</p>
<p>For example, take this script:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var b = 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun middle() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var c = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var d = 4;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      print a + c + b + d;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>If we disassemble the instruction that creates the closure for <code>inner()</code>, it
prints this:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">0004    9 OP_CLOSURE          2 &lt;fn inner&gt;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">0006      |                     upvalue 0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">0008      |                     local 1</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">0010      |                     upvalue 1</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">0012      |                     local 2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We have two other, simpler instructions to add disassembler support for.</p>
<p>^code disassemble-upvalue-ops (2 before, 1 after)</p>
<p>These both have a single-byte operand, so there&#x27;s nothing exciting going on. We
do need to add an include so the debug module can get to <code>AS_FUNCTION()</code>.</p>
<p>^code debug-include-object (1 before, 1 after)</p>
<p>With that, our compiler is where we want it. For each function declaration, it
outputs an <code>OP_CLOSURE</code> instruction followed by a series of operand byte pairs
for each upvalue it needs to capture at runtime. It&#x27;s time to hop over to that
side of the VM and get things running.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="upvalue-objects">Upvalue Objects<a href="#upvalue-objects" class="hash-link" aria-label="Upvalue Objects的直接链接" title="Upvalue Objects的直接链接">​</a></h2>
<p>Each <code>OP_CLOSURE</code> instruction is now followed by the series of bytes that
specify the upvalues the ObjClosure should own. Before we process those
operands, we need a runtime representation for upvalues.</p>
<p>^code obj-upvalue</p>
<p>We know upvalues must manage closed-over variables that no longer live on the
stack, which implies some amount of dynamic allocation. The easiest way to do
that in our VM is by building on the object system we already have. That way,
when we implement a garbage collector in <a href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection.html">the next chapter</a>, the GC can
manage memory for upvalues too.</p>
<p>Thus, our runtime upvalue structure is an ObjUpvalue with the typical Obj header
field. Following that is a <code>location</code> field that points to the closed-over
variable. Note that this is a <em>pointer</em> to a Value, not a Value itself. It&#x27;s a
reference to a <em>variable</em>, not a <em>value</em>. This is important because it means
that when we assign to the variable the upvalue captures, we&#x27;re assigning to the
actual variable, not a copy. For example:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = &quot;before&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x = &quot;assigned&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  inner();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  print x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">outer();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>This program should print &quot;assigned&quot; even though the closure assigns to <code>x</code> and
the surrounding function accesses it.</p>
<p>Because upvalues are objects, we&#x27;ve got all the usual object machinery, starting
with a constructor-like function:</p>
<p>^code new-upvalue-h (1 before, 1 after)</p>
<p>It takes the address of the slot where the closed-over variable lives. Here is
the implementation:</p>
<p>^code new-upvalue</p>
<p>We simply initialize the object and store the pointer. That requires a new
object type.</p>
<p>^code obj-type-upvalue (1 before, 1 after)</p>
<p>And on the back side, a destructor-like function:</p>
<p>^code free-upvalue (3 before, 1 after)</p>
<p>Multiple closures can close over the same variable, so ObjUpvalue does not own
the variable it references. Thus, the only thing to free is the ObjUpvalue
itself.</p>
<p>And, finally, to print:</p>
<p>^code print-upvalue (3 before, 1 after)</p>
<p>Printing isn&#x27;t useful to end users. Upvalues are objects only so that we can
take advantage of the VM&#x27;s memory management. They aren&#x27;t first-class values
that a Lox user can directly access in a program. So this code will never
actually execute... but it keeps the compiler from yelling at us about an
unhandled switch case, so here we are.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="upvalues-in-closures">Upvalues in closures<a href="#upvalues-in-closures" class="hash-link" aria-label="Upvalues in closures的直接链接" title="Upvalues in closures的直接链接">​</a></h3>
<p>When I first introduced upvalues, I said each closure has an array of them.
We&#x27;ve finally worked our way back to implementing that.</p>
<p>^code upvalue-fields (1 before, 1 after)</p>
<p><span name="count">Different</span> closures may have different numbers of
upvalues, so we need a dynamic array. The upvalues themselves are dynamically
allocated too, so we end up with a double pointer -- a pointer to a dynamically
allocated array of pointers to upvalues. We also store the number of elements in
the array.</p>
<aside name="count">
<p>Storing the upvalue count in the closure is redundant because the ObjFunction
that the ObjClosure references also keeps that count. As usual, this weird code
is to appease the GC. The collector may need to know an ObjClosure&#x27;s upvalue
array size after the closure&#x27;s corresponding ObjFunction has already been freed.</p>
</aside>
<p>When we create an ObjClosure, we allocate an upvalue array of the proper size,
which we determined at compile time and stored in the ObjFunction.</p>
<p>^code allocate-upvalue-array (1 before, 1 after)</p>
<p>Before creating the closure object itself, we allocate the array of upvalues and
initialize them all to <code>NULL</code>. This weird ceremony around memory is a careful
dance to please the (forthcoming) garbage collection deities. It ensures the
memory manager never sees uninitialized memory.</p>
<p>Then we store the array in the new closure, as well as copy the count over from
the ObjFunction.</p>
<p>^code init-upvalue-fields (1 before, 1 after)</p>
<p>When we free an ObjClosure, we also free the upvalue array.</p>
<p>^code free-upvalues (1 before, 1 after)</p>
<p>ObjClosure does not own the ObjUpvalue objects themselves, but it does own <em>the
array</em> containing pointers to those upvalues.</p>
<p>We fill the upvalue array over in the interpreter when it creates a closure.
This is where we walk through all of the operands after <code>OP_CLOSURE</code> to see what
kind of upvalue each slot captures.</p>
<p>^code interpret-capture-upvalues (1 before, 1 after)</p>
<p>This code is the magic moment when a closure comes to life. We iterate over each
upvalue the closure expects. For each one, we read a pair of operand bytes. If
the upvalue closes over a local variable in the enclosing function, we let
<code>captureUpvalue()</code> do the work.</p>
<p>Otherwise, we capture an upvalue from the surrounding function. An <code>OP_CLOSURE</code>
instruction is emitted at the end of a function declaration. At the moment that
we are executing that declaration, the <em>current</em> function is the surrounding
one. That means the current function&#x27;s closure is stored in the CallFrame at the
top of the callstack. So, to grab an upvalue from the enclosing function, we can
read it right from the <code>frame</code> local variable, which caches a reference to that
CallFrame.</p>
<p>Closing over a local variable is more interesting. Most of the work happens in a
separate function, but first we calculate the argument to pass to it. We need to
grab a pointer to the captured local&#x27;s slot in the surrounding function&#x27;s stack
window. That window begins at <code>frame-&gt;slots</code>, which points to slot zero. Adding
<code>index</code> offsets that to the local slot we want to capture. We pass that pointer
here:</p>
<p>^code capture-upvalue</p>
<p>This seems a little silly. All it does is create a new ObjUpvalue that captures
the given stack slot and returns it. Did we need a separate function for this?
Well, no, not <em>yet</em>. But you know we are going to end up sticking more code in
here.</p>
<p>First, let&#x27;s wrap up what we&#x27;re working on. Back in the interpreter code for
handling <code>OP_CLOSURE</code>, we eventually finish iterating through the upvalue
array and initialize each one. When that completes, we have a new closure with
an array full of upvalues pointing to variables.</p>
<p>With that in hand, we can implement the instructions that work with those
upvalues.</p>
<p>^code interpret-get-upvalue (1 before, 1 after)</p>
<p>The operand is the index into the current function&#x27;s upvalue array. So we simply
look up the corresponding upvalue and dereference its location pointer to read
the value in that slot. Setting a variable is similar.</p>
<p>^code interpret-set-upvalue (1 before, 1 after)</p>
<p>We <span name="assign">take</span> the value on top of the stack and store it
into the slot pointed to by the chosen upvalue. Just as with the instructions
for local variables, it&#x27;s important that these instructions are fast. User
programs are constantly reading and writing variables, so if that&#x27;s slow,
everything is slow. And, as usual, the way we make them fast is by keeping them
simple. These two new instructions are pretty good: no control flow, no complex
arithmetic, just a couple of pointer indirections and a <code>push()</code>.</p>
<aside name="assign">
<p>The set instruction doesn&#x27;t <em>pop</em> the value from the stack because, remember,
assignment is an expression in Lox. So the result of the assignment -- the
assigned value -- needs to remain on the stack for the surrounding expression.</p>
</aside>
<p>This is a milestone. As long as all of the variables remain on the stack, we
have working closures. Try this:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = &quot;outside&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  inner();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">outer();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Run this, and it correctly prints &quot;outside&quot;.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="closed-upvalues">Closed Upvalues<a href="#closed-upvalues" class="hash-link" aria-label="Closed Upvalues的直接链接" title="Closed Upvalues的直接链接">​</a></h2>
<p>Of course, a key feature of closures is that they hold on to the variable as
long as needed, even after the function that declares the variable has returned.
Here&#x27;s another example that <em>should</em> work:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun outer() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var x = &quot;outside&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun inner() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  return inner;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var closure = outer();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closure();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复  制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>But if you run it right now... who knows what it does? At runtime, it will end
up reading from a stack slot that no longer contains the closed-over variable.
Like I&#x27;ve mentioned a few times, the crux of the issue is that variables in
closures don&#x27;t have stack semantics. That means we&#x27;ve got to hoist them off the
stack when the function where they were declared returns. This final section of
the chapter does that.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="values-and-variables">Values and variables<a href="#values-and-variables" class="hash-link" aria-label="Values and variables的直接链接" title="Values and variables的直接链接">​</a></h3>
<p>Before we get to writing code, I want to dig into an important semantic point.
Does a closure close over a <em>value</em> or a <em>variable?</em> This isn&#x27;t purely an <span name="academic">academic</span> question. I&#x27;m not just splitting hairs.
Consider:</p>
<aside name="academic">
<p>If Lox didn&#x27;t allow assignment, it <em>would</em> be an academic question.</p>
</aside>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var globalSet;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var globalGet;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = &quot;initial&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun set() { a = &quot;updated&quot;; }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun get() { print a; }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  globalSet = set;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  globalGet = get;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">main();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">globalSet();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">globalGet();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The outer <code>main()</code> function creates two closures and stores them in <span name="global">global</span> variables so that they outlive the execution of
<code>main()</code> itself. Both of those closures capture the same variable. The first
closure assigns a new value to it and the second closure reads the variable.</p>
<aside name="global">
<p>The fact that I&#x27;m using a couple of global variables isn&#x27;t significant. I needed
some way to return two values from a function, and without any kind of
collection type in Lox, my options were limited.</p>
</aside>
<p>What does the call to <code>globalGet()</code> print? If closures capture <em>values</em> then
each closure gets its own copy of <code>a</code> with the value that <code>a</code> had at the point
in time that the closure&#x27;s function declaration executed. The call to
<code>globalSet()</code> will modify <code>set()</code>&#x27;s copy of <code>a</code>, but <code>get()</code>&#x27;s copy will be
unaffected. Thus, the call to <code>globalGet()</code> will print &quot;initial&quot;.</p>
<p>If closures close over variables, then <code>get()</code> and <code>set()</code> will both capture --
reference -- the <em>same mutable variable</em>. When <code>set()</code> changes <code>a</code>, it changes
the same <code>a</code> that <code>get()</code> reads from. There is only one <code>a</code>. That, in turn,
implies the call to <code>globalGet()</code> will print &quot;updated&quot;.</p>
<p>Which is it? The answer for Lox and most other languages I know with closures is
the latter. Closures capture variables. You can think of them as capturing <em>the
place the value lives</em>. This is important to keep in mind as we deal with
closed-over variables that are no longer on the stack. When a variable moves to
the heap, we need to ensure that all closures capturing that variable retain a
reference to its <em>one</em> new location. That way, when the variable is mutated, all
closures see the change.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="closing-upvalues">Closing upvalues<a href="#closing-upvalues" class="hash-link" aria-label="Closing upvalues的直接链接" title="Closing upvalues的直接链接">​</a></h3>
<p>We know that local variables always start out on the stack. This is faster, and
lets our single-pass compiler emit code before it discovers the variable has
been captured. We also know that closed-over variables need to move to the heap
if the closure outlives the function where the captured variable is declared.</p>
<p>Following Lua, we&#x27;ll use <strong>open upvalue</strong> to refer to an upvalue that points to
a local variable still on the stack. When a variable moves to the heap, we are
<em>closing</em> the upvalue and the result is, naturally, a <strong>closed upvalue</strong>. The
two questions we need to answer are:</p>
<ol>
<li>
<p>Where on the heap does the closed-over variable go?</p>
</li>
<li>
<p>When do we close the upvalue?</p>
</li>
</ol>
<p>The answer to the first question is easy. We already have a convenient object on
the heap that represents a reference to a variable -- ObjUpvalue itself. The
closed-over variable will move into a new field right inside the ObjUpvalue
struct. That way we don&#x27;t need to do any additional heap allocation to close an
upvalue.</p>
<p>The second question is straightforward too. As long as the variable is on the
stack, there may be code that refers to it there, and that code must work
correctly. So the logical time to hoist the variable to the heap is as late as
possible. If we move the local variable right when it goes out of scope, we are
certain that no code after that point will try to access it from the stack.
<span name="after">After</span> the variable is out of scope, the compiler will
have reported an error if any code tried to use it.</p>
<aside name="after">
<p>By &quot;after&quot; here, I mean in the lexical or textual sense -- code past the <code>}</code>
for the block containing the declaration of the closed-over variable.</p>
</aside>
<p>The compiler already emits an <code>OP_POP</code> instruction when a local variable goes
out of scope. If a variable is captured by a closure, we will instead emit a
different instruction to hoist that variable out of the stack and into its
corresponding upvalue. To do that, the compiler needs to know which <span name="param">locals</span> are closed over.</p>
<aside name="param">
<p>The compiler doesn&#x27;t pop parameters and locals declared immediately inside the
body of a function. We&#x27;ll handle those too, in the runtime.</p>
</aside>
<p>The compiler already maintains an array of Upvalue structs for each local
variable in the function to track exactly that state. That array is good for
answering &quot;Which variables does this closure use?&quot; But it&#x27;s poorly suited for
answering, &quot;Does <em>any</em> function capture this local variable?&quot; In particular,
once the Compiler for some closure has finished, the Compiler for the enclosing
function whose variable has been captured no longer has access to any of the
upvalue state.</p>
<p>In other words, the compiler maintains pointers from upvalues to the locals they
capture, but not in the other direction. So we first need to add some extra
tracking inside the existing Local struct so that we can tell if a given local
is captured by a closure.</p>
<p>^code is-captured-field (1 before, 1 after)</p>
<p>This field is <code>true</code> if the local is captured by any later nested function
declaration. Initially, all locals are not captured.</p>
<p>^code init-is-captured (1 before, 1 after)</p>
<p><span name="zero">Likewise</span>, the special &quot;slot zero local&quot; that the
compiler implicitly declares is not captured.</p>
<aside name="zero">
<p>Later in the book, it <em>will</em> become possible for a user to capture this
variable. Just building some anticipation here.</p>
</aside>
<p>^code init-zero-local-is-captured (1 before, 1 after)</p>
<p>When resolving an identifier, if we end up creating an upvalue for a local
variable, we mark it as captured.</p>
<p>^code mark-local-captured (1 before, 1 after)</p>
<p>Now, at the end of a block scope when the compiler emits code to free the stack
slots for the locals, we can tell which ones need to get hoisted onto the heap.
We&#x27;ll use a new instruction for that.</p>
<p>^code end-scope (3 before, 2 after)</p>
<p>The instruction requires no operand. We know that the variable will always be
right on top of the stack at the point that this instruction executes. We
declare the instruction.</p>
<p>^code close-upvalue-op (1 before, 1 after)</p>
<p>And add trivial disassembler support for it:</p>
<p>^code disassemble-close-upvalue (1 before, 1 after)</p>
<p>Excellent. Now the generated bytecode tells the runtime exactly when each
captured local variable must move to the heap. Better, it does so only for the
locals that <em>are</em> used by a closure and need this special treatment. This aligns
with our general performance goal that we want users to pay only for
functionality that they use. Variables that aren&#x27;t used by closures live and die
entirely on the stack just as they did before.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tracking-open-upvalues">Tracking open upvalues<a href="#tracking-open-upvalues" class="hash-link" aria-label="Tracking open upvalues的直接链接" title="Tracking open upvalues的直接链接">​</a></h3>
<p>Let&#x27;s move over to the runtime side. Before we can interpret <code>OP_CLOSE_UPVALUE</code>
instructions, we have an issue to resolve. Earlier, when I talked about whether
closures capture variables or values, I said it was important that if multiple
closures access the same variable that they end up with a reference to the
exact same storage location in memory. That way if one closure writes to the
variable, the other closure sees the change.</p>
<p>Right now, if two closures capture the same <span name="indirect">local</span>
variable, the VM creates a separate Upvalue for each one. The necessary sharing
is missing. When we move the variable off the stack, if we move it into only one
of the upvalues, the other upvalue will have an orphaned value.</p>
<aside name="indirect">
<p>The VM <em>does</em> share upvalues if one closure captures an <em>upvalue</em> from a
surrounding function. The nested case works correctly. But if two <em>sibling</em>
closures capture the same local variable, they each create a separate
ObjUpvalue.</p>
</aside>
<p>To fix that, whenever the VM needs an upvalue that captures a particular local
variable slot, we will first search for an existing upvalue pointing to that
slot. If found, we reuse that. The challenge is that all of the previously
created upvalues are squirreled away inside the upvalue arrays of the various
closures. Those closures could be anywhere in the VM&#x27;s memory.</p>
<p>The first step is to give the VM its own list of all open upvalues that point to
variables still on the stack. Searching a list each time the VM needs an upvalue
sounds like it might be slow, but in practice, it&#x27;s not bad. The number of
variables on the stack that actually get closed over tends to be small. And
function declarations that <span name="create">create</span> closures are rarely
on performance critical execution paths in the user&#x27;s program.</p>
<aside name="create">
<p>Closures are frequently <em>invoked</em> inside hot loops. Think about the closures
passed to typical higher-order functions on collections like <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)" target="_blank" rel="noopener noreferrer"><code>map()</code></a> and
<a href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)" target="_blank" rel="noopener noreferrer"><code>filter()</code></a>. That should be fast. But the function declaration that
<em>creates</em> the closure happens only once and is usually outside of the loop.</p>
</aside>
<p>Even better, we can order the list of open upvalues by the stack slot index they
point to. The common case is that a slot has <em>not</em> already been captured --
sharing variables between closures is uncommon -- and closures tend to capture
locals near the top of the stack. If we store the open upvalue array in stack
slot order, as soon as we step past the slot where the local we&#x27;re capturing
lives, we know it won&#x27;t be found. When that local is near the top of the stack,
we can exit the loop pretty early.</p>
<p>Maintaining a sorted list requires inserting elements in the middle efficiently.
That suggests using a linked list instead of a dynamic array. Since we defined
the ObjUpvalue struct ourselves, the easiest implementation is an intrusive list
that puts the next pointer right inside the ObjUpvalue struct itself.</p>
<p>^code next-field (1 before, 1 after)</p>
<p>When we allocate an upvalue, it is not attached to any list yet so the link is
<code>NULL</code>.</p>
<p>^code init-next (1 before, 1 after)</p>
<p>The VM owns the list, so the head pointer goes right inside the main VM struct.</p>
<p>^code open-upvalues-field (1 before, 1 after)</p>
<p>The list starts out empty.</p>
<p>^code init-open-upvalues (1 before, 1 after)</p>
<p>Starting with the first upvalue pointed to by the VM, each open upvalue points
to the next open upvalue that references a local variable farther down the
stack. This script, for example,</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var a = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun f() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var b = 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun g() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print b;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var c = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun h() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    print c;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>should produce a series of linked upvalues like so:</p>
<img decoding="async" loading="lazy" src="image/closures/linked-list.png" alt="Three upvalues in a linked list." class="img_ev3q">
<p>Whenever we close over a local variable, before creating a new upvalue, we look
for an existing one in the list.</p>
<p>^code look-for-existing-upvalue (1 before, 1 after)</p>
<p>We start at the <span name="head">head</span> of the list, which is the upvalue
closest to the top of the stack. We walk through the list, using a little
pointer comparison to iterate past every upvalue pointing to slots above the one
we&#x27;re looking for. While we do that, we keep track of the preceding upvalue on
the list. We&#x27;ll need to update that node&#x27;s <code>next</code> pointer if we end up inserting
a node after it.</p>
<aside name="head">
<p>It&#x27;s a singly linked list. It&#x27;s not like we have any other choice than to start
at the head and go forward from there.</p>
</aside>
<p>There are three reasons we can exit the loop:</p>
<ol>
<li>
<p><strong>The local slot we stopped at <em>is</em> the slot we&#x27;re looking for.</strong> We found
an existing upvalue capturing the variable, so we reuse that upvalue.</p>
</li>
<li>
<p><strong>We ran out of upvalues to search.</strong> When <code>upvalue</code> is <code>NULL</code>, it means
every open upvalue in the list points to locals above the slot we&#x27;re looking
for, or (more likely) the upvalue list is empty. Either way, we didn&#x27;t find
an upvalue for our slot.</p>
</li>
<li>
<p><strong>We found an upvalue whose local slot is <em>below</em> the one we&#x27;re looking
for.</strong> Since the list is sorted, that means we&#x27;ve gone past the slot we are
closing over, and thus there must not be an existing upvalue for it.</p>
</li>
</ol>
<p>In the first case, we&#x27;re done and we&#x27;ve returned. Otherwise, we create a new
upvalue for our local slot and insert it into the list at the right location.</p>
<p>^code insert-upvalue-in-list (1 before, 1 after)</p>
<p>The current incarnation of this function already creates the upvalue, so we only
need to add code to insert the upvalue into the list. We exited the list
traversal by either going past the end of the list, or by stopping on the first
upvalue whose stack slot is below the one we&#x27;re looking for. In either case,
that means we need to insert the new upvalue <em>before</em> the object pointed at by
<code>upvalue</code> (which may be <code>NULL</code> if we hit the end of the list).</p>
<p>As you may have learned in Data Structures 101, to insert a node into a linked
list, you set the <code>next</code> pointer of the previous node to point to your new one.
We have been conveniently keeping track of that preceding node as we walked the
list. We also need to handle the <span name="double">special</span> case where
we are inserting a new upvalue at the head of the list, in which case the &quot;next&quot;
pointer is the VM&#x27;s head pointer.</p>
<aside name="double">
<p>There is a shorter implementation that handles updating either the head pointer
or the previous upvalue&#x27;s <code>next</code> pointer uniformly by using a pointer to a
pointer, but that kind of code confuses almost everyone who hasn&#x27;t reached some
Zen master level of pointer expertise. I went with the basic <code>if</code> statement
approach.</p>
</aside>
<p>With this updated function, the VM now ensures that there is only ever a single
ObjUpvalue for any given local slot. If two closures capture the same variable,
they will get the same upvalue. We&#x27;re ready to move those upvalues off the
stack now.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="closing-upvalues-at-runtime">Closing upvalues at runtime<a href="#closing-upvalues-at-runtime" class="hash-link" aria-label="Closing upvalues at runtime的直接链接" title="Closing upvalues at runtime的直接链接">​</a></h3>
<p>The compiler helpfully emits an <code>OP_CLOSE_UPVALUE</code> instruction to tell the VM
exactly when a local variable should be hoisted onto the heap. Executing that
instruction is the interpreter&#x27;s responsibility.</p>
<p>^code interpret-close-upvalue (1 before, 1 after)</p>
<p>When we reach the instruction, the variable we are hoisting is right on top of
the stack. We call a helper function, passing the address of that stack slot.
That function is responsible for closing the upvalue and moving the local from
the stack to the heap. After that, the VM is free to discard the stack slot,
which it does by calling <code>pop()</code>.</p>
<p>The fun stuff happens here:</p>
<p>^code close-upvalues</p>
<p>This function takes a pointer to a stack slot. It closes every open upvalue it
can find that points to that slot or any slot above it on the stack. Right now,
we pass a pointer only to the top slot on the stack, so the &quot;or above it&quot; part
doesn&#x27;t come into play, but it will soon.</p>
<p>To do this, we walk the VM&#x27;s list of open upvalues, again from top to bottom. If
an upvalue&#x27;s location points into the range of slots we&#x27;re closing, we close the
upvalue. Otherwise, once we reach an upvalue outside of the range, we know the
rest will be too, so we stop iterating.</p>
<p>The way an upvalue gets closed is pretty <span name="cool">cool</span>. First,
we copy the variable&#x27;s value into the <code>closed</code> field in the ObjUpvalue. That&#x27;s
where closed-over variables live on the heap. The <code>OP_GET_UPVALUE</code> and
<code>OP_SET_UPVALUE</code> instructions need to look for the variable there after it&#x27;s
been moved. We could add some conditional logic in the interpreter code for
those instructions to check some flag for whether the upvalue is open or closed.</p>
<p>But there is already a level of indirection in play -- those instructions
dereference the <code>location</code> pointer to get to the variable&#x27;s value. When the
variable moves from the stack to the <code>closed</code> field, we simply update that
<code>location</code> to the address of the ObjUpvalue&#x27;s <em>own</em> <code>closed</code> field.</p>
<aside name="cool">
<p>I&#x27;m not praising myself here. This is all the Lua dev team&#x27;s innovation.</p>
</aside>
<img decoding="async" loading="lazy" src="image/closures/closing.png" alt="Moving a value from the stack to the upvalue&#x27;s &#x27;closed&#x27; field and then pointing the &#x27;value&#x27; field to it." class="img_ev3q">
<p>We don&#x27;t need to change how <code>OP_GET_UPVALUE</code> and <code>OP_SET_UPVALUE</code> are
interpreted at all. That keeps them simple, which in turn keeps them fast. We do
need to add the new field to ObjUpvalue, though.</p>
<p>^code closed-field (1 before, 1 after)</p>
<p>And we should zero it out when we create an ObjUpvalue so there&#x27;s no
uninitialized memory floating around.</p>
<p>^code init-closed (1 before, 1 after)</p>
<p>Whenever the compiler reaches the end of a block, it discards all local
variables in that block and emits an <code>OP_CLOSE_UPVALUE</code> for each local variable
that was closed over. The compiler <span name="close">does</span> <em>not</em> emit any
instructions at the end of the outermost block scope that defines a function
body. That scope contains the function&#x27;s parameters and any locals declared
immediately inside the function. Those need to get closed too.</p>
<aside name="close">
<p>There&#x27;s nothing <em>preventing</em> us from closing the outermost function scope in the
compiler and emitting <code>OP_POP</code> and <code>OP_CLOSE_UPVALUE</code> instructions. Doing so is
just unnecessary because the runtime discards all of the stack slots used by the
function implicitly when it pops the call frame.</p>
</aside>
<p>This is the reason <code>closeUpvalues()</code> accepts a pointer to a stack slot. When a
function returns, we call that same helper and pass in the first stack slot
owned by the function.</p>
<p>^code return-close-upvalues (1 before, 1 after)</p>
<p>By passing the first slot in the function&#x27;s stack window, we close every
remaining open upvalue owned by the returning function. And with that, we now
have a fully functioning closure implementation. Closed-over variables live as
long as they are needed by the functions that capture them.</p>
<p>This was a lot of work! In jlox, closures fell out naturally from our
environment representation. In clox, we had to add a lot of code -- new bytecode
instructions, more data structures in the compiler, and new runtime objects. The
VM very much treats variables in closures as different from other variables.</p>
<p>There is a rationale for that. In terms of implementation complexity, jlox gave
us closures &quot;for free&quot;. But in terms of <em>performance</em>, jlox&#x27;s closures are
anything but. By allocating <em>all</em> environments on the heap, jlox pays a
significant performance price for <em>all</em> local variables, even the majority which
are never captured by closures.</p>
<p>With clox, we have a more complex system, but that allows us to tailor the
implementation to fit the two use patterns we observe for local variables. For
most variables which do have stack semantics, we allocate them entirely on the
stack which is simple and fast. Then, for the few local variables where that
doesn&#x27;t work, we have a second slower path we can opt in to as needed.</p>
<p>Fortunately, users don&#x27;t perceive the complexity. From their perspective, local
variables in Lox are simple and uniform. The <em>language itself</em> is as simple as
jlox&#x27;s implementation. But under the hood, clox is watching what the user does
and optimizing for their specific uses. As your language implementations grow in
sophistication, you&#x27;ll find yourself doing this more. A large fraction of
&quot;optimization&quot; is about adding special case code that detects certain uses and
provides a custom-built, faster path for code that fits that pattern.</p>
<p>We have lexical scoping fully working in clox now, which is a major milestone.
And, now that we have functions and variables with complex lifetimes, we also
have a <em>lot</em> of objects floating around in clox&#x27;s heap, with a web of pointers
stringing them together. The <a href="/docs/Craftinginterpreters/not-translated-yet/garbage-collection.html">next step</a> is figuring out how to manage that
memory so that we can free some of those objects when they&#x27;re no longer needed.</p>
<div class="challenges">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h2>
<ol>
<li>
<p>Wrapping every ObjFunction in an ObjClosure introduces a level of
indirection that has a performance cost. That cost isn&#x27;t necessary for
functions that do not close over any variables, but it does let the runtime
treat all calls uniformly.</p>
<p>Change clox to only wrap functions in ObjClosures that need upvalues. How
does the code complexity and performance compare to always wrapping
functions? Take care to benchmark programs that do and do not use closures.
How should you weight the importance of each benchmark? If one gets slower
and one faster, how do you decide what trade-off to make to choose an
implementation strategy?</p>
</li>
<li>
<p>Read the design note below. I&#x27;ll wait. Now, how do you think Lox <em>should</em>
behave? Change the implementation to create a new variable for each loop
iteration.</p>
</li>
<li>
<p>A <a href="http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent" target="_blank" rel="noopener noreferrer">famous koan</a> teaches us that &quot;objects are a poor man&#x27;s closure&quot;
(and vice versa). Our VM doesn&#x27;t support objects yet, but now that we have
closures we can approximate them. Using closures, write a Lox program that
models two-dimensional vector &quot;objects&quot;. It should:</p>
<ul>
<li>
<p>Define a &quot;constructor&quot; function to create a new vector with the given
<em>x</em> and <em>y</em> coordinates.</p>
</li>
<li>
<p>Provide &quot;methods&quot; to access the <em>x</em> and <em>y</em> coordinates of values
returned from that constructor.</p>
</li>
<li>
<p>Define an addition &quot;method&quot; that adds two vectors and produces a third.</p>
</li>
</ul>
</li>
</ol>
</div>
<div class="design-note">
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="design-note-closing-over-the-loop-variable">Design Note: Closing Over the Loop Variable<a href="#design-note-closing-over-the-loop-variable" class="hash-link" aria-label="Design Note: Closing Over the Loop Variable的直接链接" title="Design Note: Closing Over the Loop Variable的直接链接">​</a></h2>
<p>Closures capture variables. When two closures capture the same variable, they
share a reference to the same underlying storage location. This fact is visible
when new values are assigned to the variable. Obviously, if two closures capture
<em>different</em> variables, there is no sharing.</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var globalOne;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var globalTwo;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var a = &quot;one&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun one() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    globalOne = one;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var a = &quot;two&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun two() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    globalTwo = two;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">main();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">globalOne();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">globalTwo();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>This prints &quot;one&quot; then &quot;two&quot;. In this example, it&#x27;s pretty clear that the two
<code>a</code> variables are different. But it&#x27;s not always so obvious. Consider:</p>
<div class="language-lox codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lox codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var globalOne;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">var globalTwo;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  for (var a = 1; a &lt;= 2; a = a + 1) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun closure() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      print a;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (globalOne == nil) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      globalOne = closure;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      globalTwo = closure;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">main();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">globalOne();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">globalTwo();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The code is convoluted because Lox has no collection types. The important part
is that the <code>main()</code> function does two iterations of a <code>for</code> loop. Each time
through the loop, it creates a closure that captures the loop variable. It
stores the first closure in <code>globalOne</code> and the second in <code>globalTwo</code>.</p>
<p>There are definitely two different closures. Do they close over two different
variables? Is there only one <code>a</code> for the entire duration of the loop, or does
each iteration get its own distinct <code>a</code> variable?</p>
<p>The script here is strange and contrived, but this does show up in real code
in languages that aren&#x27;t as minimal as clox. Here&#x27;s a JavaScript example:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">var</span><span class="token plain"> closures </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">for</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">var</span><span class="token plain"> i </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> i </span><span class="token operator">&lt;=</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> i</span><span class="token operator">++</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">push</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"> </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">0</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Does this print &quot;1&quot; then &quot;2&quot;, or does it print <span name="three">&quot;3&quot;</span>
twice? You may be surprised to hear that it prints &quot;3&quot; twice. In this JavaScript
program, there is only a single <code>i</code> variable whose lifetime includes all
iterations of the loop, including the final exit.</p>
<aside name="three">
<p>You&#x27;re wondering how <em>three</em> enters the picture? After the second iteration,
<code>i++</code> is executed, which increments <code>i</code> to three. That&#x27;s what causes <code>i &lt;= 2</code> to
evaluate to false and end the loop. If <code>i</code> never reached three, the loop would
run forever.</p>
</aside>
<p>If you&#x27;re familiar with JavaScript, you probably know that variables declared
using <code>var</code> are implicitly <em>hoisted</em> to the surrounding function or top-level
scope. It&#x27;s as if you really wrote this:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">var</span><span class="token plain"> closures </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">var</span><span class="token plain"> i</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">for</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">i </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> i </span><span class="token operator">&lt;=</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> i</span><span class="token operator">++</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">push</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"> </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">0</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>At that point, it&#x27;s clearer that there is only a single <code>i</code>. Now consider if
you change the program to use the newer <code>let</code> keyword:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">var</span><span class="token plain"> closures </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">for</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">let</span><span class="token plain"> i </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> i </span><span class="token operator">&lt;=</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> i</span><span class="token operator">++</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">push</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"> </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">0</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Does this new program behave the same? Nope. In this case, it prints &quot;1&quot; then
&quot;2&quot;. Each closure gets its own <code>i</code>. That&#x27;s sort of strange when you think about
it. The increment clause is <code>i++</code>. That looks very much like it is assigning to
and mutating an existing variable, not creating a new one.</p>
<p>Let&#x27;s try some other languages. Here&#x27;s Python:</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">for</span><span class="token plain"> i </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">in</span><span class="token plain"> </span><span class="token builtin" style="color:rgb(189, 147, 249)">range</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token number">3</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">append</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">lambda</span><span class="token punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">print</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">0</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">1</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Python doesn&#x27;t really have block scope. Variables are implicitly declared and
are automatically scoped to the surrounding function. Kind of like hoisting in
JS, now that I think about it. So both closures capture the same variable.
Unlike C, though, we don&#x27;t exit the loop by incrementing <code>i</code> <em>past</em> the last
value, so this prints &quot;2&quot; twice.</p>
<p>What about Ruby? Ruby has two typical ways to iterate numerically. Here&#x27;s the
classic imperative style:</p>
<div class="language-ruby codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ruby codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures = []</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">for i in 1..2 do</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  closures &lt;&lt; lambda { puts i }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">end</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures[0].call</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures[1].call</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>This, like Python, prints &quot;2&quot; twice. But the more idiomatic Ruby style is using
a higher-order <code>each()</code> method on range objects:</p>
<div class="language-ruby codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ruby codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures = []</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">(1..2).each do |i|</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  closures &lt;&lt; lambda { puts i }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">end</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures[0].call</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">closures[1].call</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>If you&#x27;re not familiar with Ruby, the <code>do |i| ... end</code> part is basically a
closure that gets created and passed to the <code>each()</code> method. The <code>|i|</code> is the
parameter signature for the closure. The <code>each()</code> method invokes that closure
twice, passing in 1 for <code>i</code> the first time and 2 the second time.</p>
<p>In this case, the &quot;loop variable&quot; is really a function parameter. And, since
each iteration of the loop is a separate invocation of the function, those are
definitely separate variables for each call. So this prints &quot;1&quot; then &quot;2&quot;.</p>
<p>If a language has a higher-level iterator-based looping structure like <code>foreach</code>
in C#, Java&#x27;s &quot;enhanced for&quot;, <code>for-of</code> in JavaScript, <code>for-in</code> in Dart, etc.,
then I think it&#x27;s natural to the reader to have each iteration create a new
variable. The code <em>looks</em> like a new variable because the loop header looks
like a variable declaration. And there&#x27;s no increment expression that looks like
it&#x27;s mutating that variable to advance to the next step.</p>
<p>If you dig around StackOverflow and other places, you find evidence that this is
what users expect, because they are very surprised when they <em>don&#x27;t</em> get it. In
particular, C# originally did <em>not</em> create a new loop variable for each
iteration of a <code>foreach</code> loop. This was such a frequent source of user confusion
that they took the very rare step of shipping a breaking change to the language.
In C# 5, each iteration creates a fresh variable.</p>
<p>Old C-style <code>for</code> loops are harder. The increment clause really does look like
mutation. That implies there is a single variable that&#x27;s getting updated each
step. But it&#x27;s almost never <em>useful</em> for each iteration to share a loop
variable. The only time you can even detect this is when closures capture it.
And it&#x27;s rarely helpful to have a closure that references a variable whose value
is whatever value caused you to exit the loop.</p>
<p>The pragmatically useful answer is probably to do what JavaScript does with
<code>let</code> in <code>for</code> loops. Make it look like mutation but actually create a new
variable each time, because that&#x27;s what users want. It is kind of weird when you
think about it, though.</p>
</div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/jabberwocky238/jabberwocky238.github.io/docs/Craftinginterpreters/not-translated-yet/closures.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Craftinginterpreters/not-translated-yet/classes"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">classes</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Craftinginterpreters/not-translated-yet/compiling-expressions"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">compiling-expressions</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#closure-objects" class="table-of-contents__link toc-highlight">Closure Objects</a><ul><li><a href="#compiling-to-closure-objects" class="table-of-contents__link toc-highlight">Compiling to closure objects</a></li><li><a href="#interpreting-function-declarations" class="table-of-contents__link toc-highlight">Interpreting function declarations</a></li></ul></li><li><a href="#upvalues" class="table-of-contents__link toc-highlight">Upvalues</a><ul><li><a href="#compiling-upvalues" class="table-of-contents__link toc-highlight">Compiling upvalues</a></li><li><a href="#flattening-upvalues" class="table-of-contents__link toc-highlight">Flattening upvalues</a></li></ul></li><li><a href="#upvalue-objects" class="table-of-contents__link toc-highlight">Upvalue Objects</a><ul><li><a href="#upvalues-in-closures" class="table-of-contents__link toc-highlight">Upvalues in closures</a></li></ul></li><li><a href="#closed-upvalues" class="table-of-contents__link toc-highlight">Closed Upvalues</a><ul><li><a href="#values-and-variables" class="table-of-contents__link toc-highlight">Values and variables</a></li><li><a href="#closing-upvalues" class="table-of-contents__link toc-highlight">Closing upvalues</a></li><li><a href="#tracking-open-upvalues" class="table-of-contents__link toc-highlight">Tracking open upvalues</a></li><li><a href="#closing-upvalues-at-runtime" class="table-of-contents__link toc-highlight">Closing upvalues at runtime</a></li></ul></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li><li><a href="#design-note-closing-over-the-loop-variable" class="table-of-contents__link toc-highlight">Design Note: Closing Over the Loop Variable</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>