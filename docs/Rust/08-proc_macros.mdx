---
sidebar_position: 8
sidebar_label: ğŸ’©è¿‡ç¨‹å® proc macros
sidebar_class_name: green
---

# è¿‡ç¨‹å®

## proc_macroå’Œmacro_rules!çš„åŒºåˆ«
åœ¨ Rust ä¸­ï¼Œ`proc_macro` å’Œ `macro_rules!` æ˜¯ä¸¤ç§ä¸åŒç±»å‹çš„å®ç³»ç»Ÿï¼Œå®ƒä»¬åœ¨åŠŸèƒ½å’Œç”¨é€”ä¸Šæœ‰æ‰€åŒºåˆ«ï¼š

### `macro_rules!`

- **å®šä¹‰å®çš„æ–¹å¼**ï¼š`macro_rules!` æ˜¯ä¸€ç§å£°æ˜å¼å®ç³»ç»Ÿï¼Œå…è®¸ä½ å®šä¹‰ä¸€ç³»åˆ—çš„æ¨¡å¼å’ŒåŒ¹é…è¿™äº›æ¨¡å¼çš„æ›¿æ¢ä»£ç ã€‚å®ƒåŸºäºæ¨¡å¼åŒ¹é…æ¥å®ç°å®çš„è¡Œä¸ºã€‚
- **ç¼–è¯‘æ—¶æ‰§è¡Œ**ï¼š`macro_rules!` å®åœ¨ç¼–è¯‘æ—¶å±•å¼€ï¼Œå®ƒä»¬çš„æ‰§è¡Œç»“æœå°†ç›´æ¥æ›¿æ¢å®è°ƒç”¨çš„ä½ç½®ã€‚
- **æ˜“äºç†è§£å’Œä½¿ç”¨**ï¼šå¯¹äºå¤§å¤šæ•°ç®€å•çš„å®ï¼Œ`macro_rules!` æä¾›äº†ä¸€ç§ç›¸å¯¹ç®€å•å’Œç›´è§‚çš„æ–¹å¼æ¥å®šä¹‰å®ã€‚
- **é€‚ç”¨åœºæ™¯**ï¼šé€‚åˆå®šä¹‰é€šç”¨çš„ã€å¤æ‚çš„å®ï¼Œå¦‚æ¡ä»¶ç¼–è¯‘ã€å¾ªç¯ã€è¿­ä»£ç­‰ã€‚

### `proc_macro`

- **å®šä¹‰å®çš„æ–¹å¼**ï¼š`proc_macro` æ˜¯ä¸€ç§åŠŸèƒ½æ›´å¼ºå¤§çš„è¿‡ç¨‹å®ç³»ç»Ÿï¼Œå…è®¸ä½ ç¼–å†™æ›´å¤æ‚çš„å®ï¼Œè¿™äº›å®å¯ä»¥è®¿é—®å’Œä¿®æ”¹ Rust ä»£ç çš„æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ã€‚
- **å•ç‹¬çš„ Crate**ï¼š`proc_macro` å®šä¹‰åœ¨å•ç‹¬çš„ crate ä¸­ï¼Œå¹¶ä¸”éœ€è¦ä½¿ç”¨ `proc_macro` ä½œä¸º crate ç±»å‹æ¥æ„å»ºã€‚
- **åŠ¨æ€æ‰§è¡Œ**ï¼šä¸ `macro_rules!` ä¸åŒï¼Œ`proc_macro` å®ä¸æ˜¯åœ¨æ¯ä¸ªè°ƒç”¨ç‚¹é™æ€å±•å¼€çš„ï¼Œè€Œæ˜¯ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„è¿‡ç¨‹è¿è¡Œï¼Œå¯ä»¥åŠ¨æ€åœ°ç”Ÿæˆä»£ç ã€‚
- **ä¾èµ–å¤–éƒ¨åº“**ï¼šé€šå¸¸éœ€è¦ä½¿ç”¨å¤–éƒ¨åº“ï¼Œå¦‚ `syn` æ¥è§£æ Rust ä»£ç ï¼Œ`quote` æ¥ç”Ÿæˆä»£ç ï¼Œ`proc_macro2` æ¥å¤„ç† token streamsã€‚
- **é€‚ç”¨åœºæ™¯**ï¼šé€‚åˆå®šä¹‰éœ€è¦æ·±å…¥åˆ†æå’Œè½¬æ¢ä»£ç çš„å®ï¼Œå¦‚å¤–éƒ¨è¡ç”Ÿçš„ trait å®ç°ï¼ˆderive macrosï¼‰ã€å¤æ‚ä»£ç ç”Ÿæˆç­‰ã€‚

### ç¤ºä¾‹

- **`macro_rules!` ç¤ºä¾‹**ï¼š

```rust
macro_rules! vec_to_string {
    ($v:expr) => {
        $v.iter().map(|i| i.to_string()).collect::<String>()
    };
}

fn main() {
    let v = vec![1, 2, 3];
    let s = vec_to_string!(v);
    println!("{}", s); // è¾“å‡º: 123
}
```

- **`proc_macro` ç¤ºä¾‹**ï¼š

```rust
// åœ¨ä¸€ä¸ªå•ç‹¬çš„ proc-macro crate ä¸­
#[proc_macro_derive(ToLower)]
pub fn to_lower(input: TokenStream) -> TokenStream {
    // ä½¿ç”¨ syn å’Œ quote ç­‰åº“è§£æå’Œç”Ÿæˆä»£ç 
}

// åœ¨ä½¿ç”¨è¯¥å®çš„ crate ä¸­
use to_lower_derive::ToLower;

#[derive(ToLower)]
struct MyStruct;

fn main() {
    let my_struct = MyStruct{};
    // è‡ªåŠ¨å®ç° to_lower æ–¹æ³•
}
```

### æ€»ç»“

- **`macro_rules!`** æ˜¯ä¸€ç§ç®€å•ã€å£°æ˜å¼çš„å®ç³»ç»Ÿï¼Œé€‚åˆå¤§å¤šæ•°ç®€å•çš„å®å®šä¹‰ã€‚
- **`proc_macro`** æ˜¯ä¸€ç§æ›´å¤æ‚ã€åŠŸèƒ½æ›´å¼ºå¤§çš„å®ç³»ç»Ÿï¼Œé€‚åˆéœ€è¦æ·±å…¥ä»£ç åˆ†æå’Œç”Ÿæˆçš„åœºæ™¯ã€‚

é€‰æ‹©å“ªç§å®ç³»ç»Ÿå–å†³äºä½ çš„å…·ä½“éœ€æ±‚å’Œå®çš„å¤æ‚æ€§ã€‚


## serde/src/de/impls.rs line 989
```rust
macro_rules! seq_impl {
    (
        $(#[$attr:meta])*
        $ty:ident <T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*>,
        $access:ident,
        $clear:expr,
        $with_capacity:expr,
        $reserve:expr,
        $insert:expr
    ) => {
        $(#[$attr])*
        impl<'de, T $(, $typaram)*> Deserialize<'de> for $ty<T $(, $typaram)*>
        where
            T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,
            $($typaram: $bound1 $(+ $bound2)*,)*
        {
```

è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ª Rust çš„è¿‡ç¨‹å®ï¼Œåä¸º `seq_impl`ã€‚è¿‡ç¨‹å®åœ¨ Rust ä¸­æ˜¯ä¸€ç§éå¸¸å¼ºå¤§çš„å·¥å…·ï¼Œå…è®¸å¼€å‘è€…ç¼–å†™å¯ä»¥ç”Ÿæˆå¤æ‚ä»£ç æ¨¡æ¿çš„å®ã€‚è¿™ä¸ªç‰¹å®šçš„å® `seq_impl` çœ‹èµ·æ¥æ˜¯ä¸ºäº†å®ç°åºåˆ—åŒ–å’Œååºåˆ—åŒ–æ“ä½œï¼Œç‰¹åˆ«æ˜¯é’ˆå¯¹æŸä¸ªæ³›å‹ç±»å‹ `$ty`ã€‚è®©æˆ‘ä»¬é€è¡Œåˆ†æè¿™ä¸ªå®çš„å®šä¹‰ï¼š

### å®å®šä¹‰ç»“æ„

1. **å±æ€§å’Œæ³›å‹å‚æ•°**
   - `$(#[$attr:meta])*`: è¿™æ˜¯ä¸€ä¸ªé‡å¤å‚æ•°ï¼Œç”¨äºæ•è·é›¶ä¸ªæˆ–å¤šä¸ªå±æ€§ã€‚è¿™äº›å±æ€§å°†è¢«åº”ç”¨åˆ°ç”Ÿæˆçš„ `impl` å—ä¸Šã€‚
   - `$ty:ident <T $(: $tbound1:ident $(+ $tbound2:ident)*)*`: å®šä¹‰äº†ä¸€ä¸ªæ³›å‹ç±»å‹ `$ty`ï¼Œå…¶ä¸­ `T` æ˜¯ç±»å‹å‚æ•°ï¼Œåé¢è·Ÿç€ä¸€ä¸ªæˆ–å¤šä¸ª trait ç»‘å®šï¼ˆä¾‹å¦‚ `: Deserialize`ï¼‰ã€‚
   - `$(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*`: å¯é€‰çš„é¢å¤–ç±»å‹å‚æ•°å’Œå®ƒä»¬çš„ trait ç»‘å®šã€‚

2. **æ–¹æ³•å’Œè¡¨è¾¾å¼**
   - `$access:ident`, `$clear:expr`, `$with_capacity:expr`, `$reserve:expr`, `$insert:expr`: è¿™äº›æ˜¯å®è°ƒç”¨æ—¶æä¾›çš„è¡¨è¾¾å¼æˆ–æ–¹æ³•åï¼Œç”¨äºåœ¨ç”Ÿæˆçš„ä»£ç ä¸­è®¿é—®ã€æ¸…é™¤ã€å¸¦å®¹é‡åˆå§‹åŒ–ã€ä¿ç•™ç©ºé—´å’Œæ’å…¥å…ƒç´ ã€‚

### å®å±•å¼€

- **ç”Ÿæˆçš„ä»£ç **
  - `impl<'de, T $(, $typaram)*> Deserialize<'de> for $ty<T $(, $typaram)*>`: ä¸ºç±»å‹ `$ty` å®ç° `Deserialize` traitã€‚è¿™é‡Œçš„ `'de` æ˜¯ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œç”¨äºååºåˆ—åŒ–æ“ä½œã€‚
  - `where` å­å¥åˆ—å‡ºäº†æ‰€æœ‰ç±»å‹å‚æ•° `T` å’Œ `$typaram` éœ€è¦æ»¡è¶³çš„ trait ç»‘å®šã€‚

### ç¤ºä¾‹ç”¨æ³•

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç±»å‹ `MySeq` å’Œä¸€ä¸ªç±»å‹ `MyTrait`ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸º `MySeq<T>` å®ç° `Deserialize`ï¼Œå…¶ä¸­ `T` å¿…é¡»å®ç° `Deserialize` å’Œ `MyTrait`ï¼š

```rust
seq_impl!(
    /// MySeq deserializer.
    MySeq<T: Deserialize + MyTrait>,
    access,
    clear,
    with_capacity,
    reserve,
    insert
);
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå®ä¼šç”Ÿæˆä¸€ä¸ª `impl` å—ï¼Œä¸º `MySeq<T>` å®ç° `Deserialize` traitï¼Œå…¶ä¸­ `T` éœ€è¦å®ç° `Deserialize` å’Œ `MyTrait`ã€‚

### æ³¨æ„äº‹é¡¹

- **å¤æ‚æ€§**ï¼šè¿‡ç¨‹å®å¯ä»¥éå¸¸å¤æ‚ï¼Œå°¤å…¶æ˜¯å½“å®ƒä»¬å¤„ç†å¤šä¸ªæ³›å‹å‚æ•°å’Œ trait ç»‘å®šæ—¶ã€‚
- **è°ƒè¯•éš¾åº¦**ï¼šç”±äºè¿‡ç¨‹å®åœ¨ç¼–è¯‘æ—¶å±•å¼€ï¼Œå®ƒä»¬å¯èƒ½å¯¼è‡´éš¾ä»¥è·Ÿè¸ªçš„é”™è¯¯ã€‚
- **æ€§èƒ½**ï¼šå°½ç®¡å®å¯ä»¥ç”Ÿæˆä¼˜åŒ–çš„ä»£ç ï¼Œä½†è¿‡åº¦ä½¿ç”¨æˆ–ä¸å½“ä½¿ç”¨å¯èƒ½å¯¼è‡´ç¼–è¯‘æ—¶é—´å¢åŠ ã€‚

è¿™ä¸ªå®çš„è®¾è®¡å…è®¸å®ƒåœ¨å¤šç§ä¸åŒçš„ç±»å‹å’Œçº¦æŸä¸Šé‡ç”¨ï¼Œä½¿å¾—ä»£ç æ›´åŠ æ¨¡å—åŒ–å’Œå¯ç»´æŠ¤ã€‚

```rust
seq_impl!(
    #[cfg(any(feature = "std", feature = "alloc"))]
    #[cfg_attr(docsrs, doc(cfg(any(feature = "std", feature = "alloc"))))]
    BinaryHeap<T: Ord>,
    seq,
    BinaryHeap::clear,
    BinaryHeap::with_capacity(size_hint::cautious::<T>(seq.size_hint())),
    BinaryHeap::reserve,
    BinaryHeap::push
);

seq_impl!(
    #[cfg(any(feature = "std", feature = "alloc"))]
    #[cfg_attr(docsrs, doc(cfg(any(feature = "std", feature = "alloc"))))]
    BTreeSet<T: Eq + Ord>,
    seq,
    BTreeSet::clear,
    BTreeSet::new(),
    nop_reserve,
    BTreeSet::insert
);
```
åœ¨ Rust å®ç³»ç»Ÿä¸­ï¼Œ`ident` å’Œ `expr` æ˜¯ä¸¤ç§ä¸åŒç±»å‹çš„æ¨¡å¼ï¼Œç”¨äºåŒ¹é…å®å®šä¹‰ä¸­çš„è¾“å…¥ã€‚å®ƒä»¬çš„ä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬æ‰€åŒ¹é…çš„è¯­æ³•ç§ç±»ï¼š

1. **`ident`**ï¼š
   - `ident` ç”¨äºåŒ¹é…æ ‡è¯†ç¬¦ã€‚
   - æ ‡è¯†ç¬¦æ˜¯ Rust ä»£ç ä¸­çš„åå­—ï¼Œæ¯”å¦‚å˜é‡åã€å‡½æ•°åã€ç±»å‹åç­‰ã€‚
   - ç¤ºä¾‹ï¼š`fn`ã€`loop`ã€`Result`ã€`x`ã€`y`ã€‚

2. **`expr`**ï¼š
   - `expr` ç”¨äºåŒ¹é…è¡¨è¾¾å¼ã€‚
   - è¡¨è¾¾å¼æ˜¯ Rust ä»£ç ä¸­çš„ä¸€ä¸ªå®Œæ•´çš„è®¡ç®—å•å…ƒï¼Œå¯ä»¥æ˜¯å­—é¢é‡ã€å˜é‡å¼•ç”¨ã€å‡½æ•°è°ƒç”¨ã€è¿ç®—ç¬¦åº”ç”¨ç­‰ã€‚
   - ç¤ºä¾‹ï¼š`2 + 2`ã€`x * y`ã€`foo()`ã€`[1, 2, 3]`ã€‚

### è¯¦ç»†è¯´æ˜

- **`ident`**ï¼š
  - åœ¨å®å®šä¹‰ä¸­ï¼Œ`ident` æ¨¡å¼å¯ä»¥æ•è·ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œå¹¶åœ¨å®å±•å¼€æ—¶ä½œä¸ºæ ‡è¯†ç¬¦ä½¿ç”¨ã€‚
  - å®ƒé€šå¸¸ç”¨äºæ•è·å‡½æ•°åã€å˜é‡åæˆ–å…¶ä»–ç±»å‹çš„åç§°ã€‚
  - åœ¨å®çš„æ›¿æ¢æ–‡æœ¬ä¸­ï¼Œæ•è·çš„æ ‡è¯†ç¬¦å¯ä»¥é€šè¿‡ `${ident}` çš„å½¢å¼ä½¿ç”¨ã€‚

- **`expr`**ï¼š
  - `expr` æ¨¡å¼å¯ä»¥åŒ¹é…ä»»ä½•æœ‰æ•ˆçš„ Rust è¡¨è¾¾å¼ã€‚
  - å®ƒç”¨äºæ•è·æ›´å¤æ‚çš„ä»£ç ç»“æ„ï¼Œæ¯”å¦‚å‡½æ•°è°ƒç”¨ã€ç®—æœ¯è¿ç®—ã€æ¡ä»¶è¡¨è¾¾å¼ç­‰ã€‚
  - åœ¨å®çš„æ›¿æ¢æ–‡æœ¬ä¸­ï¼Œæ•è·çš„è¡¨è¾¾å¼å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œæˆ–è€…é€šè¿‡å…¶ä»–å®è§„åˆ™è¿›ä¸€æ­¥å¤„ç†ã€‚

### ç¤ºä¾‹

```rust
// å®šä¹‰ä¸€ä¸ªç®€å•çš„å®ï¼Œä½¿ç”¨ ident å’Œ expr
macro_rules! create_function {
    ($name:ident -> $ret_type:ty { $body:expr }) => {
        fn $name() -> $ret_type {
            $body
        }
    };
}

// ä½¿ç”¨å®åˆ›å»ºä¸€ä¸ªå‡½æ•°
create_function!(square -> i32 { (3 * 3) });
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼š
- `$name:ident` æ•è·äº†æ ‡è¯†ç¬¦ `square`ã€‚
- `-> $ret_type:ty` æ•è·äº†è¿”å›ç±»å‹ `i32`ã€‚
- `{ $body:expr }` æ•è·äº†è¡¨è¾¾å¼ `(3 * 3)`ã€‚

å®å±•å¼€åï¼Œç”Ÿæˆçš„ä»£ç å¦‚ä¸‹ï¼š

```rust
fn square() -> i32 {
    (3 * 3)
}
```

### æ€»ç»“

- **`ident`** ç”¨äºåŒ¹é…å’Œç”Ÿæˆæ ‡è¯†ç¬¦ã€‚
- **`expr`** ç”¨äºåŒ¹é…å’Œç”Ÿæˆè¡¨è¾¾å¼ã€‚

äº†è§£è¿™ä¸¤ç§æ¨¡å¼çš„åŒºåˆ«å¯¹äºç¼–å†™çµæ´»ä¸”å¼ºå¤§çš„ Rust å®è‡³å…³é‡è¦ã€‚

åœ¨ Rust çš„å®ç³»ç»Ÿä¸­ï¼Œ`ty` å’Œ `block` æ˜¯ç”¨äºåŒ¹é…ç‰¹å®šç±»å‹çš„æ¨¡å¼ã€‚å®ƒä»¬åˆ†åˆ«ç”¨äºç±»å‹å’Œä»£ç å—çš„åŒ¹é…ã€‚

### `ty` æ¨¡å¼

`ty` æ¨¡å¼ç”¨äºåŒ¹é… Rust ä¸­çš„ç±»å‹ã€‚å®ƒæ•è·çš„æ˜¯ä¸€ä¸ªç±»å‹è¡¨è¾¾å¼ï¼Œå¯ä»¥æ˜¯ç®€å•ç±»å‹ï¼Œå¦‚ `i32`ã€`&str`ï¼Œä¹Ÿå¯ä»¥æ˜¯å¤æ‚ç±»å‹ï¼Œå¦‚ `Vec<T>` æˆ–è‡ªå®šä¹‰ç±»å‹ã€‚

**ç¤ºä¾‹**ï¼š

```rust
macro_rules! type_of {
    ($val:expr) => {
        std::mem::discriminant(&$val)
    };
}

fn main() {
    type_of!(42); // åŒ¹é…ç±»å‹ i32
    type_of!("hello"); // åŒ¹é…ç±»å‹ &str
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå® `type_of!` ä½¿ç”¨ `expr` æ¨¡å¼æ¥åŒ¹é…ä»»ä½•è¡¨è¾¾å¼ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™ `std::mem::discriminant` å‡½æ•°ï¼Œè¯¥å‡½æ•°éœ€è¦ä¸€ä¸ªç±»å‹æ ‡è¯†ç¬¦ä½œä¸ºå‚æ•°ã€‚

### `block` æ¨¡å¼

`block` æ¨¡å¼ç”¨äºåŒ¹é… Rust ä¸­çš„ä»£ç å— `{}`ã€‚å®ƒæ•è·çš„æ˜¯ä¸€ä¸ªä»£ç å—è¡¨è¾¾å¼ï¼Œå¯ä»¥åŒ…å«ä»»æ„å¤šçš„è¯­å¥ã€‚

**ç¤ºä¾‹**ï¼š

```rust
macro_rules! block_example {
    ($block:block) => {
        {
            // å¯ä»¥åœ¨è¿™é‡Œå¤„ç† $block
            $block
        }
    };
}

fn main() {
    let result = block_example!({
        let x = 10;
        x + 2
    });
    println!("The result is: {}", result);
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå® `block_example!` ä½¿ç”¨ `block` æ¨¡å¼æ¥åŒ¹é…ä¸€ä¸ªä»£ç å—ï¼Œå¹¶å°†å…¶ä½œä¸ºå‚æ•°ä¼ é€’ã€‚åœ¨å®çš„å±•å¼€ä¸­ï¼Œä»£ç å—è¢«åŒ…å«åœ¨ä¸€ä¸ªæ–°åˆ›å»ºçš„ä»£ç å—ä¸­ï¼Œå…è®¸åœ¨å…¶ä¸­æ‰§è¡Œä¸€äº›åˆå§‹åŒ–æˆ–æœ€ç»ˆå¤„ç†ã€‚

### æ³¨æ„äº‹é¡¹

- `ty` æ¨¡å¼åªèƒ½åŒ¹é…ç±»å‹ï¼Œä¸èƒ½åŒ¹é…å€¼ã€‚
- `block` æ¨¡å¼åŒ¹é…çš„æ˜¯ä»£ç å—ï¼Œå®ƒå¯ä»¥åŒ…å«ä»»æ„å¤šçš„è¯­å¥ã€‚

ä½¿ç”¨è¿™äº›æ¨¡å¼å¯ä»¥å¸®åŠ©ä½ ç¼–å†™æ›´çµæ´»çš„å®ï¼Œä»¥é€‚åº”ä¸åŒçš„ä»£ç ç»“æ„å’Œç±»å‹ã€‚



## synç¥äº†æˆ‘æ“ï¼Œç¼–è¯‘å™¨å¼€æ´


```rust
#[macro_export]
macro_rules! Token {
    [abstract]    => { $crate::token::Abstract };
    [as]          => { $crate::token::As };
    [async]       => { $crate::token::Async };
    [auto]        => { $crate::token::Auto };
    [await]       => { $crate::token::Await };
    [become]      => { $crate::token::Become };
    [box]         => { $crate::token::Box };
    [break]       => { $crate::token::Break };
    [const]       => { $crate::token::Const };
    [continue]    => { $crate::token::Continue };
    [crate]       => { $crate::token::Crate };
    [default]     => { $crate::token::Default };
    [do]          => { $crate::token::Do };
    [dyn]         => { $crate::token::Dyn };
    [else]        => { $crate::token::Else };
    [enum]        => { $crate::token::Enum };
    [extern]      => { $crate::token::Extern };
    [final]       => { $crate::token::Final };
    [fn]          => { $crate::token::Fn };
    [for]         => { $crate::token::For };
    [if]          => { $crate::token::If };
    [impl]        => { $crate::token::Impl };
    [in]          => { $crate::token::In };
    [let]         => { $crate::token::Let };
    [loop]        => { $crate::token::Loop };
    [macro]       => { $crate::token::Macro };
    [match]       => { $crate::token::Match };
    [mod]         => { $crate::token::Mod };
    [move]        => { $crate::token::Move };
    [mut]         => { $crate::token::Mut };
    [override]    => { $crate::token::Override };
    [priv]        => { $crate::token::Priv };
    [pub]         => { $crate::token::Pub };
    [ref]         => { $crate::token::Ref };
    [return]      => { $crate::token::Return };
    [Self]        => { $crate::token::SelfType };
    [self]        => { $crate::token::SelfValue };
    [static]      => { $crate::token::Static };
    [struct]      => { $crate::token::Struct };
    [super]       => { $crate::token::Super };
    [trait]       => { $crate::token::Trait };
    [try]         => { $crate::token::Try };
    [type]        => { $crate::token::Type };
    [typeof]      => { $crate::token::Typeof };
    [union]       => { $crate::token::Union };
    [unsafe]      => { $crate::token::Unsafe };
    [unsized]     => { $crate::token::Unsized };
    [use]         => { $crate::token::Use };
    [virtual]     => { $crate::token::Virtual };
    [where]       => { $crate::token::Where };
    [while]       => { $crate::token::While };
    [yield]       => { $crate::token::Yield };
    [&]           => { $crate::token::And };
    [&&]          => { $crate::token::AndAnd };
    [&=]          => { $crate::token::AndEq };
    [@]           => { $crate::token::At };
    [^]           => { $crate::token::Caret };
    [^=]          => { $crate::token::CaretEq };
    [:]           => { $crate::token::Colon };
    [,]           => { $crate::token::Comma };
    [$]           => { $crate::token::Dollar };
    [.]           => { $crate::token::Dot };
    [..]          => { $crate::token::DotDot };
    [...]         => { $crate::token::DotDotDot };
    [..=]         => { $crate::token::DotDotEq };
    [=]           => { $crate::token::Eq };
    [==]          => { $crate::token::EqEq };
    [=>]          => { $crate::token::FatArrow };
    [>=]          => { $crate::token::Ge };
    [>]           => { $crate::token::Gt };
    [<-]          => { $crate::token::LArrow };
    [<=]          => { $crate::token::Le };
    [<]           => { $crate::token::Lt };
    [-]           => { $crate::token::Minus };
    [-=]          => { $crate::token::MinusEq };
    [!=]          => { $crate::token::Ne };
    [!]           => { $crate::token::Not };
    [|]           => { $crate::token::Or };
    [|=]          => { $crate::token::OrEq };
    [||]          => { $crate::token::OrOr };
    [::]          => { $crate::token::PathSep };
    [%]           => { $crate::token::Percent };
    [%=]          => { $crate::token::PercentEq };
    [+]           => { $crate::token::Plus };
    [+=]          => { $crate::token::PlusEq };
    [#]           => { $crate::token::Pound };
    [?]           => { $crate::token::Question };
    [->]          => { $crate::token::RArrow };
    [;]           => { $crate::token::Semi };
    [<<]          => { $crate::token::Shl };
    [<<=]         => { $crate::token::ShlEq };
    [>>]          => { $crate::token::Shr };
    [>>=]         => { $crate::token::ShrEq };
    [/]           => { $crate::token::Slash };
    [/=]          => { $crate::token::SlashEq };
    [*]           => { $crate::token::Star };
    [*=]          => { $crate::token::StarEq };
    [~]           => { $crate::token::Tilde };
    [_]           => { $crate::token::Underscore };
}
pub struct Match(pub Fragment);

impl ToTokens for Match {
    fn to_tokens(&self, out: &mut TokenStream) {
        match &self.0 {
            Fragment::Expr(expr) => {
                expr.to_tokens(out);
                <Token![,]>::default().to_tokens(out);
            }
            Fragment::Block(block) => {
                token::Brace::default().surround(out, |out| block.to_tokens(out));
            }
        }
    }
}
```

## quote!
å­—ç¬¦æµç»„åˆï¼Œåˆå¹¶å‡½æ•°
```rust
pub fn pretend_used(cont: &Container, is_packed: bool) -> TokenStream {
    let pretend_fields = pretend_fields_used(cont, is_packed);
    let pretend_variants = pretend_variants_used(cont);

    quote! {
        #pretend_fields
        #pretend_variants
    }
}
```

## çœŸå®æ¡ˆä¾‹

### tauri/tao
:::info[tao/tao-macros/src/lib.rs, line 190]
```rust
#[proc_macro]
pub fn android_fn(tokens: TokenStream) -> TokenStream {
  let tokens = parse_macro_input!(tokens as AndroidFnInput);
  let AndroidFnInput {
    domain,
    package,
    class,
    function,
    ret,
    args,
    non_jni_args,
    function_before,
  } = tokens;

  let domain = domain.to_string();
  let package = package.to_string().replace('_', "_1");
  let class = class.to_string();
  let args = args
    .into_iter()
    .enumerate()
    .map(|(i, t)| IdentArgPair(format_ident!("a_{}", i), t))
    .collect::<Vec<_>>();
  let non_jni_args = non_jni_args.into_iter().collect::<Vec<_>>();

  let java_fn_name = format_ident!(
    "Java_{domain}_{package}_{class}_{function}",
    domain = domain,
    package = package,
    class = class,
    function = function,
  );

  let args_ = args.iter().map(|a| &a.0);

  let ret = if let Some(ret) = ret {
    syn::ReturnType::Type(
      syn::token::RArrow(proc_macro2::Span::call_site()),
      Box::new(ret),
    )
  } else {
    syn::ReturnType::Default
  };

  let comma_before_non_jni_args = if non_jni_args.is_empty() {
    None
  } else {
    Some(syn::token::Comma(proc_macro2::Span::call_site()))
  };

  quote! {
    #[no_mangle]
    unsafe extern "C" fn #java_fn_name<'local>(
      env: JNIEnv<'local>,
      class: JClass<'local>,
      #(#args),*
    )  #ret {
      #function_before();
      #function(env, class, #(#args_),*  #comma_before_non_jni_args #(#non_jni_args),*)
    }

  }
  .into()
}
```
è¿™æ®µä»£ç æ˜¯ä¸€ä¸ª Rust çš„è¿‡ç¨‹å®ï¼Œç”¨äºç”Ÿæˆ Android Native Interface (JNI) å‡½æ•°çš„ Rust ç»‘å®šã€‚è¿‡ç¨‹å®åœ¨ Rust ä¸­æ˜¯ä¸€ç±»å¼ºå¤§çš„å®ï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶å¯¹ä»£ç è¿›è¡Œåˆ†æå’Œç”Ÿæˆæ–°çš„ä»£ç ã€‚è¿™ä¸ªç‰¹å®šçš„å® `android_fn` æ¥å—ç‰¹å®šçš„è¾“å…¥å¹¶ç”Ÿæˆ JNI å‡½æ•°çš„ Rust ä»£ç ã€‚è®©æˆ‘ä»¬é€æ­¥åˆ†æè¿™æ®µä»£ç ï¼š

### å±æ€§å’Œå‡½æ•°ç­¾å

```rust
#[proc_macro]
pub fn android_fn(tokens: TokenStream) -> TokenStream {
```
- `#[proc_macro]`: è¿™ä¸ªå±æ€§è¡¨æ˜ `android_fn` æ˜¯ä¸€ä¸ªè¿‡ç¨‹å®ï¼Œå…·ä½“æ¥è¯´æ˜¯ç”¨äºå¤„ç†è¿‡ç¨‹å®çš„è¾“å…¥ã€‚
- `pub fn android_fn(tokens: TokenStream) -> TokenStream`: å‡½æ•°æ¥æ”¶å¹¶è¿”å› `TokenStream`ï¼Œè¿™æ˜¯ Rust å®çš„è¾“å…¥å’Œè¾“å‡ºç±»å‹ã€‚

### è§£æè¾“å…¥

```rust
let tokens = parse_macro_input!(tokens as AndroidFnInput);
```
- ä½¿ç”¨ `parse_macro_input!` å®è§£æè¾“å…¥çš„ `TokenStream` ä¸º `AndroidFnInput` ç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä½“åº”è¯¥ç”±å¼€å‘è€…å®šä¹‰ï¼Œç”¨äºå­˜å‚¨è§£æåçš„è¾“å…¥æ•°æ®ã€‚

### åˆ†è§£ç»“æ„ä½“

```rust
let AndroidFnInput {
    domain,
    package,
    class,
    function,
    ret,
    args,
    non_jni_args,
    function_before,
} = tokens;
```
- åˆ†è§£ `AndroidFnInput` ç»“æ„ä½“ä¸ºå¤šä¸ªéƒ¨åˆ†ï¼ŒåŒ…æ‹¬åŸŸã€åŒ…ã€ç±»ã€å‡½æ•°åã€è¿”å›ç±»å‹ã€å‚æ•°ã€é JNI å‚æ•°å’Œå‡½æ•°æ‰§è¡Œå‰çš„ä»£ç ã€‚

### å¤„ç†æ ‡è¯†ç¬¦å’Œå‚æ•°

```rust
let domain = domain.to_string();
let package = package.to_string().replace('_', "_1");
let class = class.to_string();
let args = args
    .into_iter()
    .enumerate()
    .map(|(i, t)| IdentArgPair(format_ident!("a_{}", i), t))
    .collect::<Vec<_>>();
let non_jni_args = non_jni_args.into_iter().collect::<Vec<_>>();
```
- å°†åŸŸã€åŒ…å’Œç±»è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚
- å‚æ•°è¢«è½¬æ¢å¹¶ç¼–å·ï¼Œç”Ÿæˆæ–°çš„æ ‡è¯†ç¬¦ã€‚

### ç”Ÿæˆ JNI å‡½æ•°å

```rust
let java_fn_name = format_ident!(
    "Java_{domain}_{package}_{class}_{function}",
    domain = domain,
    package = package,
    class = class,
    function = function,
);
```
- ä½¿ç”¨ `format_ident!` å®ç”Ÿæˆ JNI å‡½æ•°çš„åç§°ã€‚

### å¤„ç†è¿”å›ç±»å‹

```rust
let ret = if let Some(ret) = ret {
    syn::ReturnType::Type(
      syn::token::RArrow(proc_macro2::Span::call_site()),
      Box::new(ret),
    )
  } else {
    syn::ReturnType::Default
  };
```
- æ ¹æ®æ˜¯å¦æœ‰è¿”å›ç±»å‹ç”Ÿæˆç›¸åº”çš„è¿”å›ç±»å‹è¡¨è¾¾å¼ã€‚

### ç”Ÿæˆä»£ç 

```rust
quote! {
    #[no_mangle]
    unsafe extern "C" fn #java_fn_name<'local>(
      env: JNIEnv<'local>,
      class: JClass<'local>,
      #(#args),*
    )  #ret {
      #function_before();
      #function(env, class, #(#args_),*  #comma_before_non_jni_args #(#non_jni_args),*)
    }
}
```
- ä½¿ç”¨ `quote!` å®ç”Ÿæˆ JNI å‡½æ•°çš„å®Œæ•´å®šä¹‰ï¼ŒåŒ…æ‹¬å‡½æ•°å±æ€§ã€ç­¾åã€å‚æ•°å’Œå‡½æ•°ä½“ã€‚

### è¿”å›ç”Ÿæˆçš„ä»£ç 

```rust
.into()
```
- å°†ç”Ÿæˆçš„ `TokenStream` è¿”å›ã€‚

### æ€»ç»“

è¿™ä¸ªå® `android_fn` ç”¨äºç”Ÿæˆ JNI å‡½æ•°çš„ Rust ç»‘å®šï¼Œä½¿å¾— Rust ä»£ç å¯ä»¥ä¸ Java ä»£ç äº’æ“ä½œã€‚å®ƒå¤„ç†è¾“å…¥å‚æ•°ï¼Œç”Ÿæˆé€‚å½“çš„ JNI å‡½æ•°åå’Œå‡½æ•°ä½“ï¼Œå¹¶ç¡®ä¿æ‰€æœ‰å‚æ•°å’Œè¿”å›ç±»å‹æ­£ç¡®å¤„ç†ã€‚è¿™æ˜¯ Rust ç”Ÿæ€ä¸­ä¸ JNI äº’æ“ä½œçš„å¸¸è§æ¨¡å¼ã€‚

:::